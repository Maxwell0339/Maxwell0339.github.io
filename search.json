[{"title":"å¦‚ä½•ä½¿ç”¨LaTexå†™æ–‡ç« ï¼Ÿ","path":"/2025/03/25/20250325/","content":"å‰è¨€ ä¸ªäººä¸æ˜¯ç‰¹åˆ«æ¨èä½¿ç”¨vscodeæˆ–è€…Texstudioå»æ­å»ºLatexä¹¦å†™ç¯å¢ƒã€‚ä½¿ç”¨ overleafåœ¨çº¿ç¼–è¾‘ æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œè™½ç„¶æœ‰æ—¶å€™ç¼–è¯‘çš„æ—¶é—´ä¼šæ¯”è¾ƒæ…¢ã€‚ ä»€ä¹ˆæ˜¯ LaTeXï¼ŸLaTeX æ˜¯åŸºäº TeX è¯­æ³•ä½“ç³»çš„æ’ç‰ˆå·¥å…·ï¼Œé€šè¿‡ä»£ç å®ç°å†…å®¹ä¸æ ·å¼çš„åˆ†ç¦»å¼å†™ä½œã€‚ ç›¸è¾ƒäºWordï¼Œæˆ‘æ›´ä¸ºé’çLaTeXçš„ä¸»è¦åŸå› åœ¨äºå…¶å“è¶Šçš„æ’ç‰ˆè¡¨ç°ï¼Œå°¤å…¶åœ¨æ•°å­¦å…¬å¼å¤„ç†æ–¹é¢ä¼˜åŠ¿æ˜¾è‘—ã€‚å°½ç®¡Wordå¯é€šè¿‡MathTypeç­‰æ’ä»¶å®ç°å…¬å¼ç¼–è¾‘ï¼Œä½†LaTeXå‡­å€Ÿå…¶åŸç”Ÿæ”¯æŒçš„å…¬å¼æ’ç‰ˆç³»ç»Ÿï¼Œåœ¨æ•°å­¦ç¬¦å·çš„ç²¾ç¡®å®šä½ã€å…¬å¼ç»“æ„çš„ä¸“ä¸šå‘ˆç°ä»¥åŠæ•´ä½“è§†è§‰åè°ƒæ€§æ–¹é¢å§‹ç»ˆä¿æŒç€æ˜æ˜¾ä¼˜åŠ¿ã€‚è¿™ç§ç”±ä»£ç é©±åŠ¨çš„æ’ç‰ˆæœºåˆ¶ï¼Œä½¿å¾—æœ€ç»ˆè¾“å‡ºçš„æ–‡æ¡£åœ¨å­¦æœ¯ä¸¥è°¨æ€§å’Œç‰ˆå¼ç¾è§‚åº¦ä¸Šéƒ½æ›´èƒœä¸€ç­¹ã€‚ æœ¬æ–‡å°†ä»¥æ—¥å¸¸å®è·µä¸ºä¾‹ï¼Œåˆ†äº« LaTeX çš„å¸¸ç”¨æŒ‡ä»¤ä¸æ’ç‰ˆæŠ€å·§ã€‚ å¼€å§‹å¦‚ä½•å¼€å§‹ä½ çš„LaTexå†™ä½œä¹‹æ—…ï¼Ÿ é¦–å…ˆå…ˆç¡®å®šä½ çš„æ–‡ç« ç±»å‹ã€‚è¿™æ˜¯è‡³å…³é‡è¦çš„åŸºç¡€å·¥ä½œï¼Œä¸åŒæ–‡æ¡£ç±»å‹å¯¹åº”ä¸åŒçš„æ’ç‰ˆè§„èŒƒã€‚æˆ‘æ¯”è¾ƒå–œæ¬¢å»ä½¿ç”¨å¤§ä½¬ä»¬é…ç½®å¥½çš„å†™ä½œæ¨¡æ¿ï¼Œèƒ½å¤§å¤§èŠ‚çœæˆ‘å»è®¾ç½®å†™ä½œç¯å¢ƒï¼ˆä¾‹å¦‚å­—ä½“ï¼Œè¡Œé—´è·ç­‰ï¼‰çš„æ—¶é—´ã€‚å½“ç„¶å¦‚æœä½ æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨åˆ«äººçš„æ¨¡æ¿çš„è¯ï¼Œæˆ‘å»ºè®®è®¤çœŸå»çœ‹æ¨¡æ¿é¡¹ç›®çš„READMEæ–‡ä»¶ã€‚ é‚£ä¹ˆæ¥ä¸‹æ¥å°±æ­£å¼å¼€å§‹ä½ çš„å†™ä½œç¯èŠ‚äº†ï¼ æ‰“å¼€Overleafå®˜æ–¹ç½‘ç«™ï¼Œæ³¨å†Œè´¦å·ï¼Œç™»å½•ï¼Œåˆ›å»ºæ–°é¡¹ç›®ï¼Œå°±å¯ä»¥å»åˆ›å»ºLaTexé¡¹ç›®äº†ã€‚ è¯­æ³•ç¯å¢ƒåœ¨é¡¹ç›®ä¸»æ–‡ä»¶.texä¸­ï¼Œæˆ‘ä»¬çš„æ–‡ç« å†…å®¹éƒ½ä¼šåŒ…å«åœ¨ï¼š 123\\begin&#123;document&#125;\\end&#123;document&#125; ä¸€èˆ¬æ¥è¯´ï¼Œ\\begin&#123;document&#125;å‰é¢è¿˜ä¼šè®¾ç½®æ–‡æ¡£å±æ€§ä»¥åŠä¼šç”¨åˆ°çš„å®åŒ…ã€‚ å®åŒ…æ˜¯ç”¨æ¥æ‰©å±•/å¢å¼ºLaTeXçš„åŠŸèƒ½ï¼Œå®åŒ…ä¸LaTeXçš„å…³ç³»å’Œæµè§ˆå™¨æ’ä»¶ä¸æµè§ˆå™¨çš„å…³ç³»ç±»ä¼¼ï¼Œé€šè¿‡å®‰è£…ä¸åŒçš„å®åŒ…å¯ä»¥å®ç°ä¸€äº›å¤æ‚æ’ç‰ˆåŠŸèƒ½ï¼Œä¾‹å¦‚æ’å…¥å¤æ‚çš„åˆ—è¡¨è¡¨æ ¼ã€æ’å…¥å…¬å¼å’Œç‰¹æ®Šç¬¦å·ã€æ’å…¥ä»£ç ã€è®¾ç½®æ–‡æ¡£ç‰ˆå¼ç­‰ã€‚ ä½¿ç”¨\\usepackage&#123;&#125;æ¥æ·»åŠ ä½ æƒ³è¦çš„å®åŒ…ã€‚å¸¸è§çš„å®åŒ…æœ‰: 123456789101112131415161718192021\\usepackage&#123;graphicx&#125; %è¿™ä¸ªå®åŒ…å¼•å…¥äº†æ’å›¾å‘½ä»¤ \\includegraphicsï¼Œæˆ‘ä»¬çš„æ–‡æ¡£å¦‚æœéœ€è¦æ’å›¾éƒ½å°†ç”¨åˆ°å®ƒã€‚\\usepackage&#123;amsmath&#125;\\usepackage&#123;mathtools&#125;%è¿™æ˜¯ä¸¤ä¸ªå¸¸è§çš„æ•°å­¦æ‰©å±•åŒ…,æä¾›æ›´å¤šçš„æ•°å­¦ç¬¦å·ç­‰\\usepackage&#123;geometry&#125;%ä¿®æ”¹é¡µé¢å°ºå¯¸ã€é¡µè¾¹è·ã€é¡µçœ‰é¡µè„šç­‰å‚æ•°\\usepackage&#123;float&#125;%ä¸ºæµ®åŠ¨ä½“æä¾›ä¸æµ®åŠ¨çš„ H æ¨¡å¼ï¼›æä¾›è‡ªå®šä¹‰æµ®åŠ¨ä½“ç»“æ„çš„åŠŸèƒ½\\usepackage&#123;tikz&#125;%tikzç»˜å›¾ç¥å™¨,å¯ä»¥ç”¨äºç»˜åˆ¶ä¸€äº›æµç¨‹å›¾ç­‰\\usepackage&#123;ctex&#125;%é¢å‘ä¸­æ–‡çš„æ’ç‰ˆæ¡†æ¶ï¼Œå¦‚æœæ–‡ç« å†…å®¹ä¸ºä¸­æ–‡è¯·æ·»åŠ è¯¥å®åŒ…ã€‚\\usepackage&#123;cite&#125;%äº¤å‰å¼•ç”¨çš„å®åŒ… é™¤äº†å®åŒ…æŒ‡ä»¤ä»¥åŠä¸€äº›æ–‡æ¡£é…ç½®æŒ‡ä»¤å¤–ï¼Œå‰©ä¸‹æˆ‘ä»¬æ‰€æœ‰çš„å†…å®¹éƒ½éœ€è¦åœ¨\\begin&#123;document&#125;å’Œ\\end&#123;document&#125;ä¸­ã€‚ ç”±äºLatexä¸æ”¯æŒä¸­æ–‡ï¼Œéœ€è¦ä½¿ç”¨ctexå®åŒ…ã€‚è¿˜éœ€è¦åœ¨å·¦ä¸Šè§’çš„èœå•ä¸­å°†ç¼–è¯‘æ–¹å¼æ”¹æˆXeLaTexã€‚ æ ‡é¢˜è®¾ç½®LaTexå¯ä»¥è®¾ç½®ä¸åŒçº§åˆ«çš„æ ‡é¢˜ï¼ŒåŸºæœ¬çš„æ ¼å¼ä¸º 123\\section&#123;ä¸€çº§æ ‡é¢˜&#125;\\subsection&#123;äºŒçº§æ ‡é¢˜&#125;\\subsubsection&#123;ä¸‰çº§æ ‡é¢˜&#125; Latexæœ€å¤šæ”¯æŒä¸ƒçº§ç»“æ„ï¼špartã€chapterã€sectionã€subsectionã€subsubsectionã€paragraphã€subparagraphã€‚ æˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨ä¸Šé¢åˆ—å‡ºçš„ä¸‰ç§ç»“æ„ã€‚å¦‚æœéœ€è¦ç”Ÿæˆç›®å½•ï¼Œåœ¨ç¬¬ä¸€ä¸ªæ ‡é¢˜å‰ä½¿ç”¨\\tebleofcontentså³å¯ç”Ÿæˆç›®å½•ã€‚ æœ‰åºåˆ—è¡¨å’Œæ— åºåˆ—è¡¨ä½¿ç”¨\\begin&#123;enumerate&#125;åˆ›å»ºæœ‰åºåˆ—è¡¨ 1234\\begin&#123;enumerate&#125; \\item ä½ çš„å†…å®¹1 \\item ä½ çš„å†…å®¹2\\end&#123;enumerate&#125; ä½¿ç”¨\\begin&#123;itemize&#125;åˆ›å»ºæ— åºåˆ—è¡¨ 1234\\begin&#123;itemize&#125; \\item ä½ çš„å†…å®¹1 \\item ä½ çš„å†…å®¹2\\end&#123;itemize&#125; æ­£æ–‡åˆ†æ®µä¸€èˆ¬æ¥è¯´ï¼ŒLaTeXé»˜è®¤çš„ç¬¬ä¸€æ®µä¸æ˜¯é¦–è¡Œç¼©è¿›çš„, è¿™ä¸ç¬¦åˆæˆ‘ä»¬çš„ä¸­æ–‡ä¹ æƒ¯ã€‚è¦å®ç°é¦–è¡Œç¼©è¿›ä¹Ÿå¾ˆç®€å•ã€‚è¯·ä½¿ç”¨\\setlength&#123;\\parindent&#125;&#123;2em&#125; è®¾ç½®å…¨å±€é¦–è¡Œç¼©è¿›ä¸¤ä¸ªå­—ç¬¦ï¼ˆéœ€è¦ä½¿ç”¨å®åŒ…\\usepackage&#123;indentfirst&#125;ï¼‰ã€‚ å¦‚æœéœ€è¦å–æ¶ˆæŸä¸ªæ®µè½çš„é¦–è¡Œç¼©è¿›ï¼Œè¯·åœ¨è¯¥æ®µè½å‰ä½¿ç”¨ oindentã€‚å¦‚æœéœ€è¦å…¨å±€å–æ¶ˆé¦–è¡Œç¼©è¿›ï¼Œè¯·ä½¿ç”¨\\setlength&#123;\\parindent&#125;&#123;0pt&#125; LaTexæ˜¯å¦‚ä½•åŒºåˆ†æ®µè½çš„å‘¢ï¼Ÿåªéœ€è¦åœ¨ä¸¤æ®µæ–‡å­—ä¹‹é—´å¢åŠ ä¸€è¡Œç©ºç™½æ®µè½å³å¯ï¼ä¾‹å¦‚ 12345\\begin&#123;document&#125; è¿™æ˜¯ä¸€æ®µæ–‡å­—ã€‚ è¿™æ˜¯å¦ä¸€æ®µæ–‡å­—ã€‚\\end&#123;document&#125; å›¾ç‰‡æ·»åŠ ä½¿ç”¨\\usepackage&#123;graphicx&#125;å®åŒ…åï¼Œå°±å¯ä»¥åœ¨LaTexæ­£æ–‡æ·»åŠ å›¾ç‰‡äº†ã€‚åŸºæœ¬çš„è¯­æ³•è§„åˆ™ä¸ºï¼š 123456\\begin&#123;figure&#125;[htbp] \\centering \\includegraphics[scale=0.2]&#123;example.png&#125; \\caption&#123;figure title&#125; \\label&#123;figure&#125;\\end&#123;figure&#125; è§£é‡Šï¼š \\begin&#123;figure&#125;å’Œ\\end&#123;figure&#125;æ˜¯å›ºå®šçš„ç”¨æ³•ï¼Œç”¨äºæ’å…¥å›¾ç‰‡ã€‚ \\centeringè¡¨ç¤ºå°†å›¾ç‰‡ç½®ä¸­ã€‚ \\caption&#123;å›¾ç‰‡æ ‡é¢˜&#125;ç”¨æ¥è®¾ç½®å›¾ç‰‡æ ‡é¢˜ \\label&#123;æ ‡ç­¾&#125;ç”¨æ¥è®¾ç½®æ ‡ç­¾ï¼Œå¯ä»¥è®©å›¾ç‰‡åœ¨æ­£æ–‡ä¸­è¢«å¼•ç”¨ã€‚ä½¿ç”¨\\cite&#123;label&#125;æŒ‡ä»¤åœ¨æ­£æ–‡ä¸­ç”Ÿæˆå¼•ç”¨è§’æ ‡ã€‚ è®°å¾—è¦å°†æ·»åŠ çš„å›¾ç‰‡æ·»åŠ åˆ°é¡¹ç›®æ–‡ä»¶å¤¹å†…ï¼Œå¯ä»¥æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ç”¨æ¥å­˜æ”¾å›¾ç‰‡ï¼Œä¹Ÿå¯ä»¥å°†å›¾ç‰‡å’Œ.texæ–‡ä»¶æ”¾åœ¨åŒç›®å½•å†…ã€‚\\includegraphics[]&#123;&#125;çš„ç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯å›¾ç‰‡çš„æ–‡ä»¶åœ°å€ã€‚ å›¾ç‰‡çš„ä½ç½®ä¹Ÿå¯ä»¥é€šè¿‡å‚æ•°æ§åˆ¶ã€‚\\begin&#123;figure&#125;[htbp]ä¸­çš„htbpå°±å¯ä»¥æ§åˆ¶å›¾ç‰‡ä½ç½®ã€‚å…·ä½“æ„ä¹‰å¦‚ä¸‹ï¼š hï¼šè¡¨ç¤ºå½“å‰ä½ç½®ï¼ˆhereï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´å›¾ç‰‡å°†æ”¾åœ¨ä½ è®¾ç½®çš„å½“å‰ä½ç½®ï¼Œä½†æ˜¯å¦‚æœè¿™ä¸€é¡µçš„ç©ºé—´ä¸è¶³ä»¥æ”¾ä¸‹è¿™ä¸ªå›¾ç‰‡ï¼Œæ­¤æ—¶å›¾ç‰‡ä¼šè½¬åˆ°ä¸‹ä¸€é¡µï¼› tï¼šé¡¶ç«¯ï¼ˆtopï¼‰ï¼Œæ­¤æ—¶ä¼˜å…ˆå°†å›¾ç‰‡æ”¾ç½®åœ¨é¡µé¢çš„é¡¶éƒ¨ï¼› bï¼šåº•éƒ¨ï¼ˆbottomï¼‰æ­¤æ—¶ä¼˜å…ˆå°†å›¾ç‰‡æ”¾ç½®åœ¨é¡µé¢åº•éƒ¨ï¼› pï¼šå°†å›¾ç‰‡è®¾ç½®ä¸ºæµ®åŠ¨çŠ¶æ€ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ’ç‰ˆå›¾ç‰‡çš„ä½ç½®ã€‚ è¡¨æ ¼æ·»åŠ é¦–å…ˆï¼Œç»˜åˆ¶ä¸€å¼ è¡¨æ ¼éœ€è¦åˆ›å»ºtable å’Œ tabular ç¯å¢ƒã€‚åœ¨æ–‡ç« å¼€å¤´è¿˜éœ€è¦åŠ ä¸Šå®åŒ…\\usepackage&#123;array&#125;ã€‚ä¸€ä¸ªç®€å•çš„è¡¨æ ¼ç»˜åˆ¶ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213\\begin&#123;table&#125;[!htp] \\centering \\caption&#123;Start with a simple form&#125; \\label&#123;one&#125; \\begin&#123;tabular&#125;&#123;l|c|r&#125; \\hline 1 &amp; 2 &amp; 3 \\\\ \\hline 01 &amp; 02 &amp; 03 \\\\ \\hline 001 &amp; 002 &amp; 003 \\\\ \\hline \\end&#123;tabular&#125; \\end&#123;table&#125; æ•ˆæœï¼š è¡¨æ ¼çš„å…·ä½“å†…å®¹ä½äº\\begin&#123;tabular&#125;å’Œ\\end&#123;tabular&#125; ä¹‹é—´ï¼Œä¿®æ”¹å…¶ä¸­çš„å†…å®¹å°±å¯ä»¥ä¿®æ”¹è¡¨æ ¼äº†ã€‚ &#123;l|c|r&#125;æ˜¯æ¥çº¦å®šè¡¨æ ¼çš„æ¯åˆ—å±æ€§çš„ã€‚ç”¨|åˆ†å‰²å’Œæ·»åŠ åˆ— \\hlineç»˜åˆ¶ä¸€æ¡æ¨ªçº¿ç”¨æ¥åˆ†éš”è¡¨æ ¼æ¯ä¸€è¡Œ \\\\æ˜¯æ¢è¡Œæ ‡å¿— &amp;æ˜¯åˆ—åˆ†éš”ç¬¦ï¼Œç”¨æ¥åŒºåˆ†æ²¡åˆ—çš„å…ƒç´  æ‰€ä»¥ä¸€ä¸ªåŸºæœ¬çš„è¡¨æ ¼å†…å®¹æ„é€ æ˜¯ç”±ä»¥ä¸Šå…ƒç´ çš„æ„æˆã€‚å¦‚æœéœ€è¦è¿›è¡Œé«˜é˜¶æ“ä½œä¾‹å¦‚å•å…ƒæ ¼åˆå¹¶ï¼Œåç»­ä¼šå¼€ä¸€ä¸ªä¸“æ å»è®²è§£ä¸€äº›å›¾ç‰‡å’Œè¡¨æ ¼çš„ä¸€äº›æ›´é«˜é˜¶çš„æ“ä½œã€‚ æ•°å­¦å…¬å¼æˆ‘æœ€æ¬£èµLaTexçš„ä¸€ç‚¹å°±æ˜¯å®ƒçš„æ•°å­¦å…¬å¼ç¼–è¾‘åŠŸèƒ½äº†ã€‚å¦‚æœä½ æƒ³åœ¨ä½ çš„æ–‡å­—æ®µè½ä¸­æ·»åŠ æ•°å­¦å…¬å¼ï¼Œä½¿ç”¨ä¸€ä¸ªç¾å…ƒç¬¦å·$æ¥åŒ…å«è¿™ä¸ªå…¬å¼ã€‚ 123\\begin&#123;document&#125; è¿™æ˜¯ä½ çš„å†…å®¹ï¼Œæˆ‘ä»¬çš„æ•°å­¦å…¬å¼æ˜¯$y=x$ã€‚è¿™æ˜¯ä¸€ä¸ªæ­£æ¯”ä¾‹å‡½æ•°ã€‚\\end&#123;document&#125; æ•ˆæœä¸ºï¼š å¦‚æœè¯´ï¼Œä½ æƒ³è®©ä½ çš„æ•°å­¦å…¬å¼å¦èµ·ä¸€æ®µï¼Œåœ¨æ–°çš„ä¸€è¡Œæ·»åŠ éœ€è¦çš„æ•°å­¦å…¬å¼ï¼Œè¯·ä½¿ç”¨ä¸¤ä¸ªç¾å…ƒ$$$$ç¬¦å·æ¥åŒ…å«è¿™ä¸ªå…¬å¼ã€‚ 1234\\begin&#123;document&#125; è¿™æ˜¯ä½ çš„å†…å®¹ï¼Œæˆ‘ä»¬çš„æ•°å­¦å…¬å¼æ˜¯: $$y=2x$$\\end&#123;document&#125; æ•ˆæœä¸ºï¼š æˆ–è€…ï¼Œä½ éœ€è¦ç”¨åºå·æ¥ç¼–å·ä½ æ–‡ç« ä¸­çš„æ•°å­¦å…¬å¼ï¼Œä½¿ç”¨\\begin&#123;equation&#125;å’Œ\\end&#123;equation&#125;ï¼Œåœ¨è¿™ä¸¤æ®µå‘½ä»¤ä¹‹é—´æ·»åŠ å…¬å¼ï¼Œæ³¨æ„ä¸è¦ä½¿ç”¨ç¾å…ƒç¬¦å·äº†ï¼ 123456\\begin&#123;document&#125; è¿™æ˜¯ä½ çš„å†…å®¹ï¼Œæˆ‘ä»¬çš„æ•°å­¦å…¬å¼æ˜¯: \\begin&#123;equation&#125; y=3x \\end&#123;equation&#125;\\end&#123;document&#125; æ•°å­¦å…¬å¼å†…å®¹çš„ç¼–å†™ä¹Ÿæœ‰ç›¸åº”çš„è¯­æ³•ï¼Œä¸‹é¢ç»™å¤§å®¶åˆ—ä¸€äº›å¸¸è§çš„ç¬¦å·ï¼Œæ›´å¤šçš„å¯ä»¥ä½¿ç”¨Latexå…¬å¼ç¼–è¾‘å™¨å»ç¼–è¾‘å…¬å¼ã€‚ æè¿° è¯­æ³• æ•ˆæœ åˆ†æ•° \\frac&#123;a&#125;&#123;b&#125; $\\frac{a}{b}$ ç‚¹ä¹˜ A \\Cdot B $A\\cdot B$ å‰ä¹˜ A \\times B $A \\times B$ ä¸‹æ ‡ A_&#123;b&#125; $A_{b}$ ä¸Šæ ‡ A^&#123;b&#125; $A^{b}$ ä¸‰è§’å‡½æ•° \\sin a \\cos a \\tan a $\\sin a\\cos a\\tan a$ æ ¹å· \\sqrt&#123;A&#125; $\\sqrt{A}$ å‘é‡ \\overrightarrow&#123;a&#125; $\\overrightarrow{a}$ ç§¯åˆ† \\int_&#123;a&#125;^&#123;b&#125; $\\int_{a}^{b}$ å¾®åˆ† \\frac&#123;\\mathrm&#123;d&#125; y&#125;&#123;\\mathrm&#123;d&#125; x&#125; $\\frac{\\mathrm{d} y}{\\mathrm{d} x}$ å‚è€ƒæ–‡çŒ®åœ¨è¿›è¡Œå­¦æœ¯ç›¸å…³çš„åˆ›ä½œæ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ å¿…è¦çš„å‚è€ƒæ–‡çŒ®ã€‚è¿™éƒ¨åˆ†æˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•ä½¿ç”¨BibTexæ·»åŠ ä½ éœ€è¦çš„å‚è€ƒæ–‡çŒ®ã€‚ ä»€ä¹ˆæ˜¯BibTexï¼ŸBibTeX æ˜¯æœ€ä¸ºæµè¡Œçš„å‚è€ƒæ–‡çŒ®æ•°æ®ç»„ç»‡æ ¼å¼ä¹‹ä¸€ã€‚BibTeX ä½¿ç”¨æ•°æ®åº“çš„çš„æ–¹å¼æ¥ç®¡ç†å‚è€ƒæ–‡çŒ®. BibTeX æ–‡ä»¶çš„åç¼€åä¸º .bibã€‚.bibæ–‡ä»¶ä¸­å‚è€ƒæ–‡çŒ®çš„åŸºæœ¬æ ¼å¼ä¸ºï¼š 123456789@article&#123;name1,author = &#123;ä½œè€…, å¤šä¸ªä½œè€…ç”¨ and è¿æ¥&#125;,title = &#123;æ ‡é¢˜&#125;,journal = &#123;æœŸåˆŠå&#125;,volume = &#123;å·20&#125;,number = &#123;é¡µç &#125;,year = &#123;å¹´ä»½&#125;,abstract = &#123;æ‘˜è¦, è¿™ä¸ªä¸»è¦æ˜¯å¼•ç”¨çš„æ—¶å€™è‡ªå·±å‚è€ƒçš„, è¿™ä¸€è¡Œä¸æ˜¯å¿…é¡»çš„&#125;&#125; è§£é‡Šï¼š @article æ˜¯æ–‡çŒ®ç±»å‹ï¼Œè¿˜æœ‰å…¶å®ƒæ ¼å¼, ä¾‹å¦‚ article, book, booklet, conference, inbook, incollection, inproceedingsï¼Œmanual, misc, mastersthesis, phdthesis, proceedings, techreport, unpublished ç­‰ç­‰ã€‚ä½¿ç”¨å¤§æ‹¬å·{}æ¥åŒ…å«æ–‡çŒ®çš„å±æ€§ã€‚ name1æ˜¯è¿™ç¯‡æ–‡ç« çš„åç§°æ ‡ç­¾ï¼Œåœ¨æ­£æ–‡ä¸­å¼•ç”¨æ—¶ä¼šç”¨åˆ°ã€‚ä¾‹å¦‚å¼•ç”¨æ—¶ï¼Œä½¿ç”¨\\cite&#123;name1&#125;æŒ‡ä»¤ã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±å»åˆ›å»ºè‡ªå·±çš„bibæ–‡ä»¶ã€‚åœ¨overleafçš„é¡¹ç›®ç•Œé¢ä¸­ï¼Œåœ¨å·¦ä¸Šè§’çš„æ–°å»ºæ–‡ä»¶å»åˆ›å»ºæ–°æ–‡ä»¶ï¼Œè¦å°†æ–‡ä»¶çš„åç¼€æ”¹æˆ.bibã€‚ å¤§å¤šæ—¶å€™ï¼Œæˆ‘ä»¬ä¸éœ€è¦è‡ªå·±å»æ‰‹å†™BibTexæ–‡çŒ®å†…å®¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è°·æ­Œå­¦æœ¯ä¸­æ‰¾åˆ°éœ€è¦æ–‡çŒ®çš„BibTexã€‚ æ‰“å¼€è°·æ­Œå­¦æœ¯)ï¼ˆéœ€è¦ç§‘å­¦ä¸Šç½‘ï¼Œå¯ä»¥è‡ªè¡Œæœç´¢ä¸€äº›é•œåƒç½‘ç«™ï¼‰ï¼Œæœç´¢æ–‡çŒ®æ ‡é¢˜æˆ–è€…å…³é”®è¯ï¼Œä¾‹å¦‚ï¼Œå¯¹äºè¿™ç¯‡æ–‡çŒ®ï¼Œé€‰æ‹©â€œå¼•ç”¨â€ å†é€‰æ‹©â€œBibTexâ€ï¼š å°†å‡ºç°çš„å†…å®¹å¤åˆ¶çš„ä½ çš„bibæ–‡ä»¶ä¸­ï¼Œå°±æˆåŠŸæ„å»ºä½ çš„æ–‡çŒ®æ•°æ®åº“äº†ã€‚ åœ¨åˆ›å»ºå®Œbibæ–‡ä»¶åï¼Œåœ¨\\begin&#123;document&#125;ä¸­ï¼Œæˆ‘ä»¬åœ¨æ­£æ–‡çš„æœ€åä½¿ç”¨ä¸€äº›æŒ‡ä»¤ï¼š 12\\bibliographystyle&#123;plain&#125;\\bibliography&#123;ref&#125; å…¶ä¸­\\bibliographystyle&#123;plain&#125;è¡¨ç¤ºå‚è€ƒæ–‡çŒ®çš„ç±»å‹ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œplainæ ·å¼åŸºæœ¬å°±æ»¡è¶³äº†å¤§éƒ¨åˆ†è¦æ±‚ã€‚Bibtex å‚è€ƒæ–‡çŒ®æ ·å¼_bibtex style-CSDNåšå®¢ä»‹ç»äº†ä¸€äº›å‚è€ƒæ–‡ä»¶æ ·å¼ä»¥åŠå¯¹åº”çš„æ•ˆæœã€‚ \\bibliography&#123;ref&#125;è¡¨ç¤ºäº†å‚è€ƒæ–‡çŒ®æ•°æ®åº“æ¥æºã€‚â€œrefâ€æ˜¯ä½ çš„bibæ–‡ä»¶åã€‚ä½ å¯ä»¥è®¾ç½®ä¸åŒçš„bibæ–‡ä»¶åã€‚ éœ€è¦åœ¨ä½ çš„æ­£æ–‡ä¸­ä½¿ç”¨\\cite&#123;&#125;æŒ‡ä»¤ã€‚å¦‚æœä¸€ä¸ªæ–‡ç« ä¸­æ²¡æœ‰\\cite å‘½ä»¤ï¼ŒBibTex å°±ä¸çŸ¥é“å“ªä¸€ä¸ªbibliographyæ˜¯éœ€è¦æ’å…¥çš„ã€‚æ‰€ä»¥å¿…é¡»åœ¨ä½ æ–‡ç« å¼•ç”¨çš„åœ°æ–¹åŠ å…¥\\citeã€‚ ç»“è¯­Latexçš„åŸºç¡€æ•™ç¨‹åˆ°è¿™é‡Œå°±å·®ä¸å¤šç»“æŸäº†ï¼Œåç»­ä¼šå°†ä¸€äº›é«˜é˜¶çš„LaTeä½¿ç”¨æ–¹æ³•æ›´æ–°åˆ°LaTexå­¦ä¹ ä¸“æ é‡Œï¼Œæ•¬è¯·æœŸå¾…ï¼","tags":["LaTex"],"categories":["å­¦ä¹ "]},{"title":"ä¸ºä»€ä¹ˆæˆ‘æƒ³å»ºç«‹è‡ªå·±çš„åšå®¢ç½‘ç«™","path":"/2025/03/23/20250324/","content":"è·ç¦»æˆ‘ä¸Šä¸€æ¬¡æ¥è§¦â€åšå®¢â€è¿™ä¸ªæ¦‚å¿µï¼Œå·²è¿‡å»åä½™å¹´ã€‚å½¼æ—¶æ–°æµªåšå®¢æ­£é£é¡ä¸€æ—¶ï¼Œæˆ‘æŒ‰ç…§ä¿¡æ¯æŠ€æœ¯è¯¾æœ¬ä¸Šçš„æŒ‡å¯¼æ³¨å†Œäº†äººç”Ÿç¬¬ä¸€ä¸ªåšå®¢è´¦å·ã€‚å¦‚ä»Šé‚£ä¸ªç½‘ç«™ä¼¼ä¹å·²åœæ­¢ç»´æŠ¤ï¼Œæ˜”æ—¥çš„è´¦å·ä¹Ÿæ—©å·²é—å¿˜åœ¨æ—¶å…‰é‡Œã€‚ è¿™ä¸ªåšå®¢è¯ç”Ÿçš„åŠ¨åŠ› æœ¬è´¨ä¸Šæ˜¯ä¸€ç§è®°å½•ç”Ÿæ´»çš„æ–¹å¼ï¼ å¦‚ä»Šäººä»¬è®°å½•ç”Ÿæ´»çš„æ–¹å¼å±‚å‡ºä¸ç©·ï¼Œä¸»æµç¤¾äº¤å¹³å°å‡ ä¹éƒ½å…·å¤‡åˆ†äº«ä¸è®°å½•çš„åŠŸèƒ½ã€‚ä½†å¯¹æˆ‘è€Œè¨€ï¼Œè¿™äº›å¹³å°å§‹ç»ˆç¼ºå°‘æŸç§éš¾ä»¥è¨€å–»çš„å½’å±æ„Ÿã€‚ å¶ç„¶é—´åœ¨äº’è”ç½‘ä¸Šçœ‹åˆ°æŠ€æœ¯å¤§ä½¬çš„ä¸ªäººåšå®¢â€”â€”ä¼˜é›…çš„ç•Œé¢è®¾è®¡ã€æ¸…æ™°çš„æ–‡æ¡£åˆ†ç±»ã€æµç•…çš„äº¤äº’ä½“éªŒï¼Œè¿˜æœ‰ç€ä»–ä»¬ç‹¬ç‰¹çš„ç”Ÿæ´»æ„Ÿæ‚Ÿã€‚ç€å®ä»¤äººå¿ƒå‘å¾€ä¹‹ã€‚ é‚£ä½•ä¸æ­å»ºè‡ªå·±çš„åšå®¢ç½‘ç«™ï¼Ÿè™½è¯´æ˜¯ä¸´æ—¶èµ·æ„ï¼Œä½†è¿™ä¸ªæƒ³æ³•ä¸€æ—¦èŒç”Ÿä¾¿æŒ¥ä¹‹ä¸å»ã€‚ ä»é›¶å¼€å§‹çš„æ­å»ºå†ç¨‹å¯¹äºæ¯«æ— å‰ç«¯ç»éªŒçš„æ–°æ‰‹è€Œè¨€ï¼Œç‹¬ç«‹å»ºç«™è°ˆä½•å®¹æ˜“ã€‚ç»è¿‡å¤§é‡èµ„æ–™æŸ¥é˜…ï¼Œæœ€ç»ˆé€‰æ‹©Hexoé™æ€åšå®¢æ¡†æ¶æ­é…Stellarä¸»é¢˜ã€‚ä»ç¯å¢ƒé…ç½®åˆ°ä¸»é¢˜è°ƒè¯•ï¼Œå†ç»æ•´ä¸ªé€šå®µçš„æ‘¸ç´¢ï¼Œè¿™ä¸ªåšå®¢çš„é›å½¢ç»ˆäºåˆç°ã€‚ å†…å®¹ä¸å±•æœ›æœ¬åšå®¢ä¸»è¦å­˜æ”¾ä¸ªäººå­¦ä¹ ç¬”è®°ä¸æŠ€æœ¯å¿ƒå¾—ï¼Œå†…å®¹éš¾å…å­˜åœ¨çº°æ¼ï¼Œæ³è¯·è¯»è€…ä¸åæŒ‡æ­£ï¼ç›®å‰ç½‘ç«™åŠŸèƒ½å°šæ˜¾å•è–„ï¼Œè®¡åˆ’åç»­é€æ­¥æ·»åŠ å¦‚ä¸‹ç»„ä»¶ï¼š å…¨å±€æœç´¢åŠŸèƒ½ è®¿å®¢è¯„è®ºç³»ç»Ÿ å†…å®¹äº¤äº’å¼æ¼”ç¤ºæ¨¡å— æŠ€æœ¯æ¢ç´¢æ°¸æ— æ­¢å¢ƒï¼Œè®©æˆ‘ä»¬å…±åŒè§è¯è¿™ä¸ªåšå®¢çš„æˆé•¿è½¨è¿¹ã€‚","tags":["åšå®¢"],"categories":["æ‚è°ˆ"]},{"title":"ME Control(EN)","path":"/notes/autocontrol.html","content":"Chap 1 IntroductionSec 1.1 Basic Concepts of Control DefinitionAutomatic control refers to the use of additional equipment or devices to make the machine, equipment, or production process automatically operate in accordance with the predetermined rule under a certain working state or parameter without the participation of anyone. An outstanding feature of automatic control systems is that the process of system automatic control is the process of information transmission and transformation. Sec 1.2 Feedback Control System DefinitionIf the output of the system is not brought back to affect the control part of the system, such a system is called an open-loop control system. DefinitionIf the output of the system acts on the control part through the feedback, forming a closed loop, such a system is called a closed-loop control system, also known as a Feedback Control System. Passive Feedback: It mainly acts on the control system through the difference between input and output. Positive Feedback: It boosts the input signal to make the system deviate from its original state. Sec 1.3 Control System Block Diagram A control system consists of the controlled plant and the control device. Several representations in block diagram: Sec 1.4 The Design Requirements Stability: Preconditions for normal operation of the control system. Rapidity: Dynamic performance, with indicators. Accuracy: The steady-state (after the transition) value should be as consistent as possible with the expected value. Chap2 Mathematical Model of Control System DefinitionA mathematical model is an expression that indicates the dynamic relationship between physical quantities (or variables) in a system. Sec 2.1 Differential Equation of Linear SystemLinear systems can apply the superposition principle, i.e., they have superposition and uniformity (homogeneity). General ExpressionThe mathematical equation of the linear system is: a_n \\frac{d^n c(t)}{dt^n} + a_{n-1} \\frac{d^{n-1} c(t)}{dt^{n-1}} + \\cdots + a_1 \\frac{dc(t)}{dt} + a_0 c(t) = b_m \\frac{d^m r(t)}{dt^m} + b_{m-1} \\frac{d^{m-1} r(t)}{dt^{m-1}} + \\cdots + b_1 \\frac{dr(t)}{dt} + b_0 r(t) Sec 2.2 Laplace Transform DefinitionA function $f(t)$ (original) defined in the interval $[0,\\infty]$, its Laplace transform $F(s)$ is defined as \\mathcal{L} [f(t)] = F(s) = \\int_{0}^{\\infty} f(t) e^{-st} dt The table below gives the Laplace Transform of some typical test waveforms: Item $f(t)$ $F(s)$ Impulse response $\\delta(t)$ $1$ Step response $u(t)$ $\\frac{1}{s}$ Ramp response $t u(t)$ $\\frac{1}{s^2}$ Polynomial response $t^n u(t)$ $\\frac{n!}{s^{n+1}}$ Exponential response $e^{-at} u(t)$ $\\frac{1}{s+a}$ Sinusoid response $\\sin \\omega t u(t)$ $\\frac{\\omega}{s^2 + \\omega^2}$ Cosine response $\\cos \\omega t u(t)$ $\\frac{s}{s^2 + \\omega^2}$ Theorem Linear:$L[af_1(t) \\pm bf_2(t)] = aF_1(s) \\pm bF_2(s)$ Differential:$L[f^{(n)}(t)] = s^n \\cdot F(s)$ Integral:$L\\left[\\int \\int f(t) dt\\right] = \\frac{1}{s^n} F(s)$ Real displacement:$L[f(t - \\tau_0)] = e^{-\\tau_0 s} \\cdot F(s)$ Complex displacement:$L[e^{At}f(t)] = F(s - A)$ Initial value:$\\lim_{t \\to 0} f(t) = \\lim_{s \\to \\infty} s \\cdot F(s)$ Terminal value:$\\lim_{t \\to \\infty} f(t) = \\lim_{s \\to 0} s \\cdot F(s)$ DefinitionInverse Laplace Transform: f(t) = \\mathcal{L}^{-1}[F(s)] = \\frac{1}{2\\pi j} \\int_{\\sigma - j\\infty}^{\\sigma + j\\infty} F(s) e^{st} ds Sec 2.3 Transfer Function DefinitionUnder zero initial conditions, the transfer function is the ratio of the Laplace transform of the output to the input: G(s) = \\frac{C(s)}{R(s)} = \\frac{b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_1 s + b_0}{a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_1 s + a_0} Sec 2.3.1 Basic properties The transfer function is a rational and proper fraction of the complex variable. The transfer function does not indicate the systemâ€™s physical characteristics or structure. The transfer function is only used for single-input single-output systems. Without zero-pole cancellation, the denominator polynomial is the systemâ€™s characteristic polynomial. Sec 2.3.2 Common forms Rational form: G(s) = \\frac{b_m s^m + \\cdots + b_0}{a_n s^n + \\cdots + a_0} Zero-pole form: G(s) = K^* \\frac{(s - z_1)\\cdots(s - z_m)}{(s - p_1)\\cdots(s - p_n)} Time constant form: G(s) = K \\frac{\\prod (\\tau_i s + 1) \\prod (\\tau_k^2 s^2 + 2\\xi_e \\tau_k s + 1)}{\\prod (\\tau_j s + 1) \\prod (T_l^2 s^2 + 2\\xi_e T_l s + 1)} Sec 2.3.3 Typical links Link Differential Equation Transfer Function Proportional $c = Kr$ $K$ First-order inertia $T\\dot{c} + c = r$ $\\frac{1}{Ts + 1}$ Second-order oscillation $T^2\\ddot{c} + 2\\xi T\\dot{c} + c = r$ $\\frac{1}{T^2s^2 + 2\\xi Ts + 1}$ Integral $\\dot{c} = r$ $\\frac{1}{s}$ Ideal differential $c = \\dot{r}$ $s$ Sec 2.4 Block Diagram of a System DefinitionA graphical representation of the signal transmission relationships between system components. The transfer function can be derived from the block diagram. Sec 2.4.1 Equivalent transformation rules Series blocks: Parallel blocks: Feedback connection: Open-loop transfer function: G(s) = G_1(s)G_2(s)H(s)Closed-loop transfer function: \\Phi(s) = \\frac{G(s)}{1 \\mp G_o(s)} For input signal (disturbance = 0): \\Phi(s) = \\frac{C(s)}{R(s)} = \\frac{G_1(s) G_2(s)}{1 + G_1(s) G_2(s) H(s)} For disturbance signal (input = 0): \\Phi_n(s) = \\frac{C(s)}{N(s)} = \\frac{G_2(s)}{1 + G_1(s)G_2(s)H(s)} Total output: C(s) = \\Phi(s)R(s) + \\Phi_n(s)N(s)= \\frac{1}{1 + G_1(s)G_2(s)H(s)} [G_1(s)G_2(s)R(s) + G_2(s)N(s)] \\textbf{when} $|G(s)H(s)| \\gg 1$ \\Phi(s) = \\approx \\frac{C(s)}{R(s)} = \\frac{G(s)}{1 \\mp G(s)H(s)} \\approx \\frac{1}{\\mp H(s)} When $H(s) = 1$ \\Phi(s) = \\frac{C(s)}{R(s)} = \\frac{G(s)}{1 \\mp G(s)H(s)} = \\frac{G(s)}{1 \\mp G(s)} When $H(s) = 1$, it is called unit feedback Sec 2.4.2 Equivalent Transformation Rules Signal lead backward: Signal lead forward: Comparison backward: Comparison forward:"},{"title":"Digital Circuit(EN)","path":"/notes/dc.html","content":"è¿™æ˜¯ä¸€ç¯‡æ‰‹å†™ç¬”è®°ï¼Œä¸‹é¢å¯¹åº”çš„PDFæ–‡ä»¶ ç›®å‰å­˜æ”¾åœ¨äº‘ç«¯ï¼Œè¿™æ˜¯äº‘ç«¯é“¾æ¥ æ•°ç”µç¬”è®°ã€‚"},{"title":"Forehead","path":"/notes/index.html","content":"å†™åœ¨å‰é¢é¢å‘æœŸæœ«çš„ç¬”è®°ï¼Œå…¨è‹±çš„ã€‚ï¼ˆè¯¾æ˜¯å…¨è‹±çš„è¯¾"},{"title":"Fundamentals of  Kalman Filter and Inertia Navigation(EN)","path":"/notes/kalman.html","content":"Basic Requirement Formulate an filtering problem. Build a state space model of a system. Solve linear state estimation problems with Kalman filter. Learn the principles of inertial navigation. Learn/implement basic INS-GNSS integrated navigation system. Lesson 1Why is Kalman filter so popular? Kalman filter is BULE (Best Linear Unbiased Estimator) Powerful Convenient to use Example1 - Measure the center temperature of a rocket flame Example2 - Data Merging Notation $e_{EST}$ â€”â€” state estimation error $e_{MEA}$ â€” measurement error $K$ â€” Kalman gain $X$ â€” true state $\\hat{X}$ â€” estimated state $y$ â€” measurement $K = \\frac{e_{EST}}{e_{EST} + e_{MEA}}$ $\\hat{X}_k = \\hat{X}_{k-1} + K(y - \\hat{y})$ $e_{EST} = (1 - K)e_{EST}$ Example3 - A simple 0-order Kalman filter $K = \\frac{E_{\\hat{X}}}{E_{\\hat{X}} + E_y}$ $\\hat{X}_t = \\hat{X}_{t-1} + K (y - \\hat{X}_{t-1})$ $E_{\\hat{X}_{t}} = (1 - K)E_{\\hat{X}_{t-1}}$ Lesson 2Numerical integration of differential equations Euler integration Consider a first-order differential equation of the form: \\dot{x} = f(x, t)We know from calculus that the definition of a derivative of a function can be approximated by \\dot{x} = f(x, t) = \\frac{x(t + h) - x(t)}{h} = \\frac{x_k - x_{k-1}}{h}for small $ h $ . Rearranging terms yields x_k = x_{k-1} + hf(x, t)The preceding equation is known as Euler integration. Second-order Rungeâ€“Kutta The second-order Rungeâ€“Kutta numerical integration procedure is easy to state. Given a first-order differential equation of the form: \\dot{x} = f(x, t)where $ t $ is time, we seek to find a recursive relationship for $ x $ as a function of time. With the second-order Rungeâ€“Kutta numerical technique the value of $ x $ at the next integration interval $ h $ is given by x_k = x_{k-1} + 0.5h[f(x, t) + f(x, t + h)]Finding the area under a curve using trapezoids is equivalent to second-order Rungeâ€“Kutta integration. Noise and random variables The mean squared value of $x$ is defined as: $E(x^2) = \\int_{-\\infty}^{\\infty} x^2 p(x) dx$ The root mean square or rms of $x$ is defined as: $rms = \\sqrt{E(x^2)}$ The variance of $x$ is defined as: $\\sigma^2 = E[x - E(x)]^2 = E(x^2) - E^2(x)$ If we have independent random variables $x_1, x_2 â€¦ x_n$ , then the variance of the sum can be shown to be the sum of the variances, $\\sigma^2 = \\sigma_1^2 + \\sigma_2^2 + \\cdots + \\sigma_n^2$ State space notationOften in this text we will put linear differential equations into state space form because this will be required for setting up a Kalman-filtering problem. With state-space notation we are saying that any set of linear differential equations can be put in the form of the first-order matrix differential equation \\dot{x} = Fx + Gu + w Example: Consider the second-order differential equation without any random inputs. \\ddot{y} + 2\\dot{y} + 3y = 4rewrite \\dot{y} = -2\\dot{y} - 3y + 4\\begin{bmatrix} \\dot{y} \\\\ \\dot{y} \\end{bmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -3 & -2 \\end{bmatrix} \\begin{bmatrix} y \\\\ \\dot{y} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 4 \\end{bmatrix}x = \\begin{bmatrix} y \\\\ \\dot{y} \\end{bmatrix}, F = \\begin{bmatrix} 0 & 1 \\\\ -3 & -2 \\end{bmatrix}, G = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, u = 4, w = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} Fundamental matrixIf the state-space form is: \\dot{x} = Fxwhere the systems dynamics matrix $F$ is time invariant, then we can say that there is a transition or fundamental matrix $\\Phi$ that can be used to exactly propagate the state forward from any time $t_0$ to time $t$ according to x(t) = \\Phi(t - t_0)x(t_0)Two simple ways of finding the fundamental matrix for time-invariant systems are by Laplace transforms and by Taylor-series expansion: Laplace transform technique: $\\Phi(t) = \\mathcal{L}^{-1} [(sI - F)^{-1}]$ Taylor-series expansion: $\\Phi(t) = e^{Ft} = I + Ft + \\frac{(Ft)^2}{2}{2!} + \\cdots + \\frac{(Ft)^n}{n!} + \\cdots$ Lesson 3Least squares methodWe will normally follow a three-step procedure for extracting information or estimating the characteristics of the signal based upon noisy measurement Assume a polynomial model to represent the actual signal. Try to estimate the coefficients of the selected polynomial by choosing a goodness of fit criterion. This is where Gauss comes in. The least squares criterion is the sum of the squares of the individual discrepancies between the estimated polynomial and measurement values of the actual signal contaminated by noise. Use calculus to minimize the sum of the squares of the individual discrepancies in order to obtain the best coefficients for the selected polynomial. Zero order of one-state filter For the zeroth-order case in which the best estimate is supposed to be a constant $a_0$: \\hat{x}_k = a_0Suppose we sample $n$ measurements $x^*_k$ of the data every $T_s$ seconds (i.e., $k$ goes from $1$ to $n$). R = \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = \\sum_{k = 1}^{n}(a_0 - x^*_k)^2where $R$ is the square of the summation of all the residuals or differences between the estimate and the measurement. Because we are only estimating one constant, this is also sometimes called a one-state system. From calculus we know that a function can be minimized by taking its derivative and setting the result equal to zero. R = \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = (a_0 - x^*_1)^2 + (a_0 - x^*_2)^2 + \\cdots + (a_0 - x^*_n)^2To minimize $R$ \\frac{\\partial R}{\\partial a_0} = 0 = 2(a_0 - x^*_1) + 2(a_0 - x^*_2) + \\cdots 2(a_0 - x^*_n)-x^*_1 - x^*_2 - \\cdots - x^*_n = -\\sum_{k = 1}^{n}x^*_k, \\quad a_0 + a_0 + \\cdots + a_0 = na_00 = na_0 - \\sum_{k = 1}^{n}x^*_ka_0 = \\frac{\\sum_{k = 1}^{n}x^*_k}{n}The preceding formula shows us that the best constant fit to a set of measurement data in the least squares sense is simply the average value of the measurements. First order or two-state filterSuppose we want to fit the measurement data with the best straight line (i.e., rather than a constant) in the least squares sense. This means we are seeking estimates to fit the first-order polynomial \\hat{x} = a_0 + a_1t, \\quad \\hat{\\dot{x}} = a_1in discrete notation \\hat{x}_k = a_0 + a_1(k - 1)T_s, \\quad \\hat{\\dot{x}}_k = a_1where $k$ is the number of measurements taken and $T_s$ is the sampling time. As before, the quantity to be minimized is still given by the summation of the square of the difference between the estimates and measurements or \\begin{align*} R =& \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = \\sum_{k = 1}^{n}[a_0 + a_1(k - 1)T_s - x^*_k]^2 \\\\ =& (a_0 - x^*_1)^2 + (a_0 + a_1T_s - x^*_2)^2 + \\cdots + [a_0 + a_1(n - 1)T_s - x^*_n]^2 \\end{align*}Again, according to calculus, we can minimize $R$ by setting its derivative with respect to $a_0$ and $a_1$ to zero or \\begin{align*} \\frac{\\partial R}{\\partial a_0} &= 0 \\\\=& 2(a_0 - x^*_1) + 2(a_0 + a_1T_s - x^*_2) + \\cdots + 2[a_0 + a_1(n - 1)T_s - x^*_n] \\end{align*}\\begin{align*} \\frac{\\partial R}{\\partial a_1} &= 0\\\\ =& 2(a_0 + a_1T_s - x^*_2)T_s + \\cdots + 2(n - 1)T_s[a_0 + a_1(n - 1)T_s - x^*_n] \\end{align*}Simplify: na_0 + a_1\\sum_{k = 1}^{n}(k - 1)T_s = \\sum_{k = 1}^{n}x^*_ka_0\\sum_{k = 1}^{n}(k - 1)T_s + a_1\\sum_{k = 1}^{n}[(k - 1)T_s]^2 = \\sum_{k = 1}^{n}(k - 1)T_sx^*_kmatrix form: \\begin{bmatrix} n & \\sum_{k = 1}^{n}(k - 1)T_s \\\\ \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\end{bmatrix} = \\begin{bmatrix} \\sum_{k = 1}^{n}x^*_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^*_k \\end{bmatrix} Lesson 4Second order LS filter*Second order polynomial model \\hat{x} = a_0 + a_1t + a_2t^2 \\hat{\\dot{x}} = a_1 + 2a_2t \\hat{\\ddot{x}} = 2a_2Discrete form \\hat{x}_k = a_0 + a_1(k - 1)T_s + a_2[(k - 1)T_s]^2matrix form: \\begin{align*} & \\begin{bmatrix} n & \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\\\ \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 & \\sum_{k = 1}^{n}[(k - 1)T_s]^3 \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2 & \\sum_{k = 1}^{n}[(k - 1)T_s]^3 & \\sum_{k = 1}^{n}[(k - 1)T_s]^4 \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{bmatrix} \\\\&= \\begin{bmatrix} \\sum_{k = 1}^{n}x^*_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^*_k \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2x^*_k \\end{bmatrix} \\end{align*} Third order LS filter*We can also fit the measurement data with the best cubic or third - order curve in the least squares sense. This means we are seeking estimates to fit the formula for the cubic \\hat{x} = a_0 + a_1t + a_2t^2 + a_3t^3or \\hat{x}_k = a_0 + a_1(k - 1)T_s + a_2[(k - 1)T_s]^2 + a_3[(k - 1)T_s]^3 Lesson 5Least-squares coefficients for different order polynomial fits to measurement data Order Equations Zeroth $a_0 = \\frac{\\sum_{k = 1}^{n}x^*_k}{n}$ First $\\begin{bmatrix}a_0 \\\\ a_1\\end{bmatrix} = \\begin{bmatrix}n &amp; \\sum_{k = 1}^{n}(k - 1)T_s \\\\ \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2\\end{bmatrix}^{-1}\\begin{bmatrix}\\sum_{k = 1}^{n}x^_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^_k\\end{bmatrix}$ Second $\\begin{bmatrix}a_0 \\\\ a_1 \\\\ a_2\\end{bmatrix} = \\begin{bmatrix}n &amp; \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\\\ \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^3 \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^3 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^4\\end{bmatrix}^{-1}\\begin{bmatrix}\\sum_{k = 1}^{n}x^_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^_k \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2x^*_k\\end{bmatrix}$ Accelerometer testing exampleAccelerometer measurements are taken for different accelerometer orientation angles. where $\\theta_ğ‘˜$ is the angle the accelerometer makes with the vertical for the $k$th measurement, $g$ is gravity. \\text{Theory} = g \\cos\\theta_kActually, the accelerometer output will also consist of additional terms caused by imperfections in the accelerometer. \\text{Output} = g \\cos\\theta_k + \\bm B + \\bm{SF}g \\cos\\theta_k + \\bm{K}(g \\cos\\theta_k)^2Therefore, the accelerometer error is simply the difference between the actual output and theory($\\theta_k$ is the actual angle and $\\theta^*_k$ is the measured angle): Error = Accelerometer Output â€“ Theory = g\\cos\\theta_k + B + SF \\ g\\cos\\theta_k + K(g\\cos\\theta_k)^2 - g\\cos\\theta^*_kInitially, the simulation is set up so there is no noise on the angle $\\theta^*_k$. The error or measurement equation for the first example will be given by: \\theta^*_k = \\theta_k, \\quad x_k = g\\cos\\theta_k, \\quad y^*_k = B + SF \\ g\\cos\\theta_k + K(g\\cos\\theta_k)^2Let $x_k = g\\cos\\theta_k$ then $y^*_k = B + SFx_k + K(x_k)^2$ Term Scientific value English units Bias error $B$ $10 \\ \\mu g$ $1010^{-6}32.2 = 0.000322 \\ \\text{ft}/\\text{s}^2$ Scale factor error $SF$ $5 \\ \\text{ppm}$ $5*10^{-6}$ $g$-squared sensitive drift $K$ $1 \\ \\mu g/\\text{g}^2$ $110^{-6}/32.2 = 3.10610^{-8} \\ \\text{s}^2/\\text{ft}$ No angle noise 1 $\\bm{\\mu r}$ of angle noise on the vertical angle Making Least-Squares filter recursiveIf we were trying to fit a zeroth - order polynomial or constant to a set of measurement data the best estimate can be expressed as \\hat{x}_k = a_0 = \\frac{\\sum_{i = 1}^{k}x^*_i}{k}By changing subscripts we can rewrite the preceding expression as \\hat{x}_{k + 1} = \\frac{\\sum_{i = 1}^{k + 1}x^*_i}{k + 1} = \\frac{\\sum_{i = 1}^{k}x^*_i + x^*_{k + 1}}{k + 1}\\sum_{i = 1}^{k}x^*_i = k\\hat{x}_k\\hat{x}_{k + 1} = \\frac{k\\hat{x}_k + x^*_{k + 1}}{k + 1}\\begin{align*} \\hat{x}_{k + 1} = \\frac{k\\hat{x}_k + \\hat{x}_k + x^*_{k + 1} - \\hat{x}_k}{k + 1} \\\\= \\frac{(k + 1)\\hat{x}_k + x^*_{k + 1} - \\hat{x}_k}{k + 1} \\\\= \\hat{x}_k + \\frac{1}{k + 1}(x^*_{k + 1} - \\hat{x}_k) \\end{align*}Recursive properties of One-State filtersThe form of the zeroth - order or one - state recursive least - squares filter is given by \\hat{x}_k = \\hat{x}_{k - 1} + K_{1k}Res_kgain: $K_{1k} = \\frac{1}{k} \\quad k = 1,2,\\cdots,n$ residual: $Res_k = x^*_k - \\hat{x}_{k - 1}$ We can see that the filter gain for the zeroth - order recursive least - squares filter is unity for the first measurement (i.e., $k = 1$) and eventually goes to zero as more measurements are taken. The batch-processing least squares estimates are only available after all of the measurements are taken ,whereas the recursive least-squares estimates are available as the measurements are being taken. Recursive properties of One-State filtersIf the actual measurement data are simply a constant plus noise (i.e., zeroth - order signal plus noise) where the measurement noise is a zero - mean Gaussian process with variance $\\sigma^2_n$. x^*_k = x_k + v_k\\begin{align*} x_k - \\hat{x}_k =& x_k - \\hat{x}_{k - 1} - \\frac{1}{k}(x^*_k - \\hat{x}_{k - 1}) \\\\=& x_k - \\hat{x}_{k - 1} - \\frac{1}{k}(x_k + v_k - \\hat{x}_{k - 1}) \\end{align*}However, because the signal is a constant for the zeroth - order system, we can also say that $x_k = x_{k - 1}$ x_k - \\hat{x}_k = (x_{k - 1} - \\hat{x}_{k - 1})\\left(1 - \\frac{1}{k}\\right) - \\frac{1}{k}v_k\\begin{align*} (x_k - \\hat{x}_k)^2 =& (x_{k - 1} - \\hat{x}_{k - 1})^2\\left(1 - \\frac{1}{k}\\right)^2 \\\\-& 2\\left(1 - \\frac{1}{k}\\right)(x_{k - 1} - \\hat{x}_{k - 1})\\frac{v_k}{k} + \\left(\\frac{1}{k}v_k\\right)^2 \\end{align*}\\begin{align*} E[(x_k - \\hat{x}_k)^2] =& E[(x_{k - 1} - \\hat{x}_{k - 1})^2]\\left(1 - \\frac{1}{k}\\right)^2 \\\\-& 2\\left(1 - \\frac{1}{k}\\right)E[(x_{k - 1} - \\hat{x}_{k - 1})v_k]\\frac{1}{k} + E\\left[\\left(\\frac{1}{k}v_k\\right)^2\\right] \\end{align*}If we define the variance of the error in the estimate to be $P_k$ and the variance of the measurement noise to be $\\sigma^2_n$ and also assume that the noise is uncorrelated with the state or the estimate of the state, we can say that E[(x_k - \\hat{x}_k)^2] = P_kE[v^2_k] = \\sigma^2_nE[(x_{k - 1} - \\hat{x}_{k - 1})v_k] = 0Substitution of the preceding three equations into the expectation equation yields the difference equation for the variance of the error in the estimate or P_k = P_{k - 1}\\left(1 - \\frac{1}{k}\\right)^2 + \\frac{\\sigma^2_n}{k^2}P_1 = P_0\\left(1 - \\frac{1}{1}\\right)^2 + \\frac{\\sigma^2_n}{1^2} = \\sigma^2_nP_2 = P_1\\left(1 - \\frac{1}{2}\\right)^2 + \\frac{\\sigma^2_n}{2^2} = \\sigma^2_n\\frac{1}{4} + \\frac{\\sigma^2_n}{4} = \\frac{\\sigma^2_n}{2}P_3 = P_2\\left(1 - \\frac{1}{3}\\right)^2 + \\frac{\\sigma^2_n}{3^2} = \\frac{\\sigma^2_n}{2}\\frac{4}{9} + \\frac{\\sigma^2_n}{9} = \\frac{\\sigma^2_n}{3}P_4 = P_3\\left(1 - \\frac{1}{4}\\right)^2 + \\frac{\\sigma^2_n}{4^2} = \\frac{\\sigma^2_n}{3}\\frac{9}{16} + \\frac{\\sigma^2_n}{16} = \\frac{\\sigma^2_n}{4}The trend in the preceding four equations is now obvious, and we can summarize these results by saying in general for the zeroth - order recursive least - squares filter that the variance of the error in the estimate is simply P_k = \\frac{\\sigma^2_n}{k} If the real signal is a first - order: x_k = a_0 + a_1t = a_0 + a_1(k - 1)T_sAs we saw the filter will not be able to track the signal. The resulting error in the estimate is known as truncation error: \\varepsilon_k = x_k - \\hat{x}_kIn the noise - free case: \\begin{align*} \\hat{x}_k&=\\frac{\\sum_{i = 1}^{k}x_i}{k}=\\frac{\\sum_{i = 1}^{k}[a_0 + a_1(i - 1)T_s]}{k} \\\\&= \\frac{a_0\\sum_{i = 1}^{k}1 + a_1T_s\\sum_{i = 1}^{k}i - a_1T_s\\sum_{i = 1}^{k}1}{k}\\\\ &=\\frac{a_0k + a_1T_s[k(k + 1)/2] - a_1T_sk}{k}\\\\&=a_0+\\frac{a_1T_s}{2}(k - 1) \\end{align*}The truncation error of the zeroth - order recursive least - squares filter: \\begin{align*} \\varepsilon_k = x_k - \\hat{x}_k &= a_0 + a_1T_s(k - 1) - a_0 - \\frac{a_1T_s}{2}(k - 1)\\\\&=\\frac{a_1T_s}{2}(k - 1) \\end{align*}As already noted, as more measurements are taken k gets larger, and the error in the estimate caused by the measurement noise decreases while the error in the estimate caused by truncation error increases. In principle, for any particular numerical example there is an optimal value of k that will minimize the errors in the estimates caused by both measurement noise and truncation error. Lesson 6"},{"title":"Robotics(EN)","path":"/notes/robotics.html","content":"Chap1. Spatial Descriptions and TransformationsSec 1.1 Descriptions: Positions, Orientations and Frames Descriptions of a position \\mathbf{^A P} = \\begin{bmatrix} P_x \\\\ P_y \\\\ P_z \\end{bmatrix}Position is represented in a column vector $(n \\times 1)$ Description of an orientation Rotation matrix {}^A_BR = \\left[ {}^A\\widehat{X}_B \\quad {}^A\\widehat{Y}_B \\quad {}^A\\widehat{Z}_B \\right] Properties Transpose of rotation matrix describing $ \\{A\\} $ relative to $\\{ B\\} $ equals to the matrix describing $ \\{ B \\} $ relative to $ \\{ A \\} $ : {}^A_BR = {}^B_AR^T Rotation matrix describing a rectangular coordinate system $\\{A \\} $ relative to another is orthogonal: {}^B_AR^{-1} = {}^B_AR^T Description of a frame A frame (coordinate system) can be described by a vector and a rotation matrix: \\{B\\} = \\{^A_BR, ^A\\mathbf{P}_{BORG}\\} Attention ${}^A_BR(x, \\alpha)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$â€™s x-axis by $\\alpha$ degrees ${}^A_BR(y, \\beta)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$â€™s y-axis by $\\beta$ degrees ${}^A_BR(z, \\gamma)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$â€™s z-axis by $\\gamma$ degrees Rotation Matrices: {}^A_BR(x, \\alpha) = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{bmatrix} {}^A_BR(y, \\beta) = \\begin{bmatrix} \\cos\\beta & 0 & \\sin\\beta \\\\ 0 & 1 & 0 \\\\ -\\sin\\beta & 0 & \\cos\\beta \\end{bmatrix} {}^A_BR(z, \\gamma) = \\begin{bmatrix} \\cos\\gamma & -\\sin\\gamma & 0 \\\\ \\sin\\gamma & \\cos\\gamma & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} Sec 1.2 MappingsMapping changes the description of a point from one frame to another. Mappings involving translated frames If $\\{A\\}$ and $\\{B\\}$ have the same orientation but differ by translation ${}^AP_{BORG}$: ^AP = ^BP + ^AP_{BORG}$$ Mappings involving rotated frames If $\\{A\\}$ and $\\{B\\}$ share the same origin but differ by rotation ${}^A_BR$: {}^AP = {}^A_BR \\, {}^BP Mapings involving general frames For frames differing by both translation and rotation: {}^AP = {}^A_BR \\, {}^BP + {}^AP_{BORG} Homogeneous Transform Matrix: {}^A_BT = \\begin{bmatrix} {}^A_BR & {}^A\\mathbf{P}_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_BT \\begin{bmatrix} {}^BP \\\\ 1 \\end{bmatrix} AttentionMapping describes the same point in different frames. Translation and rotation relate frames, not point positions. Sec 1.3 OperatorsOperators translate points, rotate vectors, or both. Translational operators Translating point $P_1$ by ${}^A\\mathbf{Q}$: {}^AP_2 = {}^AP_1 + {}^A\\mathbf{Q}Matrix form: D_Q = \\begin{bmatrix} 1 & 0 & 0 & q_x \\\\ 0 & 1 & 0 & q_y \\\\ 0 & 0 & 1 & q_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = D_Q \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix} Rotational operators Rotating vector ${}^AP_1$ by $R$: {}^AP_2 = R \\, {}^AP_1$R$ is equivalent to a rotation matrix ${}^A_BR$. Transformation operators Combining translation and rotation: \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = T \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix}where $T = \\begin{bmatrix} R &amp; \\mathbf{Q} \\\\ 0 &amp; 1 \\end{bmatrix}$. AttentionOperators act on vectors before transformation, while mappings describe vectors after transformation. Sec 1.4 Transformation Arithmetic Compound Transformation Problem: Transform ${}^CP$ to ${}^AP$ via intermediate frames: {}^A_CT = {}^A_BT {}^B_CT \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_CT \\begin{bmatrix} {}^CP \\\\ 1 \\end{bmatrix}Fixed reference frame transformations: {}^3_1T = {}^3_2T {}^2_1T Inverse transformation Method 1: ${}^B_AT = {}^A_BT^{-1}$ Method 2: {}^B_AT = \\begin{bmatrix} {}^A_BR^T & -{}^A_BR^T \\, {}^AP_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} Sec 1.5 More on Representation of Orientation X-Y-Z Fixed Angles Rotate $\\{B\\}$ about fixed axes of $\\{A\\}$ (order: Xâ†’Yâ†’Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-X Euler Angles Rotate $\\{B\\}$ about its own axes (order: Zâ†’Yâ†’X): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-Z Euler Angles Rotate $\\{B\\}$ about its own axes (order: Zâ†’Yâ†’Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(z, \\gamma) Comparison Chap 2. Manipulator Kinematics"},{"title":"Kalman Filter Introduction","path":"/wiki/kalmanprj/Kalman Intro.html","content":"1 IntroductionThe Kalman filter, first proposed by Rudolf E. KÃ¡lmÃ¡n in 1960, has become one of the most fundamental and widely used algorithms in estimation theory and signal processing. As an optimal recursive estimator, it provides an efficient computational framework for inferring the internal states of dynamic systems from noisy measurements. The fundamental strength of the Kalman filter lies in its ability to combine uncertain predictions with noisy measurements through an elegant probabilistic framework. By maintaining estimates of both the system state and its uncertainty covariance matrix, the filter achieves optimal estimation in the minimum mean-square error (MMSE) sense for linear Gaussian systems. This recursive nature makes it particularly suitable for real-time applications where computational efficiency is crucial. 2 AlgorithmThe Kalman filter operates through a recursive prediction-correction cycle, combining system dynamics with noisy measurements. Consider a discrete-time linear dynamic system described by: \\mathbf{x}_k = \\mathbf{A}\\mathbf{x}_{k-1} + \\mathbf{B}\\mathbf{u}_k + \\mathbf{w}_k \\mathbf{z}_k = \\mathbf{H}\\mathbf{x}_k + \\mathbf{v}_kwhere $\\mathbf{x}_k \\in \\mathbb{R}^n$ is the state vector, $\\mathbf{u}_k \\in \\mathbb{R}^m$ the control input, and $\\mathbf{z}_k \\in \\mathbb{R}^p$ the measurement vector. $\\mathbf{A}$ (state transition), $\\mathbf{B}$ (control input), and $\\mathbf{H}$ (observation) matrices define the system model. Process noise $\\mathbf{w}_k \\sim \\mathcal{N}(0,\\mathbf{Q})$ and measurement noise $\\mathbf{v}_k \\sim \\mathcal{N}(0,\\mathbf{R})$ are independent Gaussian distributions. 2.1 Predict PhaseThe filter first predicts the a priori state estimate and error covariance: \\hat{\\mathbf{x}}^-_k = \\mathbf{A}\\hat{\\mathbf{x}}_{k-1} + \\mathbf{B}\\mathbf{u}_k \\mathbf{P}^-_k = \\mathbf{A}\\mathbf{P}_{k-1}\\mathbf{A}^\\top + \\mathbf{Q}where $\\hat{\\mathbf{x}}^-_k$ represents the predicted state estimate and $\\mathbf{P}^-_k$ the predicted estimate covariance. 2.2 Update PhaseThe measurement update incorporates observations to compute the a posteriori estimate: \\mathbf{K}_k = \\mathbf{P}^-_k\\mathbf{H}^\\top(\\mathbf{H}\\mathbf{P}^-_k\\mathbf{H}^\\top + \\mathbf{R})^{-1} \\hat{\\mathbf{x}}_k = \\hat{\\mathbf{x}}^-_k + \\mathbf{K}_k(\\mathbf{z}_k - \\mathbf{H}\\hat{\\mathbf{x}}^-_k) \\mathbf{P}_k = (\\mathbf{I} - \\mathbf{K}_k\\mathbf{H})\\mathbf{P}^-_kHere, $\\mathbf{K}_k$ denotes the Kalman gain matrix that optimally weights prediction and measurement uncertainties. The innovation term $(\\mathbf{z}_k - \\mathbf{H}\\hat{\\mathbf{x}}^-_k)$ represents the difference between actual and predicted measurements. 2.3 Algorithm Pseudocode"},{"title":"Kalman Filter Simulation Practice","path":"/wiki/kalmanprj/Kalman simulation.html","content":"Project I1. Project DescriptionThe object is initially 40,000$m$ above the radar and throwing at initial vertical downward velocity 300$m/s$ and horizontal velocity 400$m/s$ . In this example we are neglecting drag or air resistance so that only gravity g ( $g$=9.8$m/s^2$) acts on the object.Assuming that the radar measures the range from the radar to the target with a 100$m$ standard deviation measurement accuracy. The radar takes measurement 10 times a second for 30 s. We would like to build a filter to estimate the position and velocity of the object without any a priori information. 2. Modelling State Space: We set the k-th state $\\boldsymbol{x}_k = [P_x\\quad P_y \\quad V_x\\quad V_y]^T_k$, so the (k+1)-th state is \\boldsymbol{x}_{k+1} = [P_x\\quad P_y \\quad V_x\\quad V_y]^T_{k+1}\\quad \\text{Expanded,} \\begin{bmatrix} P_x^{k+1} \\\\ P_y^{k+1}\\\\ V_x^{k+1}\\\\ V_y^{k+1} \\end{bmatrix} = \\begin{bmatrix} P_x^k +V_x^kdt + \\frac{1}{2}a_x(dt)^2\\\\ P_y^k +V_y^kdt + \\frac{1}{2}a_y(dt)^2\\\\ V_x^k + a_xdt\\\\ V_y^k + a_ydt \\end{bmatrix} The control input is $\\boldsymbol{u}_k = [a_x\\quad a_y]^T$. State Transition Matrix: According to the equation $\\boldsymbol{x}_{k+1} = \\mathbf{A}\\boldsymbol{x}_k + \\mathbf{B}\\boldsymbol{u}_k + \\boldsymbol{w}_k$, we can write: \\begin{bmatrix} P_x^{k+1} \\\\ P_y^{k+1}\\\\ V_x^{k+1}\\\\ V_y^{k+1} \\end{bmatrix} = A \\cdot \\begin{bmatrix} P_x^k \\\\ P_y^k\\\\ V_x^k\\\\ V_y^k \\end{bmatrix} + B \\cdot \\begin{bmatrix} a_x\\\\ a_y \\end{bmatrix}So the state transition matrix $\\mathbf{A}$ is: \\mathbf{A} = \\begin{bmatrix} 1 & 0 & dt & 0\\\\ 0 & 1 & 0 & dt\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} The control input matrix $\\mathbf{B}$ is: \\mathbf{B} = \\begin{bmatrix} \\frac{1}{2}(dt)^2 & 0\\\\ 0 & \\frac{1}{2}(dt)^2\\\\ dt & 0\\\\ 0 & dt \\end{bmatrix} Measurement Model: The measurement model is given by:$\\mathbf{z}_k = \\mathbf{H}\\boldsymbol{x}_k + \\mathbf{v}_k$. where $\\mathbf{H}$ is the measurement matrix. In this case, we only measure the range from the radar to the target, so: $\\boldsymbol{z}_k=\\boldsymbol{x}_k = \\begin{bmatrix}P_x^k\\\\P_y^k\\\\V_x^k\\\\V_y^k\\end{bmatrix}$. eventually we have: $\\mathbf{H} =\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$. Process Noise: The process noise $\\mathbf{w}_k$ is assumed to be Gaussian with zero mean and covariance $\\mathbf{Q}$. We can set $\\mathbf{Q}$ as: \\mathbf{Q} = \\begin{bmatrix} q_{P_x} & 0 & 0 & 0\\\\ 0 & q_{P_y} & 0 & 0\\\\ 0 & 0 & q_{V_x} & 0\\\\ 0 & 0 & 0 & q_{V_y} \\end{bmatrix}where $q_{P_x}$, $q_{P_y}$, $q_{V_x}$, and $q_{V_y}$ are the process noise variances for position and velocity in the x and y directions, respectively. We can set them as: q_{P_x} = 0.1, \\quad q_{P_y} = 0.1, \\quad q_{V_x} = 0.1, \\quad q_{V_y} = 0.1 Measurement Noise: The measurement noise $\\mathbf{v}_k$ is also assumed to be Gaussian with zero mean and covariance $\\mathbf{R}$. We can set $\\mathbf{R}$ as: \\mathbf{R} = \\begin{bmatrix} r_{P_x} & 0 & 0 & 0\\\\ 0 & r_{P_y} & 0 & 0\\\\ 0 & 0 & r_{V_x} & 0\\\\ 0 & 0 & 0 & r_{V_y} \\end{bmatrix}where $r_{P_x}$, $r_{P_y}$, $r_{V_x}$, and $r_{V_y}$ are the measurement noise variances for position and velocity in the x and y directions, respectively. We can set them as: r_{P_x} = 100, \\quad r_{P_y} = 100, \\quad r_{V_x} = 100, \\quad r_{V_y} = 100 Initial State: The initial state $\\boldsymbol{x}_0$ is given by the initial position and velocity of the object. We can set it as: \\boldsymbol{x}_0 = \\begin{bmatrix} P_x\\\\ P_y\\\\ V_x\\\\ V_y \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 40000\\\\ 400\\\\ -300 \\end{bmatrix}where $P_x$ is the initial position in the x direction, $P_y$ is the initial position in the y direction, $V_x$ is the initial velocity in the x direction, and $V_y$ is the initial velocity in the y direction. And the control input $\\boldsymbol{u}_0$ is given by the initial acceleration of the object. We can set it as: \\boldsymbol{u}_0 = \\begin{bmatrix} a_x\\\\ a_y \\end{bmatrix} = \\begin{bmatrix} 0\\\\ -9.8 \\end{bmatrix}where $a_x$ is the acceleration in the x direction and $a_y$ is the acceleration in the y direction. Initial Covariance: The initial covariance $\\mathbf{P}_0$ is given by the initial uncertainty of the state. We can set it as: \\mathbf{P}_0 = \\begin{bmatrix} p_{P_x} & 0 & 0 & 0\\\\ 0 & p_{P_y} & 0 & 0\\\\ 0 & 0 & p_{V_x} & 0\\\\ 0 & 0 & 0 & p_{V_y} \\end{bmatrix}where $p_{P_x}$, $p_{P_y}$, $p_{V_x}$, and $p_{V_y}$ are the initial covariance values for position and velocity in the x and y directions, respectively. We can set them as: p_{P_x} = 0.1, \\quad p_{P_y} = 0.1, \\quad p_{V_x} = 0.1, \\quad p_{V_y} = 0.13. Results:Position estimation: Velocity estimation: Project II1. Project DescriptionSuppose that the actual measurement is a pure cosine wave of unity amplitude corrupted by noise or where $\\omega$ is the frequency of the cosinusoidal signal and the noise is zero-mean Gaussian with a standard deviation of unity. We would like to build a Kalman filter that will be able to track the cosinusoidal and estimate its states based on the noisy cosinusoidal measurement. \\boldsymbol{x}^{*} = \\cos (\\omega t) + \\textbf{noise}2. Modelling State Space We set the k-th state $\\boldsymbol{x}_k = [x_1\\quad x_2]^T_k$. The components of the state vector are: \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} \\cos(\\omega t)\\\\ \\sin(\\omega t) \\end{bmatrix}The components meet the relationship: \\left\\{\\begin{matrix} \\dot{x_1} (t) = -\\omega x_2(t)\\\\ \\dot{x_2} (t) = -\\omega x_1(t) \\end{matrix}\\right.The (k+1)-th state is $\\boldsymbol{x}_{k+1}$ is given by: \\boldsymbol{x}_{k+1} = \\begin{bmatrix} \\cos\\omega (t + dt)\\\\ \\sin\\omega (t + dt) \\end{bmatrix} = \\begin{bmatrix} \\cos \\omega t \\sin \\omega dt - \\sin\\omega t \\sin \\omega dt\\\\ \\sin \\omega t \\cos \\omega dt + \\cos\\omega t \\sin \\omega dt \\end{bmatrix} State Transition Matrix: According to the equation $\\boldsymbol{x}_{k+1} = \\mathbf{A}\\boldsymbol{x}_k + \\mathbf{B}\\boldsymbol{u}_k + \\boldsymbol{w}_k$, since the control input is zero, we can write: \\begin{bmatrix} \\cos \\omega t \\sin \\omega dt - \\sin\\omega t \\sin \\omega dt\\\\ \\sin \\omega t \\cos \\omega dt + \\cos\\omega t \\sin \\omega dt \\end{bmatrix} = \\mathbf{A} \\cdot \\begin{bmatrix} \\cos(\\omega t)\\\\ \\sin(\\omega t) \\end{bmatrix}So the state transition matrix $\\mathbf{A}$ is: \\mathbf{A} = \\begin{bmatrix} \\cos\\omega dt & -\\sin\\omega dt\\\\ \\sin\\omega dt & \\cos\\omega dt \\end{bmatrix} Measurement Model: The measurement model is given by:$\\mathbf{z}_k = \\mathbf{H}\\boldsymbol{x}_k + \\mathbf{v}_k$. where $\\mathbf{H}$ is the measurement matrix. In this case, we only measure the range from the radar to the target, so: $ \\boldsymbol{z}_k=\\boldsymbol{x}_k = \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix}$. eventually we have: $\\mathbf{H} = \\begin{bmatrix} 1 &amp; 0 \\end{bmatrix}$. Process Noise: The process noise $\\mathbf{w}_k$ is assumed to be Gaussian with zero mean and covariance $\\mathbf{Q}$. We can set $\\mathbf{Q}$ as: \\mathbf{Q} = \\begin{bmatrix} q_{x_1} & 0\\\\ 0 & q_{x_2} \\end{bmatrix}where $q_{x_1}$ and $q_{x_2}$ are the process noise variances in the two component states, respectively. We can set them as: q_{x_1} = 10^{-3}, \\quad q_{x_2} = 10^{-3} Measurement Noise: The measurement noise $\\mathbf{v}_k$ is also assumed to be Gaussian with zero mean and covariance $\\mathbf{R}$. We can set $\\mathbf{R}$ as: \\mathbf{R} = \\begin{bmatrix} r_{x} \\end{bmatrix}where $r_{x}$ are the measurement noise variances in the measure state. We can set: r_{x} = 1 Initial State: The initial state $\\boldsymbol{x}_0$ is given by the initial state. We can set it as: \\boldsymbol{x}_0 = \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 1\\\\ 0 \\end{bmatrix}where $x_1$ is the initial state in the first component and $x_2$ is the initial state in the second component.(The initial state is the cosine wave at $t=0$) Initial Covariance: The initial covariance $\\mathbf{P}_0$ is given by the initial uncertainty of the state. We can set it as: \\mathbf{P}_0 = \\begin{bmatrix} p_{x_1} & 0\\\\ 0 & p_{x_2} \\end{bmatrix}where $p_{x_1}$ and $p_{x_2}$ are the initial covariance values for the two component states, respectively. We can set them as: p_{x_1} = 1, \\quad p_{x_2} = 13. Results"},{"title":"Sensors and Measurement System(EN)","path":"/notes/sensors.html","content":"Chap1 IntroductiomSec 1.1 Definition of measurement systemThe measurement is the process by which one can convert physical parameters to meaningful numbers. A measurement system is an information system which presents an observer with a numerical value corresponding to the variable being measured. Sec 1.2 Structure of measurement system Sensing elements: This is in contact with the process and gives an output which depends in some way on the variable to be measured. Signal conditioning element: This takes the output of the sensing elements and converts it into a form more suitable for further processing. Signal processing element: This takes the output of the conditioning element and converts it into a form more suitable for presentation. Data presentation element: This presents the measured value in a form which can be easily recognized by the observer. Sec 1.3 Applications In regulating trade, i.e. ruler. In monitoring functions, i.e. smoke sensor. Using as part of automatic feedback control systems, i.e. feedback control system. Sec 1.4 Methods of measurement Direct method: The unknown quantity can be measured directly. (like vernier caliper) Indirect method: It canâ€™t be measured directly, but it can be transformed into directly measurable physical quantity by the relation. (like laser range finder) Sec 1.5 Definition of sensors A sensor is a device that receives a stimulus and responds with an electrical signal. A sensor is a translator of a generally nonelectrical value into an electrical value, which can be channeled, amplified, and modified by electronic devices. Sec 1.6 Sensor classification1.6.1 Passive and active Passive sensor: it does not need any additional energy source and directly generates an electric signal in response to an external stimulus. That is, the input stimulus energy is converted by the sensor into the output signal. Active Sensor: it requires external power for its operation, which is called an excitation signal. That signal is modified by the sensor to produce the output signal. 1.6.2 Absolute and relative Absolute sensor: it detects a stimulus in reference to an absolute physical scale that is independent of the measurement conditions. Relative sensor: it produces a signal that relates to some special case. Chap 2 Measurement system Characteristic and PrinciplesSec 2.1 Static characteristics Static or steady-state characteristics; The relationships which may occur between the output $O$ and input $I$ of an element when $I$ is either at a constant value or changing slowly. It consists of systematic characteristic and statistical ones. 2.1.1 Systematic characteristicsThe systematic characteristics can be exactly quantified by mathematical or graphical means. These are distinct from statistical characteristics which can not be exactly quantified. Range: \\text{The input range}: I_{\\text{min}} \\quad \\text{to} \\quad I_{\\text{max}} \\text{The output range}: O_{\\text{min}} \\quad \\text{to} \\quad O_{\\text{max}} Span \\text{The input span}: I_{\\text{max}}- I_{\\text{min}} \\text{The output span}: O_{\\text{max}}- O_{\\text{min}} Usually the relationship between the input and output is monotonic. If not, the system is unsuitable for measuring. We should consider that the maximum input $I_{\\mathrm{max}}$ corresponds to the maximum output $O_{\\mathrm{max}}$. Linearity (Ideal straight line)The ideal straight line connects the minimum point A($I_{MIN}$, $O_{MIN}$) to maximum B($I_{MAX}$, $O_{MAX}$) O_{\\text{IDEAL}} = KI+awhere K = \\text{ideal straight-line slope} = \\frac{O_{\\text{max}}- O_{\\text{min}}}{I_{\\text{max}}- I_{\\text{min}}} a = \\text{ideal straight-line intercept} = O_{\\text{min}} - KI_{\\text{min}} We are only describing the relationship between output and input, not fitting the curve. Non-linearity N(I) = O(I) - (KI+a) \\text{Max non-linearity as a percentage of f.s.d.} = \\frac{\\hat{N}}{O_{\\text{max}}- O_{\\text{min}}} \\times 100\\% Sensitivity This is the change $\\Delta O$ output $O$ for unit change $\\Delta I$ input $I$. If the $\\Delta I$ tends to zero, we can find that the sensitivity $ \\Delta O \\setminus \\Delta I $ is the derivative $ \\text{d} O \\setminus \\text{d} I $. Hysteresis H(I) = O(I)_{\\downarrow } - O(I)_{\\uparrow } \\text{Max hysteresis as a percentage of f.s.d.} = \\frac{\\hat{H}}{O_{\\text{max}}- O_{\\text{min}}} \\times 100\\% ResolutionThis is defined as largest change in I that can occur without any corresponding change in O. R(I) = \\frac{\\Delta I_{R}}{I_{\\text{max}}- I_{\\text{min}}} \\times 100\\%For example, the ADC converter. Wear and ageing These effects can cause the characteristics of an element, e.g. $K$ and $a$, to change slowly but systematically throughout its life. Error bands Here the manufacturer states that for any value of I, the output $O$ will be within $\\pm h$ of the ideal straight-line value $O_{IDEAL}$. Environment effect The steady-state of output in general is expressed as: O = KI + a + N(I) + K_MI_MI+K_II_IWhere: $K_M$ is the change in sensitivity for unit change in $I_M$; $K_I$ is the change in zero bias for unit change in $I_I$. What is the interfering input $I_I$ and the modifying input $I_M$? Interfering Inputs - Quantities to which instrument is unintentionally sensitive. Modifying Inputs - Quantities which cause changes in Input-Output relations of desired and interfering inputs."},{"title":"ADC","path":"/wiki/lanqiao/ADC.html","content":"åµŒå…¥å¼ADCåœ¨cubemxä¸­é€‰æ‹©PB12ï¼ŒPB15åˆ†åˆ«è®¾ç½®ä¸ºADCè¾“å‡ºæ¨¡å¼ï¼ˆADC1_IN11å’ŒADC2_IN15ï¼‰ ç”Ÿæˆä»£ç åï¼Œåœ¨adc.cæ–‡ä»¶ä¸­å†™å•é€šé“é‡‡æ ·å‡½æ•°ï¼Œéœ€è¦åœ¨adc.hæ–‡ä»¶ä¸­å£°æ˜ 1234567double getADC(ADC_HandleTypeDef *pin)&#123; uint16_t adc; HAL_ADC_Start(pin); adc = HAL_ADC_GetValue(pin); return adc*3.3/4096;&#125; åœ¨ä¸»å‡½æ•°ä¸­ï¼Œç”¨ACD_Proc()è°ƒç”¨é‡‡æ ·åŠŸèƒ½ 12345678void ADC_Proc(void)&#123; char text[20]; adc_value1 = getADC(&amp;hadc1); adc_value2 = getADC(&amp;hadc2); sprintf(text,&quot;ADC1:%.2f,ADC2:%.2f&quot;,adc_value1,adc_value2); LCD_DisplayStringLine(Line4,(uint8_t *)text);&#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè®°å¾—åœ¨adc.cä¸­ä½¿ç”¨æ ¡å‡†å‡½æ•°å¯¹é‡‡æ ·è¿›è¡Œæ ¡å‡†ï¼Œå¦åˆ™é‡‡æ ·æœ€å¤§å€¼ä¸º3.25V 123456/* USER CODE BEGIN ADC1_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc1,ADC_SINGLE_ENDED);/* USER CODE END ADC1_Init 2 *//* USER CODE BEGIN ADC2_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);/* USER CODE END ADC2_Init 2 */"},{"title":"IIC","path":"/wiki/lanqiao/IIC.html","content":"åµŒå…¥å¼IICé€šä¿¡ä¸EEPROMçš„è¯»å†™I2Cæ€»çº¿æ˜¯ä¸€ç§åŒå‘äºŒçº¿åˆ¶çš„åŒæ­¥ä¸²è¡Œæ€»çº¿ï¼Œå®ƒåªéœ€è¦ä¸¤æ ¹çº¿å³å¯åœ¨è¿æ¥äºæ€»çº¿ä¸Šçš„å™¨ä»¶ä¹‹é—´ä¼ é€ä¿¡æ¯ã€‚ï¼ˆSDAå’ŒSCLï¼‰ å…³é”®æ˜¯è¯»æ‡‚EEPROMçš„è¯»å†™æ—¶åºã€‚ å¯¹ç…§ç€æ—¶åºå›¾ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºä¸EEPROMè¿›è¡Œè¯»å†™æ•°æ®çš„å‡½æ•°ï¼š 12345678910111213//å†™å‡½æ•°void e2prom_write(unsigned char address, unsigned char info)&#123; I2CStart(); //1.I2Cèµ·å§‹ä¿¡å·(START) I2CSendByte(0xa0); //2.å‘é€è®¾å¤‡åœ°å€ä¸â€œå†™â€ä¿¡å·(DEVICE ADDRESS+WRITE)ï¼Œå°†åœ¨ä¸‹æ–‡è§£é‡Š I2CWaitAck(); //3.IC2ç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) I2CSendByte(address); //4.å‘é€æ•°æ®å­˜å‚¨åœ°å€(WORD ADDRESS)ï¼ˆå¯ä»¥ä¸º0~255ï¼Œå¯¹åº”256ä¸ªï¼‰ I2CWaitAck(); //5.I2Cç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) I2CSendByte(info); //6.å‘é€æ•°æ®(DATA) I2CWaitAck(); //7.I2Cç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) I2CStop(); //8.I2Cç»“æŸä¿¡å·(STOP)&#125; 12345678910111213141516171819202122//è¯»å‡½æ•°unsigned char e2prom_read(unsigned char address)&#123; unsigned char val; I2CStart(); //1.I2Cèµ·å§‹ä¿¡å·(START) I2CSendByte(0xa0); //2.å‘é€è®¾å¤‡åœ°å€ä¸â€œå†™â€ä¿¡å·(DEVICE ADDRESS+WR-TE)ï¼Œå°†åœ¨ä¸‹æ–‡è§£é‡Š I2CWaitAck(); //3.IC2ç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) I2CSendByte(address); //4.å‘é€æ•°æ®å­˜å‚¨åœ°å€(WORD ADDRESS)ï¼ˆå¯ä»¥ä¸º0~255ï¼Œå¯¹åº”256ä¸ªï¼‰ I2CWaitAck(); //5.I2Cç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) I2CStop(); //ä¸‹ä¸€æ¬¡å‘é€èµ·å§‹ä¿¡å·å‰å…ˆåœæ­¢ I2CStart(); //6.I2Cèµ·å§‹ä¿¡å·(START) I2CSendByte(0xa1); //7.å‘é€è®¾å¤‡åœ°å€ä¸â€œè¯»â€ä¿¡å·(DEVICE ADDRESS+READ)ï¼Œå°†åœ¨ä¸‹æ–‡è§£é‡Š I2CWaitAck(); //8.I2Cç­‰å¾…ç¡®è®¤ä¿¡å·(ACK) val = I2CReceiveByte(); //9.æ¥æ”¶æ•°æ®(DATA) I2CSendNotAck(); //10.I2Cå‘é€éç¡®è®¤ä¿¡å·(NO ACK) I2CStop(); //11.I2Cç»“æŸä¿¡å·(STOP) return (val);&#125; æ³¨æ„ï¼ŒEEPROMæ¯ä¸€ä¸ªåœ°å€åªèƒ½è¯»å–8ä½æ— ç¬¦å·æ•°ï¼Œ16ä½æˆ–è€…32ä½éœ€è¦è¿›è¡Œåˆ†å‰² åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œæ¯ä¸€æ¬¡çš„EEPROMçš„è¯»å†™éƒ½éœ€è¦æ—¶é—´ï¼Œåœ¨å…·ä½“ç¨‹åºä¸­éœ€è¦è¿›å»¶æ—¶æ“ä½œã€‚"},{"title":"KEY","path":"/wiki/lanqiao/KEY.html","content":"åµŒå…¥å¼æŒ‰é”®ä½¿ç”¨æŒ‰é”®çŠ¶æ€æœºï¼Œåœ¨ç”¨æˆ·åŒºæ–°å»ºKey_State.cå’ŒKey_State.hæ–‡ä»¶ã€‚åœ¨Key_State.hä¸­ï¼Œå†™ä¸‹ 123456789101112131415161718192021222324252627#ifndef __KEY_STATE_H_#define __KEY_STATE_H_#include &quot;main.h&quot;/** * @brief æŒ‰é”®çŠ¶æ€ç»“æ„ä½“ */struct keys&#123; uint8_t judge_state; // çŠ¶æ€æœºæ ‡å¿—ï¼Œ0ï¼š æ£€æµ‹åˆ°ä¸€ä¸ªä½ç”µå¹³ï¼›1ï¼šç¡®å®è¢«æŒ‰ä¸‹ï¼›2ï¼šç­‰å¾…æŠ¬èµ· uint8_t key_state; // æŒ‰é”®æ˜¯å¦è¢«æŒ‰ä¸‹ï¼ˆä¿¡å·æ¥è‡ªGPIOè¾“å…¥ï¼‰ uint8_t key_isPressed; // æŒ‰é”®çŸ­æŒ‰æ ‡å¿—ä½ uint8_t key_long_flag; // æŒ‰é”®é•¿æŒ‰æ ‡å¿—ä½ uint32_t key_time; // æŒ‰é”®è®¡æ—¶ uint32_t key_double_click_time; // åŒå‡»è®¡æ—¶å™¨ uint8_t key_double_click_EN; // åŒå‡»è®¡æ—¶å™¨ä½¿èƒ½ uint8_t key_double_click_flag; // åŒå‡»æ ‡å¿—ä½&#125;;extern struct keys key[];void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);#endif keysç»“æ„ä½“å³ä¸ºæŒ‰é”®çŠ¶æ€æœºï¼Œä½¿ç”¨å®šæ—¶ä¸­æ–­å‡½æ•°è¿›è¡ŒæŒ‰é”®æ¶ˆæŠ–ã€‚ Key_State.cå†…å®¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;Key_State.h&quot;struct keys key[4] = &#123;0, 0, 0, 0&#125;;/** * @brief TIMå®šæ—¶å™¨å®šæ—¶ä¸­æ–­å›è°ƒå‡½æ•° */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM3) &#123; key[0].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); key[1].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1); key[2].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2); key[3].key_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); for (uint8_t i = 0; i &lt; 4; i ++) &#123; if (key[i].key_double_click_EN == 1) // è®¡æ•°å™¨ä½¿èƒ½å¼€å¯æ—¶ï¼Œè®¡æ—¶å¹¶åˆ¤æ–­ &#123; key[i].key_double_click_time ++; if (key[i].key_double_click_time &gt; 35) // å¦‚æœè¶…æ—¶ï¼Œåˆ™è¯´æ˜æ˜¯çŸ­æŒ‰ï¼Œç½®æ ‡å¿—ä½åå…³é—­è®¡æ•°å™¨ä½¿èƒ½ &#123; key[i].key_isPressed = 1; key[i].key_double_click_EN = 0; &#125; &#125; switch (key[i].judge_state) &#123; case 0: if (key[i].key_state == 0) // å¦‚æœåˆšå¼€å§‹æ£€æµ‹åˆ°ä¸€ä¸ªä½ç”µå¹³ &#123; key[i].key_time = 0; // æ—¶é—´è®¡æ•°æ¸…0 key[i].judge_state = 1; &#125; break; case 1: if (key[i].key_state == 0) // å¦‚æœ10msåä¾ç„¶æ£€æµ‹åˆ°è¿™ä¸ªæŒ‰é”®æ˜¯ä½ç”µå¹³ï¼Œå°±è¯´æ˜è¿™ä¸ªæŒ‰é”®ç¡®å®è¢«æŒ‰ä¸‹äº† &#123; key[i].judge_state = 2; &#125; else &#123; key[i].judge_state = 0; &#125; break; case 2: if (key[i].key_state == 1 &amp;&amp; key[i].key_time &lt;= 70) // å¦‚æœæ˜¯ä¸€æ¬¡çŸ­æŒ‰ &#123; key[i].judge_state = 0; if (key[i].key_double_click_EN == 0) // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æŒ‰ä¸‹ &#123; key[i].key_double_click_EN = 1; key[i].key_double_click_time = 0; &#125; else // åŒå‡»è®¡æ—¶å¼€å¯ï¼Œè¯´æ˜è¿™æ¬¡çŸ­æŒ‰è¿˜åœ¨åŒå‡»è®¡æ—¶çš„æ—¶é—´èŒƒå›´å†… &#123; key[i].key_double_click_EN = 0; key[i].key_double_click_flag = 1; &#125; &#125; else if (key[i].key_state == 1 &amp;&amp; key[i].key_time &gt; 70) // é•¿æŒ‰æ¾å¼€æŒ‰é”®ï¼Œåˆ™å›åˆ°state0 &#123; key[i].judge_state = 0; &#125; else if (key[i].key_state == 0) // å¦‚æœæŒ‰é”®æ²¡æœ‰æ¾å¼€ï¼Œåˆ™æŒç»­è®¡æ—¶ &#123; key[i].key_time ++; if (key[i].key_time &gt; 70) // å¦‚æœæŒ‰é”®æŒ‰ä¸‹æ—¶é—´å¤§äº700ms &#123; key[i].key_long_flag = 1; &#125; &#125; break; default: break; &#125; &#125; &#125;&#125; è®°ä½è¦åœ¨cubemxä¸­è®¾ç½®10msä¸­æ–­ï¼Œå…¶ä¸­PSCé¢„åˆ†é¢‘æ˜¯79ï¼ˆ80-1ï¼‰ï¼ŒARRé‡è£…é¢„è½½æ˜¯9999ï¼ˆ10000-1ï¼‰ã€‚ä»¥åŠåŠ å…¥åˆå§‹åŒ–å‡½æ•°ï¼š 1HAL_TIM_Base_Start_IT(&amp;htim3);"},{"title":"16å±Šè“æ¡¥æ¯æ¨¡æ‹Ÿè¯•é¢˜1","path":"/wiki/lanqiao/16moni_1.html","content":"åŸé¢˜è¯·åœ¨80MHzä¸»é¢‘ä¸‹å®Œæˆä»¥ä¸‹ä»»åŠ¡ åŠŸèƒ½è¦æ±‚ï¼š åŠŸèƒ½æ¦‚è¿°ï¼š é€šè¿‡å¾®æ§åˆ¶å™¨çš„ADCåŠŸèƒ½ï¼Œæ£€æµ‹ç”µä½å™¨R37ä¸Šè¾“å‡ºçš„æ¨¡æ‹Ÿç”µå‹ä¿¡å·; é€šè¿‡æ¿è½½AT24C02 EEPROMèŠ¯ç‰‡ï¼Œå­˜å‚¨å¯†ç å€¼; ä¾è¯•é¢˜è¦æ±‚ï¼Œé€šè¿‡LCDå®Œæˆæ•°æ®æ˜¾ç¤ºç­‰åŠŸèƒ½; ä¾è¯•é¢˜è¦æ±‚é€šè¿‡æŒ‰é”®å®Œæˆå‚æ•°è®¾ç½®åŠŸèƒ½; ä¾è¯•é¢˜è¦æ±‚ï¼Œé€šè¿‡LEDå®ŒæˆçŠ¶æ€æŒ‡ç¤ºåŠŸèƒ½ã€‚ æ€§èƒ½è¦æ±‚ï¼š æŒ‰é”®å“åº”æ—¶é—´:â‰¤0.1ç§’ ç”µå‹é‡‡é›†åˆ·æ–°æ—¶é—´:â‰¤0.5ç§’ AT24C02:æ•°æ®æ‰ç”µä¸ä¸¢å¤± æ˜¾ç¤ºåŠŸèƒ½ï¼š è¾“å…¥ç•Œé¢ï¼šæ˜¾ç¤ºè¦ç´ åŒ…å«ç•Œé¢åç§°(Lock)ï¼Œè¾“å…¥å¯†ç (Pass Word)ã€‚è¾“å…¥å¯†ç å€¼ä»å·¦å¾€å³è¾“å…¥ï¼Œæœªè¾“å…¥çš„å¯†ç å€¼ä½¿ç”¨â€*â€ä»£æ›¿ã€‚ ä¿®æ”¹ç•Œé¢ï¼šæ˜¾ç¤ºè¦ç´ åŒ…å«ç•Œé¢åç§°(Set)ï¼Œå¾…ä¿®æ”¹å¯†ç (Change)ã€‚ä¿®æ”¹å¯†ç å€¼ä»å·¦å¾€å³è¾“å…¥ï¼Œæœªè¾“å…¥çš„ä¿®æ”¹å¯†ç å€¼ä½¿ç”¨â€œ*â€ä»£æ›¿ã€‚ LCDé€šç”¨è¦æ±‚ï¼š æ˜¾ç¤ºèƒŒæ™¯è‰²(BackColor):é»‘è‰² æ˜¾ç¤ºå‰æ™¯è‰²(TextColor):ç™½è‰² è¯·ä¸¥æ ¼æŒ‰ç…§å›¾ç¤ºè¦æ±‚è®¾è®¡å„ä¸ªä¿¡æ¯é¡¹çš„åç§°(åŒºåˆ†å­—æ¯å¤§å°å†™)å’Œè¡Œåˆ—ä½ç½®ã€‚ å¯†ç æœºåˆ¶ï¼šä½¿ç”¨å¾®æ§åˆ¶å™¨çš„ADCåŠŸèƒ½è¯»å–ç”µä½å™¨R37çš„ç”µå‹å€¼ï¼Œç»è½¬æ¢å…³ç³»è½¬åŒ–åä½œä¸ºè¾“å…¥çš„å¯†ç ï¼šè¾“å…¥ç•Œé¢è¾“å…¥å¯†ç ä¸ä¿®æ”¹ç•Œé¢è¾“å…¥å¯†ç çš„æœºåˆ¶ç›¸åŒã€‚ å­˜å‚¨åŠŸèƒ½ï¼šå½“å‰å¯†ç å€¼å­˜å‚¨äºAT24C02çš„æŒ‡å®šä½ç½®ï¼Œå¯†ç æ•°æ®æ‰ç”µä¸ä¸¢å¤±ï¼Œå­˜å‚¨è¡¨å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ è§£é”åŠŸèƒ½ï¼š è¾“å…¥ç•Œé¢ä¸‹ï¼Œå®Œæˆä¸‰ä½å¯†ç å€¼è¾“å…¥åè‡ªåŠ¨å°è¯•è§£é”ï¼Œè‹¥è¾“å…¥å¯†ç å€¼å’Œå­˜å‚¨å¯†ç å€¼ä¸€è‡´ï¼Œåˆ™è¿›å…¥ä¿®æ”¹ç•Œé¢ï¼Œå¦åˆ™è¾“å…¥çš„å¯†ç å€¼æ›´ç½®ä¸ºâ€œ*â€ï¼Œå¯ä»¥é‡æ–°å¼€å§‹è¾“å…¥å¯†ç ã€‚ è¿›å…¥ä¿®æ”¹ç•Œé¢å3ç§’ä¸è¿›è¡Œä¿®æ”¹å¯†ç æ“ä½œåˆ™è¿”å›è¾“å…¥ç•Œé¢ã€‚ æŒ‰é”®åŠŸèƒ½ B1:å®šä¹‰ä¸ºâ€œç¡®è®¤â€æŒ‰é”®ï¼š åœ¨è¾“å…¥ç•Œé¢ï¼ŒæŒ‰ä¸‹B1æŒ‰é”®ï¼Œç¡®å®šä¸€ä½è¾“å…¥å¯†ç ã€‚ åœ¨ä¿®æ”¹ç•Œé¢ï¼ŒæŒ‰ä¸‹B1æŒ‰é”®ï¼Œç¡®å®šä¸€ä½ä¿®æ”¹çš„å¯†ç ã€‚è‹¥ä¸‰ä½ä¿®æ”¹å¯†ç å€¼è¾“å…¥å®Œæˆï¼Œåˆ™å°†å¯†ç å€¼ä¿®æ”¹æˆåŠŸï¼ŒåŒæ—¶å¯¹å½“å‰å¯†ç å€¼è¿›è¡Œå­˜å‚¨ï¼Œå¹¶è¿”å›åˆ°è¾“å…¥ç•Œé¢ã€‚ é€šç”¨æŒ‰é”®è¦æ±‚ï¼š æŒ‰é”®åº”è¿›è¡Œæœ‰æ•ˆçš„é˜²æŠ–å¤„ç†ï¼Œé¿å…å‡ºç°ä¸€æ¬¡æŒ‰é”®åŠ¨ä½œè§¦å‘å¤šæ¬¡åŠŸèƒ½ç­‰æƒ…å½¢ã€‚ æŒ‰é”®åŠ¨ä½œä¸åº”å½±å“æ•°æ®é‡‡é›†è¿‡ç¨‹å’Œå±å¹•æ˜¾ç¤ºæ•ˆæœã€‚ å½“å‰ç•Œé¢ä¸‹æ— åŠŸèƒ½çš„æŒ‰é”®æŒ‰ä¸‹ï¼Œä¸è§¦å‘å…¶å®ƒç•Œé¢çš„åŠŸèƒ½ã€‚ LEDåŠŸèƒ½ LD1:å¤„äºè¾“å…¥ç•Œé¢æ—¶ï¼ŒæŒ‡ç¤ºç¯LD1ç‚¹äº®ï¼Œå¦åˆ™ç†„ç­ã€‚ LD2:å¤„äºä¿®æ”¹ç•Œé¢æ—¶ï¼ŒæŒ‡ç¤ºç¯LD2ç‚¹äº®ï¼Œå¦åˆ™ç†„ç­ã€‚ LD3-LD8æŒ‡ç¤ºç¯ã€‚ åˆå§‹çŠ¶æ€è¯´æ˜ï¼š è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¦æ±‚è®¾ç½®ä½œå“çš„åˆå§‹çŠ¶æ€ï¼š å¤„äºè¾“å…¥ç•Œé¢ åˆå§‹çŠ¶æ€å¯†ç é»˜è®¤ä¸ºï¼š012 è®¾è®¡æ€è·¯Cubemxé…ç½®ï¼š æ—¶é’Ÿæ ‘é…ç½® å¼•è„šé…ç½® LEDæ¨¡å—åœ¨cubemxä¸­é…ç½®å¥½æ—¶é’Ÿå’Œå¼•è„šåï¼Œæ–°å»ºå·¥ç¨‹æ–‡ä»¶ï¼Œæ‰“å¼€å·¥ç¨‹æ–‡ä»¶ï¼Œæ–°å¢æ–‡ä»¶â€œled.câ€å’Œâ€œled.hâ€ã€‚ led.c123456789101112#include &quot;led.h&quot;void LED_Disp(uint8_t led)&#123;\tHAL_GPIO_WritePin(GPIOC, 0xff&lt;&lt;8, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC, led&lt;&lt;8, GPIO_PIN_RESET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);&#125; led.h1234567#ifndef __LED_H#define __LED_H#include &quot;main.h&quot;void LED_Disp(uint8_t led);#endif æŒ‰é”®æ¨¡å—æ–°å»ºæ–‡ä»¶â€œkey.câ€å’Œâ€œkey.hâ€ï¼Œç”±äºåªéœ€è¦æŒ‰é”®å•å‡»ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„æŒ‰é”®é©±åŠ¨å¯ä»¥ç®€å†™ï¼š key.c123456789101112131415161718192021222324252627282930313233#include &quot;key.h&quot;struct keys key[4] = &#123;0,0,0,0&#125;;void key_state(void)&#123;\tkey[0].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0);\tkey[1].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1);\tkey[2].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2);\tkey[3].key_state = HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0); for(uint8_t i = 0; i&lt; 4; i++)\t&#123; switch(key[i].judge_state) &#123; case 0: if(key[i].key_state == 0) &#123; key[i].judge_state =1; &#125; break; case 1: if(key[i].key_state == 1) &#123; key[i].key_ispressed = 1; key[i].judge_state = 0; &#125; break; default:break; &#125;\t&#125; &#125; key.h123456789101112131415161718#ifndef __KEY_H#define __KEY_H#include &quot;main.h&quot;struct keys&#123;\tuint8_t judge_state;\tuint8_t key_state;\tuint8_t key_ispressed;&#125;;extern struct keys key[];void key_state(void);#endif ADCç”µå‹æ•è·é…ç½®æ‰“å¼€ç”Ÿæˆçš„â€œadc.câ€æ–‡ä»¶ï¼Œåœ¨ç”¨æˆ·ä»£ç åŒºå¢åŠ ADCæ•è·å‡½æ•°ï¼š adc.c12345678910/* USER CODE BEGIN 1 */double getADC(ADC_HandleTypeDef *pin)&#123;\tuint16_t adc;\tHAL_ADC_Start(pin);\tadc = HAL_ADC_GetValue(pin);\treturn adc*3.3/4096;&#125;/* USER CODE END 1 */ è®°ä½éœ€è¦åœ¨â€œadc.hâ€ä¸­å¢åŠ å£°æ˜ã€‚ e2promæ¨¡å—å°†èµ›ç‚¹èµ„æºåŒ…ä¸­çš„i2cé©±åŠ¨æ”¾åˆ°é¡¹ç›®æ–‡ä»¶å¤¹ä¸­ï¼Œå¹¶å¯¼å…¥åˆ°é¡¹ç›®ï¼š æ–°å»ºâ€œe2prom.câ€å’Œâ€œe2prom.hâ€æ–‡ä»¶ï¼š e2prom.c123456789101112131415161718192021222324252627282930313233343536#include &quot;e2prom.h&quot;#include &quot;i2c_hal.h&quot;void e2prom_write(uint8_t addr, uint8_t data)&#123;\tI2CStart();\tI2CSendByte(0xa0);\tI2CWaitAck(); I2CSendByte(addr);\tI2CWaitAck();\tI2CSendByte(data);\tI2CWaitAck();\tI2CStop();&#125;uint8_t e2prom_read(uint8_t addr)&#123;\tuint8_t val;\tI2CStart();\tI2CSendByte(0xa0);\tI2CWaitAck(); I2CSendByte(addr);\tI2CWaitAck();\tI2CStop(); I2CStart();\tI2CSendByte(0xa1);\tI2CWaitAck();\tval = I2CReceiveByte();\tI2CSendNotAck();\tI2CStop(); return val;&#125; e2prom.h123456789#ifndef __E2PROM_H#define __E2PROM_H#include &quot;main.h&quot;void e2prom_write(uint8_t addr, uint8_t data);uint8_t e2prom_read(uint8_t addr);#endif ä¸»å‡½æ•°LCDæ˜¾ç¤ºä¸ç¨‹åºä¸»ä½“åŒæ ·çš„ï¼Œæˆ‘ä»¬æŠŠâ€œlcd.câ€å’Œâ€œlcd.hâ€æ”¾å…¥é¡¹ç›®æ–‡ä»¶å¤¹å’Œé¡¹ç›®æ–‡ä»¶ä¸­ï¼Œåœ¨ä¸»å‡½æ•°ç”¨æˆ·ç¼–è¾‘åŒºï¼Œå¢åŠ lcdæ˜¾ç¤ºå‡½æ•°ç”¨äºæ˜¾ç¤ºå±å¹•å†…å®¹ï¼š main.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void LCD_Page(void)&#123;\tchar buf[20]; switch(page_flag)\t&#123; case 0: sprintf(buf,&quot; Lock &quot;); LCD_DisplayStringLine(Line1, (uint8_t *)buf); sprintf(buf,&quot; Pass Word &quot;); LCD_DisplayStringLine(Line3,(uint8_t *)buf); if(password1_flag == 1 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d * * &quot;,password[0]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d %d * &quot;,password[0],password[1]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 1) &#123; sprintf(buf,&quot; %d %d %d &quot;,password[0],password[1],password[2]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); if(password[0] == password_saved[0] &amp;&amp; password[1] == password_saved[1] &amp;&amp; password[2] == password_saved[2]) page_flag = 1, password1_flag = 0, password2_flag = 0, password3_flag = 0, password[0] = 0, password[1] = 0, password[2] = 0; else password1_flag = 0, password2_flag = 0, password3_flag = 0, password[0] = 0, password[1] = 0, password[2] = 0 ; &#125; if(password1_flag == 0 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; * * * &quot;); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; LED_Disp(0x01); break; case 1: sprintf(buf,&quot; Set &quot;); LCD_DisplayStringLine(Line1, (uint8_t *)buf); sprintf(buf,&quot; Change &quot;); LCD_DisplayStringLine(Line3,(uint8_t *)buf); if(password1_flag == 1 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d * * &quot;,password_saved[0]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d %d * &quot;,password_saved[0],password_saved[1]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 1) &#123; sprintf(buf,&quot; %d %d %d &quot;,password_saved[0],password_saved[1],password_saved[2]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); page_flag = 0; password1_flag = 0, password2_flag = 0, password3_flag = 0; &#125; if(password1_flag == 0 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; * * * &quot;); LCD_DisplayStringLine(Line4,(uint8_t *)buf); if(timer &gt;=3000) &#123; page_flag = 0; timer = 0; &#125; &#125; save_Password(); LED_Disp(0x02); break; default:break;\t&#125;&#125; è¿™é‡Œçš„è®¾è®¡æ€è·¯æ˜¯ï¼š page_flag æ ‡å¿—ç”¨äºåˆ‡æ¢â€œPass Wordâ€ç•Œé¢å’Œâ€œChangeâ€ç•Œé¢ï¼› password_flag1 åˆ° password_flag3æ˜¯ä¸‰ä¸ªå¯†ç çš„è¾“å…¥æ ‡å¿—ï¼Œå¯¹åº”æ¯ä¸€ä½å¯†ç ï¼Œåœ¨è¯¥ä½å¯†ç è¾“å…¥åå¯†ç è¾“å…¥æ ‡å¿—ç½®1ï¼› ä¸‰ä½å¯†ç æ ‡å¿—å…¨éƒ¨ç½®1ååˆ¤æ–­è¾“å…¥çš„å¯†ç å’Œå­˜å‚¨çš„å¯†ç æ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰è¿›å…¥è®¾ç½®ç•Œé¢ï¼›æ— è®ºå¦‚ä½•éƒ½ä¼šæ¸…é›¶å¯†ç è¾“å…¥æ ‡å¿—ï¼› è®¾ç½®ç•Œé¢ä¹Ÿæ˜¯ç›¸åŒæ€è·¯ï¼› å¦‚ä½•å®ç°3sä¸è®¾ç½®å¯†ç è¿”å›ï¼Ÿè®¾ç½®è®¾ç½®å¯†ç ç•Œé¢æ ‡å¿—ä½ï¼Œè¿›å…¥å¯†ç è®¾ç½®ç•Œé¢åæ ‡å¿—ç½®1ï¼Œæ»´ç­”è®¡æ—¶å™¨å¼€å§‹è®¡æ—¶ï¼Œå½“è®¡æ—¶3sæ—¶ä¸”æ²¡æœ‰è¾“å…¥å¯†ç ï¼ˆå¯†ç è¾“å…¥æ ‡å¿—ä½å‡ä¸º0ï¼‰ï¼Œç•Œé¢æ ‡å¿—ä½ç½®0è¿”å›è¾“å…¥å¯†ç ç•Œé¢ã€‚ å¯†ç è¾“å…¥æ¨¡å—åœ¨ä¸»å‡½æ•°ä¸­ç”¨æˆ·ç¼–è¾‘åŒºï¼Œmain.c12345678910111213141516171819202122232425void enter_Password(void)&#123;\tr37 = getADC(&amp;hadc2);\tif(key[0].key_ispressed == 1)\t&#123; key[0].key_ispressed = 0; i++; password[i-1] = get_Password(r37); switch(i) &#123; case 1: password1_flag = 1; break; case 2: password2_flag = 1; break; case 3: password3_flag = 1; break; default:break; &#125; if(i&gt;=3) i = 0;\t&#125;&#125;æ¯æŒ‰ä¸‹ä¸€æ¬¡B1æŒ‰é”®ï¼Œiéƒ½è‡ªå¢1ï¼Œè®¾ç½®å¯†ç è¾“å…¥æ ‡å¿—ä½ã€‚æ ¹æ®å½“å‰çš„r37çš„ç”µå‹ç¡®å®šå¯†ç ï¼š main.c12345678uint8_t get_Password(double adc)&#123;\tuint8_t password_value;\tif(adc &lt; 1.5) password_value = 0;\tif(adc&gt;=1.5 &amp;&amp; adc &lt;=2.5) password_value = 1;\tif(adc &gt; 2.5) password_value = 2;\treturn password_value;&#125; å¯†ç å­˜å‚¨ä¸è¯»å–åŠŸèƒ½å­˜å‚¨å¯†ç ï¼šåœ¨ä¸Šé¢çš„å¯†ç è¾“å…¥å‡½æ•°åé¢æ·»åŠ å°†æ•°ç»„å†…å®¹å†™å…¥eepromçš„å†…å®¹ã€‚main.c12345678910111213141516171819202122232425262728293031void save_Password(void)&#123;\tr37 = getADC(&amp;hadc2);\tif(key[0].key_ispressed == 1)\t&#123; key[0].key_ispressed = 0; i++; password_saved[i-1] = get_Password(r37); switch(i) &#123; case 1: password1_flag = 1; break; case 2: password2_flag = 1; break; case 3: password3_flag = 1; break; default:break; &#125; if(i&gt;=3) i = 0;\t&#125;\te2prom_write(0x00, password_saved[0]);\tHAL_Delay(10);\te2prom_write(0x01, password_saved[1]);\tHAL_Delay(10);\te2prom_write(0x02, password_saved[2]);\tHAL_Delay(10);&#125;å¯†ç è¯»å–ï¼šmain.c12345678910void read_Password(void)&#123;\tHAL_Delay(10);\tpassword_saved[0] = e2prom_read(0x00);\tHAL_Delay(10);\tpassword_saved[1] = e2prom_read(0x01);\tHAL_Delay(10);\tpassword_saved[2] = e2prom_read(0x02);\tHAL_Delay(10);&#125;åˆå§‹å¯†ç è®¾ç½®ï¼šè¿™é‡Œè®¾ç½®ä¸€ä¸ªæ ‡å¿—ä½ï¼Œåœ¨è¿›å…¥å¾ªç¯ä¹‹å‰æŸ¥çœ‹eepromé‡Œæ˜¯å¦å­˜åœ¨è¯¥æ ‡å¿—ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¡¨ç¤ºç¬¬ä¸€æ¬¡å†™å…¥ï¼›å¦åˆ™ä¸æ˜¯ç¬¬ä¸€æ¬¡å†™å…¥ã€‚main.c123456789101112131415161718192021222324252627int main&#123;\t...\tif(e2prom_read(0x21) != 4) // åˆ¤æ–­æ˜¯å¦æ—¶ç¬¬ä¸€æ¬¡å†™å…¥\t&#123; e2prom_write(0x21,4); HAL_Delay(10); initial_password();\t&#125;\t...\twhile (1)\t...&#125;...void initial_password(void)&#123;\tHAL_Delay(10);\te2prom_write(0x00, 0);\tHAL_Delay(10);\te2prom_write(0x01, 1);\tHAL_Delay(10);\te2prom_write(0x02, 2);\tHAL_Delay(10);&#125; é¡¹ç›®æºæ–‡ä»¶å°†è¿™äº›æ–‡ä»¶ç»¼åˆä¸€ä¸‹å°±å¯ä»¥å®Œæˆè¿™ä¸€é¢˜ï¼Œåœ¨4Tè¯„æµ‹ç½‘ä¸­è¿™é¢˜ä¹Ÿæ˜¯æ»¡åˆ†ã€‚ æºæ–‡ä»¶"},{"title":"LED","path":"/wiki/lanqiao/LED.html","content":"LEDæ“ä½œåœ¨cubemxä¸­é…ç½®æ—¶é’Ÿå’Œå¼•è„šï¼ŒLEDä½ç”µå¹³æœ‰æ•ˆ æ³¨æ„è¦æ‰“å¼€PD2é”å­˜å™¨ åŸºæœ¬å†™æ³•ï¼š 123456void LED(uint8_t dsled)&#123; HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); //æ‰“å¼€é”å­˜å™¨ HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET); //ç­æ‰æ‰€æœ‰çš„LED HAL_GPIO_WritePin(GPIOC, dsled&lt;&lt;8, GPIO_PIN_RESET); //é€‰æ‹©ç‰¹å®šçš„LEDäº®èµ·&#125; å…¶ä¸­dsledæ˜¯8ä½æ— ç¬¦å·æ•°ï¼Œ0x_ _ã€‚ é«˜ä½å³ä¸ºå·¦è¾¹å››ä¸ªledï¼Œä½ä½å³ä¸ºå³è¾¹å››ä¸ªledã€‚æ¯ä¸€ä½å–1å³ä¸ºè¯¥ledäº®ã€‚ LEDäº¤æ›¿é—ªçƒå’ŒLEDé—ªçƒå–å ~ å·¦å››ä½å’Œå³å››ä½äº¤æ›¿é—ªçƒ å–å¼‚æˆ–^è¯¥ä½ledé—ªçƒ 1234567891011uint8_t ucLed=0x0f; //äº¤æ›¿é—ªçƒLED(~ucLed); //é—ªçƒuint8_t ucLed2 = 0x0f;LED(ucLed2);HAL_Delay(1000);ucLed2^=0x0f; LEDå®ç°æµæ°´ç¯ä½è¿ç®—å·¦ç§»å’Œå³ç§»ï¼ˆ&lt;&lt;å’Œ&gt;&gt;ï¼‰ Systick æ»´ç­”è®¡æ—¶HAL_Delay()æ˜¯é˜»å¡èµ‹å€¼ï¼Œå¯ä»¥ä½¿ç”¨Systickè¿›è¡Œè®¡æ—¶ï¼ŒSystickè¿›è¡Œäº†å·²ç»è®¾ç½®äº†1msçš„ä¸­æ–­ã€‚ è®¡æ—¶æ–¹å¼ 12345678910111213141516171819202122232425262728293031//åœ¨æ–‡ä»¶ï¼šstm32g4xx_it.cä¸­/* USER CODE BEGIN PV */extern uint32_t usled;/* USER CODE END PV */void SysTick_Handler(void)&#123;/* USER CODE BEGIN SysTick_IRQn 0 *//* USER CODE END SysTick_IRQn 0 */ HAL_IncTick();/* USER CODE BEGIN SysTick_IRQn 1 */ usled++;//å®ç°usledæ¯éš”1msè‡ªå¢1/* USER CODE END SysTick_IRQn 1 */&#125;//åœ¨æ–‡ä»¶main.cä¸­/* USER CODE BEGIN PV */uint32_t usled;uint8_t ucled=0x01;/* USER CODE END PV *//* USER CODE BEGIN 3 */Led_Disp(ucled);if(usled&gt;=500)//500msåˆ°&#123; usled=0;//é‡æ–°è®¡æ•° ucled^=0x01;//åè½¬led1&#125;/* USER CODE END 3 */ è§£å†³LEDå¼•è„šå†²çªé—®é¢˜ä¿®æ”¹PD2å¼•è„šä¸ºä½ç”µå¹³ å°†LEDæ˜¾ç¤ºå‡½æ•°æ”¹æˆå¦‚ä¸‹ï¼š 12345678910void Led_Disp(uint8_t ucled)&#123; HAL_GPIO_WritePin(GPIOC,0xFF&lt;&lt;8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC,ucled&lt;&lt;8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);&#125; å¢åŠ äº†é‡å†™PD2å¼•è„šé«˜ä½ç”µå¹³çš„å‡½æ•° å¦‚ä½•å•ç‹¬å¯¹ä¸€ä¸ª8bitæ•°çš„ä¸€ä½è¿›è¡Œæ“ä½œå‚è€ƒæ–‡ç« STM32å•ç‰‡æœºä¿®æ”¹å¯„å­˜å™¨çš„ä½æ“ä½œæ–¹æ³•(å…¨ç½‘æœ€å…¨)_å•ç‰‡æœºå•ç‹¬æ“ä½œä½-CSDNåšå®¢ æŠŠæŸä½æ¸…é›¶ 123456//å®šä¹‰ä¸€ä¸ªå˜é‡ a = 1001 1111 b (äºŒè¿›åˆ¶æ•°)unsigned char a = 0x9f;//å¯¹ bit2 æ¸…é›¶a &amp;= ~(1&lt;&lt;2); æŠŠè¿ç»­å‡ ä½æ¸…é›¶ 123456789//è‹¥æŠŠ a ä¸­çš„äºŒè¿›åˆ¶ä½åˆ†æˆ 2 ä¸ªä¸€ç»„//å³ bit0ã€bit1 ä¸ºç¬¬ 0 ç»„ï¼Œbit2ã€bit ä¸ºç¬¬ 1 ç»„ï¼Œ// bit4ã€bit5 ä¸ºç¬¬ 2 ç»„ï¼Œbit6ã€bit7 ä¸ºç¬¬ 3 ç»„//è¦å¯¹ç¬¬ 1 ç»„çš„ bit2ã€bit3 æ¸…é›¶a &amp;= ~(3&lt;&lt;2*1);//ä¾‹å¦‚å¯¹ç¬¬ 2 ç»„ bit4ã€bit5 æ¸…é›¶a &amp;= ~(3&lt;&lt;2*2); å¯¹æŸå‡ ä½èµ‹å€¼ 12345//a = 1000 0011 b//æ­¤æ—¶å¯¹æ¸…é›¶åçš„ç¬¬ 2 ç»„ bit4ã€bit5 è®¾ç½®æˆäºŒè¿›åˆ¶æ•°â€œ01 b â€a |= (1&lt;&lt;2*2);//a = 1001 0011 bï¼ŒæˆåŠŸè®¾ç½®äº†ç¬¬ 2 ç»„çš„å€¼ï¼Œå…¶å®ƒç»„ä¸å˜ å¯¹æŸä½å–å 12345//a = 1001 0011 b//æŠŠ bit7 å–åï¼Œå…¶å®ƒä½ä¸å˜a ^=(1&lt;&lt;6);//a = 1101 0011 b"},{"title":"LCD","path":"/wiki/lanqiao/LCD.html","content":"åµŒå…¥å¼LCDæ ¹æ®åŸç†å›¾åœ¨cubemxé…ç½®å¼•è„šï¼Œåˆå§‹åŒ–lcdã€‚ 1234LCD_Init();LCD_Clear(Black);//é»‘è‰²æ¸…å±ï¼Œä¸ç„¶LCDåŸæœ¬é¢œè‰²è¿˜ä¼šæ®‹å­˜LCD_SetBackColor(Black);//è®¾ç½®èƒŒæ™¯è‰²ä¸ºé»‘è‰²LCD_SetTextColor(White);//è®¾ç½®å‰æ™¯è‰²ä¸ºç™½è‰² è®°ä½è¦åœ¨ MX_GPIO_Init() ä¹‹åï¼Œå¦åˆ™å¯èƒ½åˆå§‹åŒ–å¤±è´¥ã€‚ åœ¨lcdå±ä¸Šæ˜¾ç¤ºå­—ç¬¦ï¼Œå¯ä»¥ä½¿ç”¨ void LCD_DisplayStringLine(u8 Line, u8 *ptr) ä¾‹å¦‚ï¼Œæ˜¾ç¤ºâ€Hello Worldâ€œ 1LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); æˆ–è€…ï¼Œå¯ä»¥ä½¿ç”¨sprintf()å‡½æ•°ï¼Œå‰æä½¿ç”¨stdioçš„å¤´æ–‡ä»¶ 12345#include &quot;stdio.h&quot;sprintf(text,&quot; count: %d &quot;,count);LCD_DisplayStringLine(Line4, (uint8_t *)text); è€ƒç‚¹1ï¼šå®ç°ç•Œé¢åˆ‡æ¢ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæŒ‰é”®ç•Œé¢åˆ‡æ¢çš„åŸºæœ¬æ€è·¯ï¼Œé€šè¿‡æŒ‰é”®æ¥å¢åŠ ç•Œé¢è®¡æ•°ã€‚æ³¨æ„ä¸è¦å°†viewå’Œcountå®šä¹‰æˆå‡½æ•°çš„å±€éƒ¨å˜é‡ï¼Œå¦åˆ™åœ¨æ¯æ¬¡åŠ è½½è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ç•Œé¢éƒ½æ˜¯ç¬¬ä¸€ä¸ªç•Œé¢ï¼Œæ— æ³•è¿›è¡Œåˆ‡æ¢ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839// å…¨å±€å˜é‡uint8_t view = 0;uint8_t count = 0;void lcd_process(void)&#123; char text[30]; for(uint8_t i = 0;i &lt; 4; i++) &#123; if(key[0].key_isPressed == 1) &#123; view++; key[i].key_isPressed = 0; if(view ==3) &#123; view = 0; &#125; &#125; if(key[1].key_isPressed == 1) &#123; count++; key[1].key_isPressed = 0; &#125; &#125; if(view==0) &#123; LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); &#125; if(view==1) &#123; sprintf(text,&quot; count: %d &quot;,count); LCD_DisplayStringLine(Line4, (uint8_t *)text); &#125; if(view == 2) &#123; LCD_DisplayStringLine(Line4,(unsigned char*)&quot; END &quot;); &#125;&#125; è€ƒç‚¹2ï¼šæ–‡æœ¬é«˜äº®æ²¡å•¥æŠ€æœ¯å«é‡ï¼Œæ›´æ”¹å¯¹åº”è¡Œçš„èƒŒæ™¯é¢œè‰²å’Œè®¾ç½®è¡Œåˆ‡æ¢æ ‡å¿—ã€‚ä½¿ç”¨æŒ‰é”®æ§åˆ¶è¡Œæ ‡å¿—ä½å¢å‡ã€‚ä¸å±å¹•ç•Œé¢åˆ‡æ¢çš„æ€è·¯ä¸€æ ·ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243if(view == 1) &#123; char text2[30]; if(line_flag == 0) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; if(line_flag == 1) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; if(line_flag == 2) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; &#125; æ³¨æ„ï¼Œå½“ä¸¤ä¸ªç•Œé¢æ‰€éœ€è¦çš„è¡Œæ•°ä¸åŒæ—¶ï¼Œæ¯”å¦‚ï¼Œç•Œé¢1åªæœ‰ä¸€è¡Œå­—ç¬¦ä¸²ï¼Œç•Œé¢2æœ‰ä¸‰è¡Œå­—ç¬¦ä¸²ï¼Œéœ€è¦ç»™ç•Œé¢1å¢åŠ ä¸‰è¡Œç©ºå­—ç¬¦ä¸²ï¼Œå³ 123456789if(view == 0) &#123; char text1[30]; sprintf(text1,&quot; Hello,world. &quot;); LCD_SetBackColor(Black); LCD_DisplayStringLine(Line4, (uint8_t *)text1); LCD_DisplayStringLine(Line5, (unsigned char *)&quot; &quot;); LCD_DisplayStringLine(Line6, (unsigned char *)&quot; &quot;); &#125; å¦åˆ™ä¼šå‡ºç°ç•Œé¢ä¹‹é—´çš„å­—ç¬¦ä¸²ä¸²åœ¨ç•Œé¢ä¸­ã€‚"},{"title":"TIM","path":"/wiki/lanqiao/TIM.html","content":"åµŒå…¥å¼TIMè€ƒç‚¹1ï¼šè®¡ç®—è¾“å‡ºé¢‘ç‡ï¼Œå ç©ºæ¯” å…³é”®æ¦‚å¿µï¼š ARRï¼šè‡ªåŠ¨é‡è£…è½½å€¼ï¼ˆAutoReloader Registerï¼‰ CCRxï¼šæ•è·å¯„å­˜å™¨å€¼ CNTï¼šè®¡æ•°å™¨å€¼ PSCï¼šé¢„åˆ†é¢‘å€¼ï¼ˆPrescalerï¼‰ å½“CNTå°äºCCRxæ—¶ï¼Œè®¡æ—¶å™¨é€šé“TIMx_CHxè¾“å‡ºé«˜ç”µå¹³ï¼Œåä¹‹è¾“å‡ºä½ç”µå¹³ è®°ä½ï¼ï¼ï¼ é¢‘ç‡ $=\\frac{\\text{CLK}}{(\\text{PSC+1})(\\text{ARR+1})}$ å ç©ºæ¯” $= \\frac{\\text{CRRx}}{\\text{ARR+1}}$ å…¬å¼ä¸­ï¼ŒCLKå·²ç»åœ¨åˆ›å»ºå·¥ç¨‹æ—¶è®¾ç½®æˆäº†80MHzï¼Œè€ŒARRå’ŒPSCå¯ä»¥åœ¨cubemxä¸­è®¾ç½®ï¼ŒCCRxåœ¨ç¨‹åºä¸­è®¾ç½®ã€‚ çœèµ›é¢˜ï¼š åœ¨cubemxä¸­é…ç½®PA6å’ŒPA7å¼•è„šåˆ†åˆ«ä¸ºTIMx_CHxé€šé“ã€‚ æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤ä¿®æ”¹å¯„å­˜å™¨çš„å€¼ï¼š 12TIM3-&gt;ARR= //ä¿®æ”¹å®šæ—¶å™¨3çš„ARRå€¼ï¼Œç”¨äºä¿®æ”¹é¢‘ç‡TIM3-&gt;CCRx= //ä¿®æ”¹å®šæ—¶å™¨3é€šé“xçš„CCRå€¼ï¼Œç”¨äºä¿®æ”¹å ç©ºæ¯” å¯¹äºè¿™é¢˜ï¼Œåœ¨keil5ä¸­ï¼Œ å…ˆåˆå§‹åŒ–é€šé“ï¼š 123456789//åˆå§‹åŒ–HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1); //PA6HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1); //PA//æ ¹æ®å¯„å­˜å™¨ä¸­ARRçš„å€¼é…ç½®é¢‘ç‡PA6_frq=10000/(TIM3-&gt;ARR+1);PA7_frq=20000/(TIM17-&gt;ARR+1);//é…ç½®å ç©ºæ¯”ï¼Œåœ¨cubemx ARR+1ä¸º100ï¼ŒCRR1çš„å€¼æ­£å¥½å°±æ˜¯å¯¹åº”çš„ç™¾åˆ†æ•°TIM3-&gt;CCR1=PA6_duty; //PA6TIM17-&gt;CCR1=PA7_duty; //PA7 é…ç½®æŒ‰é”®æ“ä½œï¼š 1234567891011121314if(key[1].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA6_duty+=10; if(PA6_duty==100) PA6_duty=10; TIM3-&gt;CCR1=PA6_duty; key[1].key_isPressed =0; &#125;if(key[2].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA7_duty+=10; if(PA7_duty==100) PA7_duty=10; TIM17-&gt;CCR1=PA7_duty; key[2].key_isPressed = 0; &#125; é…ç½®LCDçš„æ˜¾ç¤ºï¼š 123456789101112if(view == 0) &#123; char buf[20]; sprintf(buf,&quot;PA6_frq:%dHz&quot;,PA6_frq); LCD_DisplayStringLine(Line4,(uint8_t*)buf); sprintf(buf,&quot;PA7_frq:%dHz&quot;,PA7_frq); LCD_DisplayStringLine(Line5,(uint8_t*)buf); sprintf(buf,&quot;PA6_duty:%d%%&quot;,PA6_duty); LCD_DisplayStringLine(Line7,(uint8_t*)buf); sprintf(buf,&quot;PA7_duty:%d%%&quot;,PA7_duty); LCD_DisplayStringLine(Line8,(uint8_t*)buf); &#125; è€ƒç‚¹2ï¼šè¾“å…¥æ•è·é¢‘ç‡åŸç†æ˜¯è°ƒæ•´ä¿¡å·å‘ç”Ÿå™¨çš„é¢‘ç‡ï¼Œå¯¹åº”çš„åˆ†åˆ«æ˜¯PA15å’ŒPB4ï¼Œéœ€è¦åœ¨cubemxä¸­é…ç½®å®šæ—¶å™¨è¾“å…¥æ•è·æ¨¡å¼ã€‚ ä»¥TIM2_CH1ä¸ºä¾‹ï¼Œéœ€è¦åœ¨cubemxä¸­åˆ†åˆ«é…ç½®ä¸¤ä¸ªé€šé“ä¸ºdirect å’Œ indirectã€‚ è®°å¾—æ‰“å¼€NVICä¸­æ–­ä½¿èƒ½ é¦–å…ˆéœ€è¦å¯åŠ¨å®šæ—¶å™¨ï¼š 1234HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_2); æ¥ç€ï¼Œé…ç½®è¾“å…¥æ•æ‰å›è°ƒå‡½æ•°ï¼š 123456789101112131415161718192021void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123; if(htim-&gt;Instance == TIM2) &#123; if(htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) &#123; tim2_val1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); /* è¯»å–é€šé“ä¸€ï¼Œä¸Šå‡æ²¿çš„å€¼ ä¸€ä¸ªå®Œæ•´çš„å‘¨æœŸ */ tim2_val2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); /* è¯»å–é€šé“äºŒï¼Œä¸‹é™æ²¿çš„å€¼ ä¸€ä¸ªå‘¨æœŸä¸­çš„é«˜ç”µå¹³ */ __HAL_TIM_SetCounter(htim, 0);/* æ¸…é›¶å®šæ—¶å™¨ä¸­çš„å€¼ï¼Œç»§ç»­è¯»å–ä¸‹ä¸€å‘¨æœŸçš„è„‰å†² */ /* æ•è·åˆ°çš„é¢‘ç‡ = æ—¶é’Ÿé¢‘ç‡ / é¢„åˆ†é¢‘å€¼ / æ•è·çš„å€¼ï¼ˆä»0å¼€å§‹ç›´åˆ°ä¸Šå‡æ²¿äº§ç”Ÿè¯»çš„æ•°å€¼ï¼‰ */ tim2_freq = (80000000 / 80) / tim2_val1; /* æ•è·çš„å ç©ºæ¯” = é«˜ç”µå¹³çš„æ—¶é—´ / ä½ç”µå¹³çš„æ—¶é—´ * 100 */ tim2_duty = ((float)tim2_val2 / tim2_val1) * 100; HAL_TIM_IC_Start(htim, TIM_CHANNEL_1); //é‡å¼€é€šé“1 HAL_TIM_IC_Start(htim, TIM_CHANNEL_2); //é‡å¼€é€šé“2 &#125; &#125; &#125; è¿™é‡Œå†™äº†TIM2çš„é¢‘ç‡æ•è·éƒ¨åˆ†ï¼Œå¯¹äºTIM3ï¼Œæ˜¯ä¸€æ ·çš„ã€‚ æ¥ä¸‹æ¥åªéœ€è¦åœ¨LCDä¸­è¾“å…¥æ˜¾ç¤ºå³å¯ã€‚"},{"title":"RTC","path":"/wiki/lanqiao/RTC.html","content":"åµŒå…¥å¼RTCRTCå®æ—¶æ—¶é’Ÿç”¨æ¥è·å–æ—¶é—´å’Œæ—¥æœŸ cubemx RTCé…ç½® å…¶ä¸­Calendar Timeæ˜¯å½“å‰æ—¶é—´ï¼ŒCalendar Dateä¸ºå½“å‰æ—¥æœŸ è®°ä½Generalä¸­çš„å¼‚æ­¥åˆ†é¢‘ï¼ˆAPVï¼‰æ˜¯125ï¼ŒåŒæ­¥åˆ†é¢‘ï¼ˆSPVï¼‰æ˜¯6000 æ¥ç€ï¼Œåœ¨keilä¸­å…ˆé…ç½®æ—¶é—´ç»“æ„ä½“ 1234/* USER CODE BEGIN PTD */RTC_TimeTypeDef time; //æ—¶é—´ç»“æ„ä½“RTC_DateTypeDef date; //æ—¥æœŸç»“æ„ä½“/* USER CODE END PTD */ ç„¶ååœ¨ä¸»å¾ªç¯ä¸­è¿›è¡Œå®æ—¶è®¡æ—¶ï¼š 12345678910111213 while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);sprintf(buf,&quot;Date:%2d-%2d-%2d &quot;,date.Year,date.Month,date.Date);LCD_DisplayStringLine(Line1,(uint8_t*)buf);sprintf(buf,&quot;Time:%2d-%2d-%2d &quot;,time.Hours,time.Minutes,time.Seconds);LCD_DisplayStringLine(Line2,(uint8_t*)buf); &#125; /* USER CODE END 3 */"},{"title":"USART","path":"/wiki/lanqiao/USART.html","content":"åµŒå…¥å¼USARTå…ˆåœ¨cubemxé…ç½®USARTä¸­æ–­ï¼Œè°ƒè¯•æ—¶é…åˆä¸²å£è°ƒè¯•åŠ©æ‰‹ã€‚ æ³¨æ„å­—ç¬¦ä¸²æ“ä½œè¦ä½¿ç”¨stringåº“ è€ƒç‚¹1ï¼šä¸²å£å‘é€ä¾‹å¦‚ï¼Œå‘ä¸Šä½æœºå‘é€Hello World! 1234567891011121314151617char tx_buf[20]; //å­—ç¬¦ç¼“å­˜åŒºuint8_t rx_data; sprintf(tx_buf,&quot;Hello World!\\r &quot;);HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50);HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)/* * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be sent. * @param Timeout Timeout duration. * @retval HAL status*/ è€ƒç‚¹2ï¼šä¸²å£æ¥æ”¶ä¸²å£æ¥æ”¶å‡½æ•°åœ¨HALåº“ä¸­çš„å®šä¹‰ 1234567891011/** * @brief Recive an amount of data in interrupt mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the received data is handled as a set of u16. In this case, Size must indicate the number * of u16 available through pData. * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be received. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) è¿›è¡Œä¸²å£æ¥æ”¶æ—¶ï¼Œæˆ‘ä»¬è¦ç¼–å†™ä¸²å£ä¸­æ–­å‡½æ•°ï¼Œå‡½æ•°åå’Œå½¢å‚ä¸èƒ½æ”¹ï¼Œå‡½æ•°æœ¬èº«æ˜¯ç©ºå†…å®¹ï¼Œå’ŒTIMä¸­æ–­å‡½æ•°ä¸€è‡´ 1void HAL_UART_RxCpltCallback(UART_HandleTypedef *huart) ä¸²å£æ¥æ”¶åˆåˆ†ä¸ºå‡ ç§ï¼Œé¦–å…ˆæ˜¯å•å­—ç¬¦æ¥æ”¶ï¼Œä¾‹å¦‚ï¼Œæ¥æ”¶ä¸åŒçš„å•å­—ç¬¦æ¥å¯¹LED1è¿›è¡Œæ§åˆ¶ï¼š 12345678910111213141516171819202122void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(rx_data==&#x27;O&#x27;) &#123; ucled=0x01; sprintf(tx_buf,&quot;LED1 Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else if(rx_data==&#x27;C&#x27;) &#123; ucled=0x00; sprintf(tx_buf,&quot;LED1 Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else &#123; sprintf(tx_buf,&quot;Error!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); Led_Disp(ucled);&#125; è¦æå‰æ‰“å¼€æ¥æ”¶ä¸­æ–­ 123/* USER CODE BEGIN 2 */HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); //æ‰“å¼€æ¥æ”¶ä¸­æ–­/* USER CODE END 2 */ åªè¦æ¥æ”¶ä¸­æ–­å°±ä¼šè¿›å…¥ä¸²å£ä¸­æ–­å‡½æ•° å†ä¾‹å¦‚ï¼Œæ¥æ”¶å¤šå­—ç¬¦è¿›è¡ŒLEDæ§åˆ¶ï¼š 12345678910111213141516171819202122232425262728void Usart_Proc(void)&#123; if(rx_count==4) &#123; if(strcmp(rx_buf,&quot;LEDO&quot;)==0) &#123; ucled=0x01; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; if(strcmp(rx_buf,&quot;LEDC&quot;)==0) &#123; ucled=0x00; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; rx_count=0; memset(rx_buf,0,20); //å°†ç¼“å­˜æ¸…ç©º &#125; &#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; rx_buf[rx_count++]=rx_data; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1);&#125; åœ¨ä¸»å‡½æ•°ä¸»å¾ªç¯ä¸­ä½¿ç”¨Usart_Proc()å‡½æ•°ï¼ŒåŒæ ·çš„ï¼Œåœ¨æ¥æ”¶ä¸Šä½æœºå‘é€çš„ä¿¡æ¯åä¼šè¿›å…¥ä¸²å£ä¸­æ–­å‡½æ•°ï¼ŒåŒæ ·çš„ï¼Œè¦æå‰æ‰“å¼€æ¥æ”¶ä¸­æ–­ã€‚ è€ƒç‚¹3ï¼šsscanf()å‡½æ•°è§£æå­—ç¬¦ä¸²12345678int sscanf(const char* str, const char* format, ...);/*å‚æ•°ï¼šstrï¼šè¦è§£æçš„è¾“å…¥å­—ç¬¦ä¸²ã€‚formatï¼šæ ¼å¼å­—ç¬¦ä¸²ï¼ŒæŒ‡å®šè¦åŒ¹é…çš„æ ¼å¼è§„åˆ™ã€‚...ï¼šå¯å˜å‚æ•°åˆ—è¡¨ï¼Œç”¨äºæ¥æ”¶è§£æåçš„æ•°æ®ã€‚*/ ä¾‹å¦‚ï¼Œçœèµ›ä¸­è§£æè½¦ç‰Œå­—ç¬¦ä¸²ï¼š 123456789101112131415void Usart_Proc(void)&#123; if(rx_count==22) &#123; sscanf(rx_buf,&quot;%4s:%4s:%12s&quot;,car_type,car_num,car_time); sprintf(tx_buf,&quot;car_type:%4s\\r &quot;,car_type); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_num:%4s\\r &quot;,car_num); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_time:%4s\\r &quot;,car_time); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); rx_count=0; memset(rx_buf,0,20); &#125;&#125;"}]