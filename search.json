[{"title":"为什么我想建立自己的博客网站","path":"/2025/03/23/20250324/","content":"距离我上一次接触”博客”这个概念，已过去十余年。彼时新浪博客正风靡一时，我按照信息技术课本上的指导注册了人生第一个博客账号。如今那个网站似乎已停止维护，昔日的账号也早已遗忘在时光里。 这个博客诞生的动力 只是想找个能妥善存储文档的地方！！！ 既然如此，为何要大费周章搭建独立博客呢？ 前段时间遭遇的硬盘损坏事件，让我对本地存储彻底失去安全感。我开始将重要数据迁移至云端，然而国内主流网盘的免费存储空间实在有限（沟槽的bd），最终将目光投向Github——单个文件100MB上限、仓库容量5GB、不限仓库数量。 这个方案确实令人心动！！！ 我立即创建了若干仓库，将文档分门别类上传。然而使用过程中渐觉不足：单调的个人界面、不稳定的访问体验，以及强烈的个性化缺失感。 偶然间看到技术同行的个人博客——优雅的界面设计、清晰的文档分类、流畅的交互体验，着实令人向往。 灵光乍现：何不搭建自己的博客网站？既可系统化管理学习文档，又能自由定制视觉风格。虽说是临时起意，但这个想法一旦萌生便挥之不去。 从零开始的搭建历程对于毫无前端经验的新手而言，独立建站谈何容易。经过大量资料查阅，最终选择Hexo静态博客框架搭配Stellar主题。从环境配置到主题调试，历经整个通宵的摸索，这个博客的雏形终于初现。 内容与展望本博客主要存放个人学习笔记与技术心得，内容难免存在纰漏，恳请读者不吝指正！目前网站功能尚显单薄，计划后续逐步添加如下组件： 全局搜索功能 访客评论系统 内容交互式演示模块 技术探索永无止境，让我们共同见证这个博客的成长轨迹。","tags":["博客"],"categories":["杂谈"]},{"title":"Robotics(EN)","path":"/notes/robotics.html","content":"Chap1. Spatial Descriptions and TransformationsSec 1.1 Descriptions: Positions, Orientations and Frames Descriptions of a position $$\\mathbf{^A P} &#x3D; \\begin{bmatrix} P_x \\ P_y \\ P_z \\end{bmatrix}$$ Position is represented in a column vector $(n \\times 1)$ Description of an orientation Rotation matrix $${}^A_BR &#x3D; \\left[ {}^A\\widehat{X}_B \\quad {}^A\\widehat{Y}_B \\quad {}^A\\widehat{Z}_B \\right]$$ Properties Transpose of rotation matrix describing $ \\left { A \\right } $ relative to $\\left { B \\right } $ equals to the matrix describing $ \\left { B \\right } $ relative to $\\left { A\\right } $ : $${}^A_BR &#x3D; {}^B_AR^T$$ Rotation matrix describing a rectangular coordinate system $\\left {A \\right } $ relative to another is orthogonal: $${}^B_AR^{-1} &#x3D; {}^B_AR^T$$ Description of a frame A frame (coordinate system) can be described by a vector and a rotation matrix: $${B} &#x3D; {^A_BR, ^A\\mathbf{P}_{BORG}}$$ Attention ${}^A_BR(x, \\alpha)$: ${B}$ rotated counterclockwise about ${A}$’s x-axis by $\\alpha$ degrees ${}^A_BR(y, \\beta)$: ${B}$ rotated counterclockwise about ${A}$’s y-axis by $\\beta$ degrees ${}^A_BR(z, \\gamma)$: ${B}$ rotated counterclockwise about ${A}$’s z-axis by $\\gamma$ degrees Rotation Matrices: $${}^A_BR(x, \\alpha) &#x3D; \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; \\cos\\alpha &amp; -\\sin\\alpha \\ 0 &amp; \\sin\\alpha &amp; \\cos\\alpha \\end{bmatrix}$$ $${}^A_BR(y, \\beta) &#x3D; \\begin{bmatrix} \\cos\\beta &amp; 0 &amp; \\sin\\beta \\ 0 &amp; 1 &amp; 0 \\ -\\sin\\beta &amp; 0 &amp; \\cos\\beta \\end{bmatrix}$$ $${}^A_BR(z, \\gamma) &#x3D; \\begin{bmatrix} \\cos\\gamma &amp; -\\sin\\gamma &amp; 0 \\ \\sin\\gamma &amp; \\cos\\gamma &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ Sec 1.2 MappingsMapping changes the description of a point from one frame to another. Mappings involving translated frames If ${A}$ and ${B}$ have the same orientation but differ by translation ${}^AP_{BORG}$: $$^AP &#x3D; ^BP + ^AP_{BORG}$$ $$ Mappings involving rotated frames If ${A}$ and ${B}$ share the same origin but differ by rotation ${}^A_BR$: $${}^AP &#x3D; {}^A_BR , {}^BP$$ Mapings involving general frames For frames differing by both translation and rotation: $${}^AP &#x3D; {}^A_BR , {}^BP + {}^AP_{BORG}$$ Homogeneous Transform Matrix: $${}^A_BT &#x3D; \\begin{bmatrix} {}^A_BR &amp; {}^A\\mathbf{P}_{BORG} \\ \\mathbf{0} &amp; 1 \\end{bmatrix}$$ $$\\begin{bmatrix} {}^AP \\ 1 \\end{bmatrix} &#x3D; {}^A_BT \\begin{bmatrix} {}^BP \\ 1 \\end{bmatrix}$$ AttentionMapping describes the same point in different frames. Translation and rotation relate frames, not point positions. Sec 1.3 OperatorsOperators translate points, rotate vectors, or both. Translational operators Translating point $P_1$ by ${}^A\\mathbf{Q}$: $${}^AP_2 &#x3D; {}^AP_1 + {}^A\\mathbf{Q}$$ Matrix form: $$D_Q &#x3D; \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; q_x \\ 0 &amp; 1 &amp; 0 &amp; q_y \\ 0 &amp; 0 &amp; 1 &amp; q_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}$$ $$\\begin{bmatrix} {}^AP_2 \\ 1 \\end{bmatrix} &#x3D; D_Q \\begin{bmatrix} {}^AP_1 \\ 1 \\end{bmatrix}$$ Rotational operators Rotating vector ${}^AP_1$ by $R$: $${}^AP_2 &#x3D; R , {}^AP_1$$ $R$ is equivalent to a rotation matrix ${}^A_BR$. Transformation operators Combining translation and rotation: $$\\begin{bmatrix} {}^AP_2 \\ 1 \\end{bmatrix} &#x3D; T \\begin{bmatrix} {}^AP_1 \\ 1 \\end{bmatrix}$$ where $T &#x3D; \\begin{bmatrix} R &amp; \\mathbf{Q} \\ 0 &amp; 1 \\end{bmatrix}$. AttentionOperators act on vectors before transformation, while mappings describe vectors after transformation. Sec 1.4 Transformation Arithmetic Compound Transformation Problem: Transform ${}^CP$ to ${}^AP$ via intermediate frames: $${}^A_CT &#x3D; {}^A_BT {}^B_CT$$ $$\\begin{bmatrix} {}^AP \\ 1 \\end{bmatrix} &#x3D; {}^A_CT \\begin{bmatrix} {}^CP \\ 1 \\end{bmatrix}$$ Fixed reference frame transformations: $${}^3_1T &#x3D; {}^3_2T {}^2_1T$$ Inverse transformation Method 1: ${}^B_AT &#x3D; {}^A_BT^{-1}$ Method 2: $${}^B_AT &#x3D; \\begin{bmatrix} {}^A_BR^T &amp; -{}^A_BR^T , {}^AP_{BORG} \\ \\mathbf{0} &amp; 1 \\end{bmatrix}$$ Sec 1.5 More on Representation of Orientation X-Y-Z Fixed Angles Rotate ${B}$ about fixed axes of ${A}$ (order: X→Y→Z): $${}^A_BR &#x3D; R(z, \\alpha) R(y, \\beta) R(x, \\gamma)$$ Z-Y-X Euler Angles Rotate ${B}$ about its own axes (order: Z→Y→X): $${}^A_BR &#x3D; R(z, \\alpha) R(y, \\beta) R(x, \\gamma)$$ Z-Y-Z Euler Angles Rotate ${B}$ about its own axes (order: Z→Y→Z): $${}^A_BR &#x3D; R(z, \\alpha) R(y, \\beta) R(z, \\gamma)$$ Comparison Chap 2. Manipulator Kinematics"},{"path":"/notes/index.html","content":"写在前面面向期末的笔记，全英的。（课是全英的课"},{"title":"KEY","path":"/wiki/lanqiao/KEY.html","content":"嵌入式按键使用按键状态机，在用户区新建Key_State.c和Key_State.h文件。在Key_State.h中，写下 123456789101112131415161718192021222324252627#ifndef __KEY_STATE_H_#define __KEY_STATE_H_#include &quot;main.h&quot;/** * @brief 按键状态结构体 */struct keys&#123; uint8_t judge_state; // 状态机标志，0： 检测到一个低电平；1：确实被按下；2：等待抬起 uint8_t key_state; // 按键是否被按下（信号来自GPIO输入） uint8_t key_isPressed; // 按键短按标志位 uint8_t key_long_flag; // 按键长按标志位 uint32_t key_time; // 按键计时 uint32_t key_double_click_time; // 双击计时器 uint8_t key_double_click_EN; // 双击计时器使能 uint8_t key_double_click_flag; // 双击标志位&#125;;extern struct keys key[];void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);#endif keys结构体即为按键状态机，使用定时中断函数进行按键消抖。 Key_State.c内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;Key_State.h&quot;struct keys key[4] = &#123;0, 0, 0, 0&#125;;/** * @brief TIM定时器定时中断回调函数 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM3) &#123; key[0].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); key[1].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1); key[2].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2); key[3].key_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); for (uint8_t i = 0; i &lt; 4; i ++) &#123; if (key[i].key_double_click_EN == 1) // 计数器使能开启时，计时并判断 &#123; key[i].key_double_click_time ++; if (key[i].key_double_click_time &gt; 35) // 如果超时，则说明是短按，置标志位后关闭计数器使能 &#123; key[i].key_isPressed = 1; key[i].key_double_click_EN = 0; &#125; &#125; switch (key[i].judge_state) &#123; case 0: if (key[i].key_state == 0) // 如果刚开始检测到一个低电平 &#123; key[i].key_time = 0; // 时间计数清0 key[i].judge_state = 1; &#125; break; case 1: if (key[i].key_state == 0) // 如果10ms后依然检测到这个按键是低电平，就说明这个按键确实被按下了 &#123; key[i].judge_state = 2; &#125; else &#123; key[i].judge_state = 0; &#125; break; case 2: if (key[i].key_state == 1 &amp;&amp; key[i].key_time &lt;= 70) // 如果是一次短按 &#123; key[i].judge_state = 0; if (key[i].key_double_click_EN == 0) // 如果是第一次按下 &#123; key[i].key_double_click_EN = 1; key[i].key_double_click_time = 0; &#125; else // 双击计时开启，说明这次短按还在双击计时的时间范围内 &#123; key[i].key_double_click_EN = 0; key[i].key_double_click_flag = 1; &#125; &#125; else if (key[i].key_state == 1 &amp;&amp; key[i].key_time &gt; 70) // 长按松开按键，则回到state0 &#123; key[i].judge_state = 0; &#125; else if (key[i].key_state == 0) // 如果按键没有松开，则持续计时 &#123; key[i].key_time ++; if (key[i].key_time &gt; 70) // 如果按键按下时间大于700ms &#123; key[i].key_long_flag = 1; &#125; &#125; break; default: break; &#125; &#125; &#125;&#125; 记住要在cubemx中设置10ms中断，其中PSC预分频是79（80-1），ARR重装预载是9999（10000-1）。"},{"title":"ADC","path":"/wiki/lanqiao/ADC.html","content":"嵌入式ADC在cubemx中选择PB12，PB15分别设置为ADC输出模式（ADC1_IN11和ADC2_IN15） 生成代码后，在adc.c文件中写单通道采样函数，需要在adc.h文件中声明 1234567double getADC(ADC_HandleTypeDef *pin)&#123; uint16_t adc; HAL_ADC_Start(pin); adc = HAL_ADC_GetValue(pin); return adc*3.3/4096;&#125; 在主函数中，用ACD_Proc()调用采样功能 12345678void ADC_Proc(void)&#123; char text[20]; adc_value1 = getADC(&amp;hadc1); adc_value2 = getADC(&amp;hadc2); sprintf(text,&quot;ADC1:%.2f,ADC2:%.2f&quot;,adc_value1,adc_value2); LCD_DisplayStringLine(Line4,(uint8_t *)text);&#125; 需要注意的是，记得在adc.c中使用校准函数对采样进行校准，否则采样最大值为3.25V 123456/* USER CODE BEGIN ADC1_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc1,ADC_SINGLE_ENDED);/* USER CODE END ADC1_Init 2 *//* USER CODE BEGIN ADC2_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);/* USER CODE END ADC2_Init 2 */"},{"title":"LCD","path":"/wiki/lanqiao/LCD.html","content":"嵌入式LCD根据原理图在cubemx配置引脚，初始化lcd。 1234LCD_Init();LCD_Clear(Black);//黑色清屏，不然LCD原本颜色还会残存LCD_SetBackColor(Black);//设置背景色为黑色LCD_SetTextColor(White);//设置前景色为白色 记住要在 MX_GPIO_Init() 之后，否则可能初始化失败。 在lcd屏上显示字符，可以使用 void LCD_DisplayStringLine(u8 Line, u8 *ptr) 例如，显示”Hello World“ 1LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); 或者，可以使用sprintf()函数，前提使用stdio的头文件 12345#include &quot;stdio.h&quot;sprintf(text,&quot; count: %d &quot;,count);LCD_DisplayStringLine(Line4, (uint8_t *)text); 考点1：实现界面切换。 以下是一个按键界面切换的基本思路，通过按键来增加界面计数。注意不要将view和count定义成函数的局部变量，否则在每次加载这个函数的时候界面都是第一个界面，无法进行切换。 123456789101112131415161718192021222324252627282930313233343536373839// 全局变量uint8_t view = 0;uint8_t count = 0;void lcd_process(void)&#123; char text[30]; for(uint8_t i = 0;i &lt; 4; i++) &#123; if(key[0].key_isPressed == 1) &#123; view++; key[i].key_isPressed = 0; if(view ==3) &#123; view = 0; &#125; &#125; if(key[1].key_isPressed == 1) &#123; count++; key[1].key_isPressed = 0; &#125; &#125; if(view==0) &#123; LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); &#125; if(view==1) &#123; sprintf(text,&quot; count: %d &quot;,count); LCD_DisplayStringLine(Line4, (uint8_t *)text); &#125; if(view == 2) &#123; LCD_DisplayStringLine(Line4,(unsigned char*)&quot; END &quot;); &#125;&#125; 考点2：文本高亮 没啥技术含量，更改对应行的背景颜色和设置行切换标志 12345678910111213141516171819202122232425262728293031323334353637383940414243if(view == 1) &#123; char text2[30]; if(line_flag == 0) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; if(line_flag == 1) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; if(line_flag == 2) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; &#125; 注意，当两个界面所需要的行数不同时，比如，界面1只有一行字符串，界面2有三行字符串，需要给界面1增加三行空字符串，即 123456789if(view == 0) &#123; char text1[30]; sprintf(text1,&quot; Hello,world. &quot;); LCD_SetBackColor(Black); LCD_DisplayStringLine(Line4, (uint8_t *)text1); LCD_DisplayStringLine(Line5, (unsigned char *)&quot; &quot;); LCD_DisplayStringLine(Line6, (unsigned char *)&quot; &quot;); &#125; 否则会出现界面之间的字符串串在界面中。"},{"title":"LED","path":"/wiki/lanqiao/LED.html","content":"LED操作在cubemx中配置时钟和引脚，LED低电平有效 注意要打开PD2锁存器 基本写法： 123456void LED(uint8_t dsled)&#123; HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); //打开锁存器 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET); //灭掉所有的LED HAL_GPIO_WritePin(GPIOC, dsled&lt;&lt;8, GPIO_PIN_RESET); //选择特定的LED亮起&#125; 其中dsled是8位无符号数，0x_ _。 高位即为左边四个led，低位即为右边四个led。每一位取1即为该led亮。 LED交替闪烁和LED闪烁取反 ~ 左四位和右四位交替闪烁 取异或^该位led闪烁 1234567891011uint8_t ucLed=0x0f; //交替闪烁LED(~ucLed); //闪烁uint8_t ucLed2 = 0x0f;LED(ucLed2);HAL_Delay(1000);ucLed2^=0x0f; LED实现流水灯位运算左移和右移（&lt;&lt;和&gt;&gt;） Systick 滴答计时HAL_Delay()是阻塞赋值，可以使用Systick进行计时，Systick进行了已经设置了1ms的中断。 计时方式 12345678910111213141516171819202122232425262728293031//在文件：stm32g4xx_it.c中/* USER CODE BEGIN PV */extern uint32_t usled;/* USER CODE END PV */void SysTick_Handler(void)&#123;/* USER CODE BEGIN SysTick_IRQn 0 *//* USER CODE END SysTick_IRQn 0 */ HAL_IncTick();/* USER CODE BEGIN SysTick_IRQn 1 */ usled++;//实现usled每隔1ms自增1/* USER CODE END SysTick_IRQn 1 */&#125;//在文件main.c中/* USER CODE BEGIN PV */uint32_t usled;uint8_t ucled=0x01;/* USER CODE END PV *//* USER CODE BEGIN 3 */Led_Disp(ucled);if(usled&gt;=500)//500ms到&#123; usled=0;//重新计数 ucled^=0x01;//反转led1&#125;/* USER CODE END 3 */ 解决LED引脚冲突问题修改PD2引脚为低电平 将LED显示函数改成如下： 12345678910void Led_Disp(uint8_t ucled)&#123; HAL_GPIO_WritePin(GPIOC,0xFF&lt;&lt;8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC,ucled&lt;&lt;8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);&#125; 增加了重写PD2引脚高低电平的函数"},{"title":"USART","path":"/wiki/lanqiao/USART.html","content":"嵌入式USART先在cubemx配置USART中断，调试时配合串口调试助手。 注意字符串操作要使用string库 考点1：串口发送例如，向上位机发送Hello World! 1234567891011121314151617char tx_buf[20]; //字符缓存区uint8_t rx_data; sprintf(tx_buf,&quot;Hello World!\\r &quot;);HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50);HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)/* * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be sent. * @param Timeout Timeout duration. * @retval HAL status*/ 考点2：串口接收串口接收函数在HAL库中的定义 1234567891011/** * @brief Recive an amount of data in interrupt mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the received data is handled as a set of u16. In this case, Size must indicate the number * of u16 available through pData. * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be received. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 进行串口接收时，我们要编写串口中断函数，函数名和形参不能改，函数本身是空内容，和TIM中断函数一致 1void HAL_UART_RxCpltCallback(UART_HandleTypedef *huart) 串口接收又分为几种，首先是单字符接收，例如，接收不同的单字符来对LED1进行控制： 12345678910111213141516171819202122void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(rx_data==&#x27;O&#x27;) &#123; ucled=0x01; sprintf(tx_buf,&quot;LED1 Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else if(rx_data==&#x27;C&#x27;) &#123; ucled=0x00; sprintf(tx_buf,&quot;LED1 Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else &#123; sprintf(tx_buf,&quot;Error!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); Led_Disp(ucled);&#125; 要提前打开接收中断 123/* USER CODE BEGIN 2 */HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); //打开接收中断/* USER CODE END 2 */ 只要接收中断就会进入串口中断函数 再例如，接收多字符进行LED控制： 12345678910111213141516171819202122232425262728void Usart_Proc(void)&#123; if(rx_count==4) &#123; if(strcmp(rx_buf,&quot;LEDO&quot;)==0) &#123; ucled=0x01; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; if(strcmp(rx_buf,&quot;LEDC&quot;)==0) &#123; ucled=0x00; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; rx_count=0; memset(rx_buf,0,20); //将缓存清空 &#125; &#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; rx_buf[rx_count++]=rx_data; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1);&#125; 在主函数主循环中使用Usart_Proc()函数，同样的，在接收上位机发送的信息后会进入串口中断函数，同样的，要提前打开接收中断。 考点3：sscanf()函数解析字符串12345678int sscanf(const char* str, const char* format, ...);/*参数：str：要解析的输入字符串。format：格式字符串，指定要匹配的格式规则。...：可变参数列表，用于接收解析后的数据。*/ 例如，省赛中解析车牌字符串： 123456789101112131415void Usart_Proc(void)&#123; if(rx_count==22) &#123; sscanf(rx_buf,&quot;%4s:%4s:%12s&quot;,car_type,car_num,car_time); sprintf(tx_buf,&quot;car_type:%4s\\r &quot;,car_type); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_num:%4s\\r &quot;,car_num); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_time:%4s\\r &quot;,car_time); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); rx_count=0; memset(rx_buf,0,20); &#125;&#125;"}]