[{"title":"为什么我想建立自己的博客网站","path":"/2025/03/23/20250324/","content":"距离我上一次接触”博客”这个概念，已过去十余年。彼时新浪博客正风靡一时，我按照信息技术课本上的指导注册了人生第一个博客账号。如今那个网站似乎已停止维护，昔日的账号也早已遗忘在时光里。 这个博客诞生的动力 只是想找个能妥善存储文档的地方！！！ 既然如此，为何要大费周章搭建独立博客呢？ 前段时间遭遇的硬盘损坏事件，让我对本地存储彻底失去安全感。我开始将重要数据迁移至云端，然而国内主流网盘的免费存储空间实在有限（沟槽的bd），最终将目光投向Github——单个文件100MB上限、仓库容量5GB、不限仓库数量。 这个方案确实令人心动！！！ 我立即创建了若干仓库，将文档分门别类上传。然而使用过程中渐觉不足：单调的个人界面、不稳定的访问体验，以及强烈的个性化缺失感。 偶然间看到技术同行的个人博客——优雅的界面设计、清晰的文档分类、流畅的交互体验，着实令人向往。 灵光乍现：何不搭建自己的博客网站？既可系统化管理学习文档，又能自由定制视觉风格。虽说是临时起意，但这个想法一旦萌生便挥之不去。 从零开始的搭建历程对于毫无前端经验的新手而言，独立建站谈何容易。经过大量资料查阅，最终选择Hexo静态博客框架搭配Stellar主题。从环境配置到主题调试，历经整个通宵的摸索，这个博客的雏形终于初现。 内容与展望本博客主要存放个人学习笔记与技术心得，内容难免存在纰漏，恳请读者不吝指正！目前网站功能尚显单薄，计划后续逐步添加如下组件： 全局搜索功能 访客评论系统 内容交互式演示模块 技术探索永无止境，让我们共同见证这个博客的成长轨迹。","tags":["博客"],"categories":["杂谈"]},{"title":"Robotics(EN)","path":"/notes/robotics.html","content":"Chap1. Spatial Descriptions and TransformationsSec 1.1 Descriptions: Positions, Orientations and Frames Descriptions of a position \\mathbf{^A P} = \\begin{bmatrix} P_x \\\\ P_y \\\\ P_z \\end{bmatrix}Position is represented in a column vector $(n \\times 1)$ Description of an orientation Rotation matrix {}^A_BR = \\left[ {}^A\\widehat{X}_B \\quad {}^A\\widehat{Y}_B \\quad {}^A\\widehat{Z}_B \\right] Properties Transpose of rotation matrix describing $ \\{A\\} $ relative to $\\{ B\\} $ equals to the matrix describing $ \\{ B \\} $ relative to $ \\{ A \\} $ : {}^A_BR = {}^B_AR^T Rotation matrix describing a rectangular coordinate system $\\{A \\} $ relative to another is orthogonal: {}^B_AR^{-1} = {}^B_AR^T Description of a frame A frame (coordinate system) can be described by a vector and a rotation matrix: \\{B\\} = \\{^A_BR, ^A\\mathbf{P}_{BORG}\\} Attention ${}^A_BR(x, \\alpha)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s x-axis by $\\alpha$ degrees ${}^A_BR(y, \\beta)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s y-axis by $\\beta$ degrees ${}^A_BR(z, \\gamma)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s z-axis by $\\gamma$ degrees Rotation Matrices: {}^A_BR(x, \\alpha) = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{bmatrix} {}^A_BR(y, \\beta) = \\begin{bmatrix} \\cos\\beta & 0 & \\sin\\beta \\\\ 0 & 1 & 0 \\\\ -\\sin\\beta & 0 & \\cos\\beta \\end{bmatrix} {}^A_BR(z, \\gamma) = \\begin{bmatrix} \\cos\\gamma & -\\sin\\gamma & 0 \\\\ \\sin\\gamma & \\cos\\gamma & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} Sec 1.2 MappingsMapping changes the description of a point from one frame to another. Mappings involving translated frames If $\\{A\\}$ and $\\{B\\}$ have the same orientation but differ by translation ${}^AP_{BORG}$: ^AP = ^BP + ^AP_{BORG}$$ Mappings involving rotated frames If $\\{A\\}$ and $\\{B\\}$ share the same origin but differ by rotation ${}^A_BR$: {}^AP = {}^A_BR \\, {}^BP Mapings involving general frames For frames differing by both translation and rotation: {}^AP = {}^A_BR \\, {}^BP + {}^AP_{BORG} Homogeneous Transform Matrix: {}^A_BT = \\begin{bmatrix} {}^A_BR & {}^A\\mathbf{P}_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_BT \\begin{bmatrix} {}^BP \\\\ 1 \\end{bmatrix} AttentionMapping describes the same point in different frames. Translation and rotation relate frames, not point positions. Sec 1.3 OperatorsOperators translate points, rotate vectors, or both. Translational operators Translating point $P_1$ by ${}^A\\mathbf{Q}$: {}^AP_2 = {}^AP_1 + {}^A\\mathbf{Q}Matrix form: D_Q = \\begin{bmatrix} 1 & 0 & 0 & q_x \\\\ 0 & 1 & 0 & q_y \\\\ 0 & 0 & 1 & q_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = D_Q \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix} Rotational operators Rotating vector ${}^AP_1$ by $R$: {}^AP_2 = R \\, {}^AP_1$R$ is equivalent to a rotation matrix ${}^A_BR$. Transformation operators Combining translation and rotation: \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = T \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix}where $T = \\begin{bmatrix} R &amp; \\mathbf{Q} \\\\ 0 &amp; 1 \\end{bmatrix}$. AttentionOperators act on vectors before transformation, while mappings describe vectors after transformation. Sec 1.4 Transformation Arithmetic Compound Transformation Problem: Transform ${}^CP$ to ${}^AP$ via intermediate frames: {}^A_CT = {}^A_BT {}^B_CT \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_CT \\begin{bmatrix} {}^CP \\\\ 1 \\end{bmatrix}Fixed reference frame transformations: {}^3_1T = {}^3_2T {}^2_1T Inverse transformation Method 1: ${}^B_AT = {}^A_BT^{-1}$ Method 2: {}^B_AT = \\begin{bmatrix} {}^A_BR^T & -{}^A_BR^T \\, {}^AP_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} Sec 1.5 More on Representation of Orientation X-Y-Z Fixed Angles Rotate $\\{B\\}$ about fixed axes of $\\{A\\}$ (order: X→Y→Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-X Euler Angles Rotate $\\{B\\}$ about its own axes (order: Z→Y→X): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-Z Euler Angles Rotate $\\{B\\}$ about its own axes (order: Z→Y→Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(z, \\gamma) Comparison Chap 2. Manipulator Kinematics"},{"path":"/notes/index.html","content":"写在前面面向期末的笔记，全英的。（课是全英的课"},{"title":"KEY","path":"/wiki/lanqiao/KEY.html","content":"嵌入式按键使用按键状态机，在用户区新建Key_State.c和Key_State.h文件。在Key_State.h中，写下 123456789101112131415161718192021222324252627#ifndef __KEY_STATE_H_#define __KEY_STATE_H_#include &quot;main.h&quot;/** * @brief 按键状态结构体 */struct keys&#123; uint8_t judge_state; // 状态机标志，0： 检测到一个低电平；1：确实被按下；2：等待抬起 uint8_t key_state; // 按键是否被按下（信号来自GPIO输入） uint8_t key_isPressed; // 按键短按标志位 uint8_t key_long_flag; // 按键长按标志位 uint32_t key_time; // 按键计时 uint32_t key_double_click_time; // 双击计时器 uint8_t key_double_click_EN; // 双击计时器使能 uint8_t key_double_click_flag; // 双击标志位&#125;;extern struct keys key[];void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);#endif keys结构体即为按键状态机，使用定时中断函数进行按键消抖。 Key_State.c内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;Key_State.h&quot;struct keys key[4] = &#123;0, 0, 0, 0&#125;;/** * @brief TIM定时器定时中断回调函数 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM3) &#123; key[0].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); key[1].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1); key[2].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2); key[3].key_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); for (uint8_t i = 0; i &lt; 4; i ++) &#123; if (key[i].key_double_click_EN == 1) // 计数器使能开启时，计时并判断 &#123; key[i].key_double_click_time ++; if (key[i].key_double_click_time &gt; 35) // 如果超时，则说明是短按，置标志位后关闭计数器使能 &#123; key[i].key_isPressed = 1; key[i].key_double_click_EN = 0; &#125; &#125; switch (key[i].judge_state) &#123; case 0: if (key[i].key_state == 0) // 如果刚开始检测到一个低电平 &#123; key[i].key_time = 0; // 时间计数清0 key[i].judge_state = 1; &#125; break; case 1: if (key[i].key_state == 0) // 如果10ms后依然检测到这个按键是低电平，就说明这个按键确实被按下了 &#123; key[i].judge_state = 2; &#125; else &#123; key[i].judge_state = 0; &#125; break; case 2: if (key[i].key_state == 1 &amp;&amp; key[i].key_time &lt;= 70) // 如果是一次短按 &#123; key[i].judge_state = 0; if (key[i].key_double_click_EN == 0) // 如果是第一次按下 &#123; key[i].key_double_click_EN = 1; key[i].key_double_click_time = 0; &#125; else // 双击计时开启，说明这次短按还在双击计时的时间范围内 &#123; key[i].key_double_click_EN = 0; key[i].key_double_click_flag = 1; &#125; &#125; else if (key[i].key_state == 1 &amp;&amp; key[i].key_time &gt; 70) // 长按松开按键，则回到state0 &#123; key[i].judge_state = 0; &#125; else if (key[i].key_state == 0) // 如果按键没有松开，则持续计时 &#123; key[i].key_time ++; if (key[i].key_time &gt; 70) // 如果按键按下时间大于700ms &#123; key[i].key_long_flag = 1; &#125; &#125; break; default: break; &#125; &#125; &#125;&#125; 记住要在cubemx中设置10ms中断，其中PSC预分频是79（80-1），ARR重装预载是9999（10000-1）。"},{"title":"ADC","path":"/wiki/lanqiao/ADC.html","content":"嵌入式ADC在cubemx中选择PB12，PB15分别设置为ADC输出模式（ADC1_IN11和ADC2_IN15） 生成代码后，在adc.c文件中写单通道采样函数，需要在adc.h文件中声明 1234567double getADC(ADC_HandleTypeDef *pin)&#123; uint16_t adc; HAL_ADC_Start(pin); adc = HAL_ADC_GetValue(pin); return adc*3.3/4096;&#125; 在主函数中，用ACD_Proc()调用采样功能 12345678void ADC_Proc(void)&#123; char text[20]; adc_value1 = getADC(&amp;hadc1); adc_value2 = getADC(&amp;hadc2); sprintf(text,&quot;ADC1:%.2f,ADC2:%.2f&quot;,adc_value1,adc_value2); LCD_DisplayStringLine(Line4,(uint8_t *)text);&#125; 需要注意的是，记得在adc.c中使用校准函数对采样进行校准，否则采样最大值为3.25V 123456/* USER CODE BEGIN ADC1_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc1,ADC_SINGLE_ENDED);/* USER CODE END ADC1_Init 2 *//* USER CODE BEGIN ADC2_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);/* USER CODE END ADC2_Init 2 */"},{"title":"LCD","path":"/wiki/lanqiao/LCD.html","content":"嵌入式LCD根据原理图在cubemx配置引脚，初始化lcd。 1234LCD_Init();LCD_Clear(Black);//黑色清屏，不然LCD原本颜色还会残存LCD_SetBackColor(Black);//设置背景色为黑色LCD_SetTextColor(White);//设置前景色为白色 记住要在 MX_GPIO_Init() 之后，否则可能初始化失败。 在lcd屏上显示字符，可以使用 void LCD_DisplayStringLine(u8 Line, u8 *ptr) 例如，显示”Hello World“ 1LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); 或者，可以使用sprintf()函数，前提使用stdio的头文件 12345#include &quot;stdio.h&quot;sprintf(text,&quot; count: %d &quot;,count);LCD_DisplayStringLine(Line4, (uint8_t *)text); 考点1：实现界面切换。以下是一个按键界面切换的基本思路，通过按键来增加界面计数。注意不要将view和count定义成函数的局部变量，否则在每次加载这个函数的时候界面都是第一个界面，无法进行切换。 123456789101112131415161718192021222324252627282930313233343536373839// 全局变量uint8_t view = 0;uint8_t count = 0;void lcd_process(void)&#123; char text[30]; for(uint8_t i = 0;i &lt; 4; i++) &#123; if(key[0].key_isPressed == 1) &#123; view++; key[i].key_isPressed = 0; if(view ==3) &#123; view = 0; &#125; &#125; if(key[1].key_isPressed == 1) &#123; count++; key[1].key_isPressed = 0; &#125; &#125; if(view==0) &#123; LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); &#125; if(view==1) &#123; sprintf(text,&quot; count: %d &quot;,count); LCD_DisplayStringLine(Line4, (uint8_t *)text); &#125; if(view == 2) &#123; LCD_DisplayStringLine(Line4,(unsigned char*)&quot; END &quot;); &#125;&#125; 考点2：文本高亮没啥技术含量，更改对应行的背景颜色和设置行切换标志。使用按键控制行标志位增减。与屏幕界面切换的思路一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243if(view == 1) &#123; char text2[30]; if(line_flag == 0) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; if(line_flag == 1) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; if(line_flag == 2) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; &#125; 注意，当两个界面所需要的行数不同时，比如，界面1只有一行字符串，界面2有三行字符串，需要给界面1增加三行空字符串，即 123456789if(view == 0) &#123; char text1[30]; sprintf(text1,&quot; Hello,world. &quot;); LCD_SetBackColor(Black); LCD_DisplayStringLine(Line4, (uint8_t *)text1); LCD_DisplayStringLine(Line5, (unsigned char *)&quot; &quot;); LCD_DisplayStringLine(Line6, (unsigned char *)&quot; &quot;); &#125; 否则会出现界面之间的字符串串在界面中。"},{"title":"IIC","path":"/wiki/lanqiao/IIC.html","content":"嵌入式IIC通信与EEPROM的读写I2C总线是一种双向二线制的同步串行总线，它只需要两根线即可在连接于总线上的器件之间传送信息。（SDA和SCL） 关键是读懂EEPROM的读写时序。 对照着时序图，我们可以写出与EEPROM进行读写数据的函数： 12345678910111213//写函数void e2prom_write(unsigned char address, unsigned char info)&#123; I2CStart(); //1.I2C起始信号(START) I2CSendByte(0xa0); //2.发送设备地址与“写”信号(DEVICE ADDRESS+WRITE)，将在下文解释 I2CWaitAck(); //3.IC2等待确认信号(ACK) I2CSendByte(address); //4.发送数据存储地址(WORD ADDRESS)（可以为0~255，对应256个） I2CWaitAck(); //5.I2C等待确认信号(ACK) I2CSendByte(info); //6.发送数据(DATA) I2CWaitAck(); //7.I2C等待确认信号(ACK) I2CStop(); //8.I2C结束信号(STOP)&#125; 12345678910111213141516171819202122//读函数unsigned char e2prom_read(unsigned char address)&#123; unsigned char val; I2CStart(); //1.I2C起始信号(START) I2CSendByte(0xa0); //2.发送设备地址与“写”信号(DEVICE ADDRESS+WR-TE)，将在下文解释 I2CWaitAck(); //3.IC2等待确认信号(ACK) I2CSendByte(address); //4.发送数据存储地址(WORD ADDRESS)（可以为0~255，对应256个） I2CWaitAck(); //5.I2C等待确认信号(ACK) I2CStop(); //下一次发送起始信号前先停止 I2CStart(); //6.I2C起始信号(START) I2CSendByte(0xa1); //7.发送设备地址与“读”信号(DEVICE ADDRESS+READ)，将在下文解释 I2CWaitAck(); //8.I2C等待确认信号(ACK) val = I2CReceiveByte(); //9.接收数据(DATA) I2CSendNotAck(); //10.I2C发送非确认信号(NO ACK) I2CStop(); //11.I2C结束信号(STOP) return (val);&#125; 注意，EEPROM每一个地址只能读取8位无符号数，16位或者32位需要进行分割 具体分割方式将在具体题目中进行解答。"},{"title":"LED","path":"/wiki/lanqiao/LED.html","content":"LED操作在cubemx中配置时钟和引脚，LED低电平有效 注意要打开PD2锁存器 基本写法： 123456void LED(uint8_t dsled)&#123; HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); //打开锁存器 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET); //灭掉所有的LED HAL_GPIO_WritePin(GPIOC, dsled&lt;&lt;8, GPIO_PIN_RESET); //选择特定的LED亮起&#125; 其中dsled是8位无符号数，0x_ _。 高位即为左边四个led，低位即为右边四个led。每一位取1即为该led亮。 LED交替闪烁和LED闪烁取反 ~ 左四位和右四位交替闪烁 取异或^该位led闪烁 1234567891011uint8_t ucLed=0x0f; //交替闪烁LED(~ucLed); //闪烁uint8_t ucLed2 = 0x0f;LED(ucLed2);HAL_Delay(1000);ucLed2^=0x0f; LED实现流水灯位运算左移和右移（&lt;&lt;和&gt;&gt;） Systick 滴答计时HAL_Delay()是阻塞赋值，可以使用Systick进行计时，Systick进行了已经设置了1ms的中断。 计时方式 12345678910111213141516171819202122232425262728293031//在文件：stm32g4xx_it.c中/* USER CODE BEGIN PV */extern uint32_t usled;/* USER CODE END PV */void SysTick_Handler(void)&#123;/* USER CODE BEGIN SysTick_IRQn 0 *//* USER CODE END SysTick_IRQn 0 */ HAL_IncTick();/* USER CODE BEGIN SysTick_IRQn 1 */ usled++;//实现usled每隔1ms自增1/* USER CODE END SysTick_IRQn 1 */&#125;//在文件main.c中/* USER CODE BEGIN PV */uint32_t usled;uint8_t ucled=0x01;/* USER CODE END PV *//* USER CODE BEGIN 3 */Led_Disp(ucled);if(usled&gt;=500)//500ms到&#123; usled=0;//重新计数 ucled^=0x01;//反转led1&#125;/* USER CODE END 3 */ 解决LED引脚冲突问题修改PD2引脚为低电平 将LED显示函数改成如下： 12345678910void Led_Disp(uint8_t ucled)&#123; HAL_GPIO_WritePin(GPIOC,0xFF&lt;&lt;8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC,ucled&lt;&lt;8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);&#125; 增加了重写PD2引脚高低电平的函数"},{"title":"RTC","path":"/wiki/lanqiao/RTC.html","content":"嵌入式RTCRTC实时时钟用来获取时间和日期 cubemx RTC配置 其中Calendar Time是当前时间，Calendar Date为当前日期 记住General中的异步分频（APV）是125，同步分频（SPV）是6000 接着，在keil中先配置时间结构体 1234/* USER CODE BEGIN PTD */RTC_TimeTypeDef time; //时间结构体RTC_DateTypeDef date; //日期结构体/* USER CODE END PTD */ 然后在主循环中进行实时计时： 12345678910111213 while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);sprintf(buf,&quot;Date:%2d-%2d-%2d &quot;,date.Year,date.Month,date.Date);LCD_DisplayStringLine(Line1,(uint8_t*)buf);sprintf(buf,&quot;Time:%2d-%2d-%2d &quot;,time.Hours,time.Minutes,time.Seconds);LCD_DisplayStringLine(Line2,(uint8_t*)buf); &#125; /* USER CODE END 3 */"},{"title":"TIM","path":"/wiki/lanqiao/TIM.html","content":"嵌入式TIM考点1：计算输出频率，占空比 关键概念： ARR：自动重装载值（AutoReloader Register） CCRx：捕获寄存器值 CNT：计数器值 PSC：预分频值（Prescaler） 当CNT小于CCRx时，计时器通道TIMx_CHx输出高电平，反之输出低电平 记住！！！ 频率 $=\\frac{\\text{CLK}}{(\\text{PSC+1})(\\text{ARR+1})}$ 占空比 $= \\frac{\\text{CRRx}}{\\text{ARR+1}}$ 公式中，CLK已经在创建工程时设置成了80MHz，而ARR和PSC可以在cubemx中设置，CCRx在程序中设置。 省赛题： 在cubemx中配置PA6和PA7引脚分别为TIMx_CHx通道。 按照下面的步骤修改寄存器的值： 12TIM3-&gt;ARR= //修改定时器3的ARR值，用于修改频率TIM3-&gt;CCRx= //修改定时器3通道x的CCR值，用于修改占空比 对于这题，在keil5中， 先初始化通道： 123456789//初始化HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1); //PA6HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1); //PA//根据寄存器中ARR的值配置频率PA6_frq=10000/(TIM3-&gt;ARR+1);PA7_frq=20000/(TIM17-&gt;ARR+1);//配置占空比，在cubemx ARR+1为100，CRR1的值正好就是对应的百分数TIM3-&gt;CCR1=PA6_duty; //PA6TIM17-&gt;CCR1=PA7_duty; //PA7 配置按键操作： 1234567891011121314if(key[1].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA6_duty+=10; if(PA6_duty==100) PA6_duty=10; TIM3-&gt;CCR1=PA6_duty; key[1].key_isPressed =0; &#125;if(key[2].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA7_duty+=10; if(PA7_duty==100) PA7_duty=10; TIM17-&gt;CCR1=PA7_duty; key[2].key_isPressed = 0; &#125; 配置LCD的显示： 123456789101112if(view == 0) &#123; char buf[20]; sprintf(buf,&quot;PA6_frq:%dHz&quot;,PA6_frq); LCD_DisplayStringLine(Line4,(uint8_t*)buf); sprintf(buf,&quot;PA7_frq:%dHz&quot;,PA7_frq); LCD_DisplayStringLine(Line5,(uint8_t*)buf); sprintf(buf,&quot;PA6_duty:%d%%&quot;,PA6_duty); LCD_DisplayStringLine(Line7,(uint8_t*)buf); sprintf(buf,&quot;PA7_duty:%d%%&quot;,PA7_duty); LCD_DisplayStringLine(Line8,(uint8_t*)buf); &#125; 考点2：输入捕获频率原理是调整信号发生器的频率，对应的分别是PA15和PB4，需要在cubemx中配置定时器输入捕获模式。 以TIM2_CH1为例，需要在cubemx中分别配置两个通道为direct 和 indirect。 记得打开NVIC中断使能 首先需要启动定时器： 1234HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_2); 接着，配置输入捕捉回调函数： 12345678910111213if(htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) &#123; tim2_val1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); /* 读取通道一，上升沿的值 一个完整的周期 */ tim2_val2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); /* 读取通道二，下降沿的值 一个周期中的高电平 */ __HAL_TIM_SetCounter(htim, 0);/* 清零定时器中的值，继续读取下一周期的脉冲 */ /* 捕获到的频率 = 时钟频率 / 预分频值 / 捕获的值（从0开始直到上升沿产生读的数值） */ tim2_freq = (80000000 / 80) / tim2_val1; /* 捕获的占空比 = 高电平的时间 / 低电平的时间 * 100 */ tim2_duty = ((float)tim2_val2 / tim2_val1) * 100; HAL_TIM_IC_Start(htim, TIM_CHANNEL_1); HAL_TIM_IC_Start(htim, TIM_CHANNEL_1); &#125; 这里写了TIM2的频率捕获部分，对于TIM3，是一样的。 接下来只需要在LCD中输入显示即可。"},{"title":"USART","path":"/wiki/lanqiao/USART.html","content":"嵌入式USART先在cubemx配置USART中断，调试时配合串口调试助手。 注意字符串操作要使用string库 考点1：串口发送例如，向上位机发送Hello World! 1234567891011121314151617char tx_buf[20]; //字符缓存区uint8_t rx_data; sprintf(tx_buf,&quot;Hello World!\\r &quot;);HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50);HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)/* * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be sent. * @param Timeout Timeout duration. * @retval HAL status*/ 考点2：串口接收串口接收函数在HAL库中的定义 1234567891011/** * @brief Recive an amount of data in interrupt mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the received data is handled as a set of u16. In this case, Size must indicate the number * of u16 available through pData. * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be received. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 进行串口接收时，我们要编写串口中断函数，函数名和形参不能改，函数本身是空内容，和TIM中断函数一致 1void HAL_UART_RxCpltCallback(UART_HandleTypedef *huart) 串口接收又分为几种，首先是单字符接收，例如，接收不同的单字符来对LED1进行控制： 12345678910111213141516171819202122void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(rx_data==&#x27;O&#x27;) &#123; ucled=0x01; sprintf(tx_buf,&quot;LED1 Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else if(rx_data==&#x27;C&#x27;) &#123; ucled=0x00; sprintf(tx_buf,&quot;LED1 Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else &#123; sprintf(tx_buf,&quot;Error!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); Led_Disp(ucled);&#125; 要提前打开接收中断 123/* USER CODE BEGIN 2 */HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); //打开接收中断/* USER CODE END 2 */ 只要接收中断就会进入串口中断函数 再例如，接收多字符进行LED控制： 12345678910111213141516171819202122232425262728void Usart_Proc(void)&#123; if(rx_count==4) &#123; if(strcmp(rx_buf,&quot;LEDO&quot;)==0) &#123; ucled=0x01; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; if(strcmp(rx_buf,&quot;LEDC&quot;)==0) &#123; ucled=0x00; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; rx_count=0; memset(rx_buf,0,20); //将缓存清空 &#125; &#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; rx_buf[rx_count++]=rx_data; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1);&#125; 在主函数主循环中使用Usart_Proc()函数，同样的，在接收上位机发送的信息后会进入串口中断函数，同样的，要提前打开接收中断。 考点3：sscanf()函数解析字符串12345678int sscanf(const char* str, const char* format, ...);/*参数：str：要解析的输入字符串。format：格式字符串，指定要匹配的格式规则。...：可变参数列表，用于接收解析后的数据。*/ 例如，省赛中解析车牌字符串： 123456789101112131415void Usart_Proc(void)&#123; if(rx_count==22) &#123; sscanf(rx_buf,&quot;%4s:%4s:%12s&quot;,car_type,car_num,car_time); sprintf(tx_buf,&quot;car_type:%4s\\r &quot;,car_type); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_num:%4s\\r &quot;,car_num); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_time:%4s\\r &quot;,car_time); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); rx_count=0; memset(rx_buf,0,20); &#125;&#125;"}]