[{"title":"如何使用LaTex写文章？","path":"/2025/03/25/20250325/","content":"前言 个人不是特别推荐使用vscode或者Texstudio去搭建Latex书写环境。使用 overleaf在线编辑 是一个不错的选择，虽然有时候编译的时间会比较慢。 什么是 LaTeX？LaTeX 是基于 TeX 语法体系的排版工具，通过代码实现内容与样式的分离式写作。 相较于Word，我更为青睐LaTeX的主要原因在于其卓越的排版表现，尤其在数学公式处理方面优势显著。尽管Word可通过MathType等插件实现公式编辑，但LaTeX凭借其原生支持的公式排版系统，在数学符号的精确定位、公式结构的专业呈现以及整体视觉协调性方面始终保持着明显优势。这种由代码驱动的排版机制，使得最终输出的文档在学术严谨性和版式美观度上都更胜一筹。 本文将以日常实践为例，分享 LaTeX 的常用指令与排版技巧。 开始如何开始你的LaTex写作之旅？ 首先先确定你的文章类型。这是至关重要的基础工作，不同文档类型对应不同的排版规范。我比较喜欢去使用大佬们配置好的写作模板，能大大节省我去设置写作环境（例如字体，行间距等）的时间。当然如果你是第一次使用别人的模板的话，我建议认真去看模板项目的README文件。 那么接下来就正式开始你的写作环节了！ 打开Overleaf官方网站，注册账号，登录，创建新项目，就可以去创建LaTex项目了。 语法环境在项目主文件.tex中，我们的文章内容都会包含在： 123\\begin&#123;document&#125;\\end&#123;document&#125; 一般来说，\\begin&#123;document&#125;前面还会设置文档属性以及会用到的宏包。 宏包是用来扩展/增强LaTeX的功能，宏包与LaTeX的关系和浏览器插件与浏览器的关系类似，通过安装不同的宏包可以实现一些复杂排版功能，例如插入复杂的列表表格、插入公式和特殊符号、插入代码、设置文档版式等。 使用\\usepackage&#123;&#125;来添加你想要的宏包。常见的宏包有: 123456789101112131415161718192021\\usepackage&#123;graphicx&#125; %这个宏包引入了插图命令 \\includegraphics，我们的文档如果需要插图都将用到它。\\usepackage&#123;amsmath&#125;\\usepackage&#123;mathtools&#125;%这是两个常见的数学扩展包,提供更多的数学符号等\\usepackage&#123;geometry&#125;%修改页面尺寸、页边距、页眉页脚等参数\\usepackage&#123;float&#125;%为浮动体提供不浮动的 H 模式；提供自定义浮动体结构的功能\\usepackage&#123;tikz&#125;%tikz绘图神器,可以用于绘制一些流程图等\\usepackage&#123;ctex&#125;%面向中文的排版框架，如果文章内容为中文请添加该宏包。\\usepackage&#123;cite&#125;%交叉引用的宏包 除了宏包指令以及一些文档配置指令外，剩下我们所有的内容都需要在\\begin&#123;document&#125;和\\end&#123;document&#125;中。 由于Latex不支持中文，需要使用ctex宏包。还需要在左上角的菜单中将编译方式改成XeLaTex。 标题设置LaTex可以设置不同级别的标题，基本的格式为 123\\section&#123;一级标题&#125;\\subsection&#123;二级标题&#125;\\subsubsection&#123;三级标题&#125; Latex最多支持七级结构：part、chapter、section、subsection、subsubsection、paragraph、subparagraph。 我们一般使用上面列出的三种结构。如果需要生成目录，在第一个标题前使用\\tebleofcontents即可生成目录。 有序列表和无序列表使用\\begin&#123;enumerate&#125;创建有序列表 1234\\begin&#123;enumerate&#125; \\item 你的内容1 \\item 你的内容2\\end&#123;enumerate&#125; 使用\\begin&#123;itemize&#125;创建无序列表 1234\\begin&#123;itemize&#125; \\item 你的内容1 \\item 你的内容2\\end&#123;itemize&#125; 正文分段一般来说，LaTeX默认的第一段不是首行缩进的, 这不符合我们的中文习惯。要实现首行缩进也很简单。请使用\\setlength&#123;\\parindent&#125;&#123;2em&#125; 设置全局首行缩进两个字符（需要使用宏包\\usepackage&#123;indentfirst&#125;）。 如果需要取消某个段落的首行缩进，请在该段落前使用 oindent。如果需要全局取消首行缩进，请使用\\setlength&#123;\\parindent&#125;&#123;0pt&#125; LaTex是如何区分段落的呢？只需要在两段文字之间增加一行空白段落即可！例如 12345\\begin&#123;document&#125; 这是一段文字。 这是另一段文字。\\end&#123;document&#125; 图片添加使用\\usepackage&#123;graphicx&#125;宏包后，就可以在LaTex正文添加图片了。基本的语法规则为： 123456\\begin&#123;figure&#125;[htbp] \\centering \\includegraphics[scale=0.2]&#123;example.png&#125; \\caption&#123;figure title&#125; \\label&#123;figure&#125;\\end&#123;figure&#125; 解释： \\begin&#123;figure&#125;和\\end&#123;figure&#125;是固定的用法，用于插入图片。 \\centering表示将图片置中。 \\caption&#123;图片标题&#125;用来设置图片标题 \\label&#123;标签&#125;用来设置标签，可以让图片在正文中被引用。使用\\cite&#123;label&#125;指令在正文中生成引用角标。 记得要将添加的图片添加到项目文件夹内，可以新建一个文件夹用来存放图片，也可以将图片和.tex文件放在同目录内。\\includegraphics[]&#123;&#125;的第二个参数就是图片的文件地址。 图片的位置也可以通过参数控制。\\begin&#123;figure&#125;[htbp]中的htbp就可以控制图片位置。具体意义如下： h：表示当前位置（here），也就是说图片将放在你设置的当前位置，但是如果这一页的空间不足以放下这个图片，此时图片会转到下一页； t：顶端（top），此时优先将图片放置在页面的顶部； b：底部（bottom）此时优先将图片放置在页面底部； p：将图片设置为浮动状态，系统会自动排版图片的位置。 表格添加首先，绘制一张表格需要创建table 和 tabular 环境。在文章开头还需要加上宏包\\usepackage&#123;array&#125;。一个简单的表格绘制代码如下所示： 12345678910111213\\begin&#123;table&#125;[!htp] \\centering \\caption&#123;Start with a simple form&#125; \\label&#123;one&#125; \\begin&#123;tabular&#125;&#123;l|c|r&#125; \\hline 1 &amp; 2 &amp; 3 \\\\ \\hline 01 &amp; 02 &amp; 03 \\\\ \\hline 001 &amp; 002 &amp; 003 \\\\ \\hline \\end&#123;tabular&#125; \\end&#123;table&#125; 效果： 表格的具体内容位于\\begin&#123;tabular&#125;和\\end&#123;tabular&#125; 之间，修改其中的内容就可以修改表格了。 &#123;l|c|r&#125;是来约定表格的每列属性的。用|分割和添加列 \\hline绘制一条横线用来分隔表格每一行 \\\\是换行标志 &amp;是列分隔符，用来区分没列的元素 所以一个基本的表格内容构造是由以上元素的构成。如果需要进行高阶操作例如单元格合并，后续会开一个专栏去讲解一些图片和表格的一些更高阶的操作。 数学公式我最欣赏LaTex的一点就是它的数学公式编辑功能了。如果你想在你的文字段落中添加数学公式，使用一个美元符号$来包含这个公式。 123\\begin&#123;document&#125; 这是你的内容，我们的数学公式是$y=x$。这是一个正比例函数。\\end&#123;document&#125; 效果为： 如果说，你想让你的数学公式另起一段，在新的一行添加需要的数学公式，请使用两个美元$$$$符号来包含这个公式。 1234\\begin&#123;document&#125; 这是你的内容，我们的数学公式是: $$y=2x$$\\end&#123;document&#125; 效果为： 或者，你需要用序号来编号你文章中的数学公式，使用\\begin&#123;equation&#125;和\\end&#123;equation&#125;，在这两段命令之间添加公式，注意不要使用美元符号了！ 123456\\begin&#123;document&#125; 这是你的内容，我们的数学公式是: \\begin&#123;equation&#125; y=3x \\end&#123;equation&#125;\\end&#123;document&#125; 数学公式内容的编写也有相应的语法，下面给大家列一些常见的符号，更多的可以使用Latex公式编辑器去编辑公式。 描述 语法 效果 分数 \\frac&#123;a&#125;&#123;b&#125; $\\frac{a}{b}$ 点乘 A \\Cdot B $A\\cdot B$ 叉乘 A \\times B $A \\times B$ 下标 A_&#123;b&#125; $A_{b}$ 上标 A^&#123;b&#125; $A^{b}$ 三角函数 \\sin a \\cos a \\tan a $\\sin a\\cos a\\tan a$ 根号 \\sqrt&#123;A&#125; $\\sqrt{A}$ 向量 \\overrightarrow&#123;a&#125; $\\overrightarrow{a}$ 积分 \\int_&#123;a&#125;^&#123;b&#125; $\\int_{a}^{b}$ 微分 \\frac&#123;\\mathrm&#123;d&#125; y&#125;&#123;\\mathrm&#123;d&#125; x&#125; $\\frac{\\mathrm{d} y}{\\mathrm{d} x}$ 参考文献在进行学术相关的创作时，我们需要添加必要的参考文献。这部分我们将介绍如何使用BibTex添加你需要的参考文献。 什么是BibTex？BibTeX 是最为流行的参考文献数据组织格式之一。BibTeX 使用数据库的的方式来管理参考文献. BibTeX 文件的后缀名为 .bib。.bib文件中参考文献的基本格式为： 123456789@article&#123;name1,author = &#123;作者, 多个作者用 and 连接&#125;,title = &#123;标题&#125;,journal = &#123;期刊名&#125;,volume = &#123;卷20&#125;,number = &#123;页码&#125;,year = &#123;年份&#125;,abstract = &#123;摘要, 这个主要是引用的时候自己参考的, 这一行不是必须的&#125;&#125; 解释： @article 是文献类型，还有其它格式, 例如 article, book, booklet, conference, inbook, incollection, inproceedings，manual, misc, mastersthesis, phdthesis, proceedings, techreport, unpublished 等等。使用大括号{}来包含文献的属性。 name1是这篇文章的名称标签，在正文中引用时会用到。例如引用时，使用\\cite&#123;name1&#125;指令。 一般情况下，我们需要自己去创建自己的bib文件。在overleaf的项目界面中，在左上角的新建文件去创建新文件，要将文件的后缀改成.bib。 大多时候，我们不需要自己去手写BibTex文献内容，我们可以在谷歌学术中找到需要文献的BibTex。 打开谷歌学术)（需要科学上网，可以自行搜索一些镜像网站），搜索文献标题或者关键词，例如，对于这篇文献，选择“引用” 再选择“BibTex”： 将出现的内容复制的你的bib文件中，就成功构建你的文献数据库了。 在创建完bib文件后，在\\begin&#123;document&#125;中，我们在正文的最后使用一些指令： 12\\bibliographystyle&#123;plain&#125;\\bibliography&#123;ref&#125; 其中\\bibliographystyle&#123;plain&#125;表示参考文献的类型。一般来说，plain样式基本就满足了大部分要求。Bibtex 参考文献样式_bibtex style-CSDN博客介绍了一些参考文件样式以及对应的效果。 \\bibliography&#123;ref&#125;表示了参考文献数据库来源。“ref”是你的bib文件名。你可以设置不同的bib文件名。 需要在你的正文中使用\\cite&#123;&#125;指令。如果一个文章中没有\\cite 命令，BibTex 就不知道哪一个bibliography是需要插入的。所以必须在你文章引用的地方加入\\cite。 结语Latex的基础教程到这里就差不多结束了，后续会将一些高阶的LaTe使用方法更新到LaTex学习专栏里，敬请期待！","tags":["LaTex"],"categories":["学习"]},{"title":"为什么我想建立自己的博客网站","path":"/2025/03/23/20250324/","content":"距离我上一次接触”博客”这个概念，已过去十余年。彼时新浪博客正风靡一时，我按照信息技术课本上的指导注册了人生第一个博客账号。如今那个网站似乎已停止维护，昔日的账号也早已遗忘在时光里。 这个博客诞生的动力 本质上是一种记录生活的方式！ 如今人们记录生活的方式层出不穷，主流社交平台几乎都具备分享与记录的功能。但对我而言，这些平台始终缺少某种难以言喻的归属感。 偶然间在互联网上看到技术大佬的个人博客——优雅的界面设计、清晰的文档分类、流畅的交互体验，还有着他们独特的生活感悟。着实令人心向往之。 那何不搭建自己的博客网站？虽说是临时起意，但这个想法一旦萌生便挥之不去。 从零开始的搭建历程对于毫无前端经验的新手而言，独立建站谈何容易。经过大量资料查阅，最终选择Hexo静态博客框架搭配Stellar主题。从环境配置到主题调试，历经整个通宵的摸索，这个博客的雏形终于初现。 内容与展望本博客主要存放个人学习笔记与技术心得，内容难免存在纰漏，恳请读者不吝指正！目前网站功能尚显单薄，计划后续逐步添加如下组件： 全局搜索功能 访客评论系统 内容交互式演示模块 技术探索永无止境，让我们共同见证这个博客的成长轨迹。","tags":["博客"],"categories":["杂谈"]},{"title":"ME Control(EN)","path":"/notes/autocontrol.html","content":"Chap 1 IntroductionSec 1.1 Basic Concepts of Control DefinitionAutomatic control refers to the use of additional equipment or devices to make the machine, equipment, or production process automatically operate in accordance with the predetermined rule under a certain working state or parameter without the participation of anyone. An outstanding feature of automatic control systems is that the process of system automatic control is the process of information transmission and transformation. Sec 1.2 Feedback Control System DefinitionIf the output of the system is not brought back to affect the control part of the system, such a system is called an open-loop control system. DefinitionIf the output of the system acts on the control part through the feedback, forming a closed loop, such a system is called a closed-loop control system, also known as a Feedback Control System. Passive Feedback: It mainly acts on the control system through the difference between input and output. Positive Feedback: It boosts the input signal to make the system deviate from its original state. Sec 1.3 Control System Block Diagram A control system consists of the controlled plant and the control device. Several representations in block diagram: Sec 1.4 The Design Requirements Stability: Preconditions for normal operation of the control system. Rapidity: Dynamic performance, with indicators. Accuracy: The steady-state (after the transition) value should be as consistent as possible with the expected value. Chap2 Mathematical Model of Control System DefinitionA mathematical model is an expression that indicates the dynamic relationship between physical quantities (or variables) in a system. Sec 2.1 Differential Equation of Linear SystemLinear systems can apply the superposition principle, i.e., they have superposition and uniformity (homogeneity). General ExpressionThe mathematical equation of the linear system is: a_n \\frac{d^n c(t)}{dt^n} + a_{n-1} \\frac{d^{n-1} c(t)}{dt^{n-1}} + \\cdots + a_1 \\frac{dc(t)}{dt} + a_0 c(t) = b_m \\frac{d^m r(t)}{dt^m} + b_{m-1} \\frac{d^{m-1} r(t)}{dt^{m-1}} + \\cdots + b_1 \\frac{dr(t)}{dt} + b_0 r(t) Sec 2.2 Laplace Transform DefinitionA function $f(t)$ (original) defined in the interval $[0,\\infty]$, its Laplace transform $F(s)$ is defined as \\mathcal{L} [f(t)] = F(s) = \\int_{0}^{\\infty} f(t) e^{-st} dt The table below gives the Laplace Transform of some typical test waveforms: Item $f(t)$ $F(s)$ Impulse response $\\delta(t)$ $1$ Step response $u(t)$ $\\frac{1}{s}$ Ramp response $t u(t)$ $\\frac{1}{s^2}$ Polynomial response $t^n u(t)$ $\\frac{n!}{s^{n+1}}$ Exponential response $e^{-at} u(t)$ $\\frac{1}{s+a}$ Sinusoid response $\\sin \\omega t u(t)$ $\\frac{\\omega}{s^2 + \\omega^2}$ Cosine response $\\cos \\omega t u(t)$ $\\frac{s}{s^2 + \\omega^2}$ Theorem Linear:$L[af_1(t) \\pm bf_2(t)] = aF_1(s) \\pm bF_2(s)$ Differential:$L[f^{(n)}(t)] = s^n \\cdot F(s)$ Integral:$L\\left[\\int \\int f(t) dt\\right] = \\frac{1}{s^n} F(s)$ Real displacement:$L[f(t - \\tau_0)] = e^{-\\tau_0 s} \\cdot F(s)$ Complex displacement:$L[e^{At}f(t)] = F(s - A)$ Initial value:$\\lim_{t \\to 0} f(t) = \\lim_{s \\to \\infty} s \\cdot F(s)$ Terminal value:$\\lim_{t \\to \\infty} f(t) = \\lim_{s \\to 0} s \\cdot F(s)$ DefinitionInverse Laplace Transform: f(t) = \\mathcal{L}^{-1}[F(s)] = \\frac{1}{2\\pi j} \\int_{\\sigma - j\\infty}^{\\sigma + j\\infty} F(s) e^{st} ds Sec 2.3 Transfer Function DefinitionUnder zero initial conditions, the transfer function is the ratio of the Laplace transform of the output to the input: G(s) = \\frac{C(s)}{R(s)} = \\frac{b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_1 s + b_0}{a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_1 s + a_0} Sec 2.3.1 Basic properties The transfer function is a rational and proper fraction of the complex variable. The transfer function does not indicate the system’s physical characteristics or structure. The transfer function is only used for single-input single-output systems. Without zero-pole cancellation, the denominator polynomial is the system’s characteristic polynomial. Sec 2.3.2 Common forms Rational form: G(s) = \\frac{b_m s^m + \\cdots + b_0}{a_n s^n + \\cdots + a_0} Zero-pole form: G(s) = K^* \\frac{(s - z_1)\\cdots(s - z_m)}{(s - p_1)\\cdots(s - p_n)} Time constant form: G(s) = K \\frac{\\prod (\\tau_i s + 1) \\prod (\\tau_k^2 s^2 + 2\\xi_e \\tau_k s + 1)}{\\prod (\\tau_j s + 1) \\prod (T_l^2 s^2 + 2\\xi_e T_l s + 1)} Sec 2.3.3 Typical links Link Differential Equation Transfer Function Proportional $c = Kr$ $K$ First-order inertia $T\\dot{c} + c = r$ $\\frac{1}{Ts + 1}$ Second-order oscillation $T^2\\ddot{c} + 2\\xi T\\dot{c} + c = r$ $\\frac{1}{T^2s^2 + 2\\xi Ts + 1}$ Integral $\\dot{c} = r$ $\\frac{1}{s}$ Ideal differential $c = \\dot{r}$ $s$ Sec 2.4 Block Diagram of a System DefinitionA graphical representation of the signal transmission relationships between system components. The transfer function can be derived from the block diagram. Sec 2.4.1 Equivalent transformation rules Series blocks: Parallel blocks: Feedback connection: Open-loop transfer function: G(s) = G_1(s)G_2(s)H(s)Closed-loop transfer function: \\Phi(s) = \\frac{G(s)}{1 \\mp G_o(s)} For input signal (disturbance = 0): \\Phi(s) = \\frac{C(s)}{R(s)} = \\frac{G_1(s) G_2(s)}{1 + G_1(s) G_2(s) H(s)} For disturbance signal (input = 0): \\Phi_n(s) = \\frac{C(s)}{N(s)} = \\frac{G_2(s)}{1 + G_1(s)G_2(s)H(s)} Total output: C(s) = \\Phi(s)R(s) + \\Phi_n(s)N(s)= \\frac{1}{1 + G_1(s)G_2(s)H(s)} [G_1(s)G_2(s)R(s) + G_2(s)N(s)] \\textbf{when} $|G(s)H(s)| \\gg 1$ \\Phi(s) = \\approx \\frac{C(s)}{R(s)} = \\frac{G(s)}{1 \\mp G(s)H(s)} \\approx \\frac{1}{\\mp H(s)} When $H(s) = 1$ \\Phi(s) = \\frac{C(s)}{R(s)} = \\frac{G(s)}{1 \\mp G(s)H(s)} = \\frac{G(s)}{1 \\mp G(s)} When $H(s) = 1$, it is called unit feedback Sec 2.4.2 Equivalent Transformation Rules Signal lead backward: Signal lead forward: Comparison backward: Comparison forward:"},{"title":"Digital Circuit(EN)","path":"/notes/dc.html","content":"这是一篇手写笔记，下面对应的PDF文件 目前存放在云端，这是云端链接 数电笔记。"},{"title":"Forehead","path":"/notes/index.html","content":"写在前面面向期末的笔记，全英的。（课是全英的课"},{"title":"Fundamentals of  Kalman Filter and Inertia Navigation(EN)","path":"/notes/kalman.html","content":"Basic Requirement Formulate an filtering problem. Build a state space model of a system. Solve linear state estimation problems with Kalman filter. Learn the principles of inertial navigation. Learn/implement basic INS-GNSS integrated navigation system. Lesson 1Why is Kalman filter so popular? Kalman filter is BULE (Best Linear Unbiased Estimator) Powerful Convenient to use Example1 - Measure the center temperature of a rocket flame Example2 - Data Merging Notation $e_{EST}$ —— state estimation error $e_{MEA}$ — measurement error $K$ — Kalman gain $X$ — true state $\\hat{X}$ — estimated state $y$ — measurement $K = \\frac{e_{EST}}{e_{EST} + e_{MEA}}$ $\\hat{X}_k = \\hat{X}_{k-1} + K(y - \\hat{y})$ $e_{EST} = (1 - K)e_{EST}$ Example3 - A simple 0-order Kalman filter $K = \\frac{E_{\\hat{X}}}{E_{\\hat{X}} + E_y}$ $\\hat{X}_t = \\hat{X}_{t-1} + K (y - \\hat{X}_{t-1})$ $E_{\\hat{X}_{t}} = (1 - K)E_{\\hat{X}_{t-1}}$ Lesson 2Numerical integration of differential equations Euler integration Consider a first-order differential equation of the form: \\dot{x} = f(x, t)We know from calculus that the definition of a derivative of a function can be approximated by \\dot{x} = f(x, t) = \\frac{x(t + h) - x(t)}{h} = \\frac{x_k - x_{k-1}}{h}for small $ h $ . Rearranging terms yields x_k = x_{k-1} + hf(x, t)The preceding equation is known as Euler integration. Second-order Runge–Kutta The second-order Runge–Kutta numerical integration procedure is easy to state. Given a first-order differential equation of the form: \\dot{x} = f(x, t)where $ t $ is time, we seek to find a recursive relationship for $ x $ as a function of time. With the second-order Runge–Kutta numerical technique the value of $ x $ at the next integration interval $ h $ is given by x_k = x_{k-1} + 0.5h[f(x, t) + f(x, t + h)]Finding the area under a curve using trapezoids is equivalent to second-order Runge–Kutta integration. Noise and random variables The mean squared value of $x$ is defined as: $E(x^2) = \\int_{-\\infty}^{\\infty} x^2 p(x) dx$ The root mean square or rms of $x$ is defined as: $rms = \\sqrt{E(x^2)}$ The variance of $x$ is defined as: $\\sigma^2 = E[x - E(x)]^2 = E(x^2) - E^2(x)$ If we have independent random variables $x_1, x_2 … x_n$ , then the variance of the sum can be shown to be the sum of the variances, $\\sigma^2 = \\sigma_1^2 + \\sigma_2^2 + \\cdots + \\sigma_n^2$ State space notationOften in this text we will put linear differential equations into state space form because this will be required for setting up a Kalman-filtering problem. With state-space notation we are saying that any set of linear differential equations can be put in the form of the first-order matrix differential equation \\dot{x} = Fx + Gu + w Example: Consider the second-order differential equation without any random inputs. \\ddot{y} + 2\\dot{y} + 3y = 4rewrite \\dot{y} = -2\\dot{y} - 3y + 4\\begin{bmatrix} \\dot{y} \\\\ \\dot{y} \\end{bmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -3 & -2 \\end{bmatrix} \\begin{bmatrix} y \\\\ \\dot{y} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 4 \\end{bmatrix}x = \\begin{bmatrix} y \\\\ \\dot{y} \\end{bmatrix}, F = \\begin{bmatrix} 0 & 1 \\\\ -3 & -2 \\end{bmatrix}, G = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, u = 4, w = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} Fundamental matrixIf the state-space form is: \\dot{x} = Fxwhere the systems dynamics matrix $F$ is time invariant, then we can say that there is a transition or fundamental matrix $\\Phi$ that can be used to exactly propagate the state forward from any time $t_0$ to time $t$ according to x(t) = \\Phi(t - t_0)x(t_0)Two simple ways of finding the fundamental matrix for time-invariant systems are by Laplace transforms and by Taylor-series expansion: Laplace transform technique: $\\Phi(t) = \\mathcal{L}^{-1} [(sI - F)^{-1}]$ Taylor-series expansion: $\\Phi(t) = e^{Ft} = I + Ft + \\frac{(Ft)^2}{2}{2!} + \\cdots + \\frac{(Ft)^n}{n!} + \\cdots$ Lesson 3Least squares methodWe will normally follow a three-step procedure for extracting information or estimating the characteristics of the signal based upon noisy measurement Assume a polynomial model to represent the actual signal. Try to estimate the coefficients of the selected polynomial by choosing a goodness of fit criterion. This is where Gauss comes in. The least squares criterion is the sum of the squares of the individual discrepancies between the estimated polynomial and measurement values of the actual signal contaminated by noise. Use calculus to minimize the sum of the squares of the individual discrepancies in order to obtain the best coefficients for the selected polynomial. Zero order of one-state filter For the zeroth-order case in which the best estimate is supposed to be a constant $a_0$: \\hat{x}_k = a_0Suppose we sample $n$ measurements $x^*_k$ of the data every $T_s$ seconds (i.e., $k$ goes from $1$ to $n$). R = \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = \\sum_{k = 1}^{n}(a_0 - x^*_k)^2where $R$ is the square of the summation of all the residuals or differences between the estimate and the measurement. Because we are only estimating one constant, this is also sometimes called a one-state system. From calculus we know that a function can be minimized by taking its derivative and setting the result equal to zero. R = \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = (a_0 - x^*_1)^2 + (a_0 - x^*_2)^2 + \\cdots + (a_0 - x^*_n)^2To minimize $R$ \\frac{\\partial R}{\\partial a_0} = 0 = 2(a_0 - x^*_1) + 2(a_0 - x^*_2) + \\cdots 2(a_0 - x^*_n)-x^*_1 - x^*_2 - \\cdots - x^*_n = -\\sum_{k = 1}^{n}x^*_k, \\quad a_0 + a_0 + \\cdots + a_0 = na_00 = na_0 - \\sum_{k = 1}^{n}x^*_ka_0 = \\frac{\\sum_{k = 1}^{n}x^*_k}{n}The preceding formula shows us that the best constant fit to a set of measurement data in the least squares sense is simply the average value of the measurements. First order or two-state filterSuppose we want to fit the measurement data with the best straight line (i.e., rather than a constant) in the least squares sense. This means we are seeking estimates to fit the first-order polynomial \\hat{x} = a_0 + a_1t, \\quad \\hat{\\dot{x}} = a_1in discrete notation \\hat{x}_k = a_0 + a_1(k - 1)T_s, \\quad \\hat{\\dot{x}}_k = a_1where $k$ is the number of measurements taken and $T_s$ is the sampling time. As before, the quantity to be minimized is still given by the summation of the square of the difference between the estimates and measurements or \\begin{align*} R =& \\sum_{k = 1}^{n}(\\hat{x}_k - x^*_k)^2 = \\sum_{k = 1}^{n}[a_0 + a_1(k - 1)T_s - x^*_k]^2 \\\\ =& (a_0 - x^*_1)^2 + (a_0 + a_1T_s - x^*_2)^2 + \\cdots + [a_0 + a_1(n - 1)T_s - x^*_n]^2 \\end{align*}Again, according to calculus, we can minimize $R$ by setting its derivative with respect to $a_0$ and $a_1$ to zero or \\begin{align*} \\frac{\\partial R}{\\partial a_0} &= 0 \\\\=& 2(a_0 - x^*_1) + 2(a_0 + a_1T_s - x^*_2) + \\cdots + 2[a_0 + a_1(n - 1)T_s - x^*_n] \\end{align*}\\begin{align*} \\frac{\\partial R}{\\partial a_1} &= 0\\\\ =& 2(a_0 + a_1T_s - x^*_2)T_s + \\cdots + 2(n - 1)T_s[a_0 + a_1(n - 1)T_s - x^*_n] \\end{align*}Simplify: na_0 + a_1\\sum_{k = 1}^{n}(k - 1)T_s = \\sum_{k = 1}^{n}x^*_ka_0\\sum_{k = 1}^{n}(k - 1)T_s + a_1\\sum_{k = 1}^{n}[(k - 1)T_s]^2 = \\sum_{k = 1}^{n}(k - 1)T_sx^*_kmatrix form: \\begin{bmatrix} n & \\sum_{k = 1}^{n}(k - 1)T_s \\\\ \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\end{bmatrix} = \\begin{bmatrix} \\sum_{k = 1}^{n}x^*_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^*_k \\end{bmatrix} Lesson 4Second order LS filter*Second order polynomial model \\hat{x} = a_0 + a_1t + a_2t^2 \\hat{\\dot{x}} = a_1 + 2a_2t \\hat{\\ddot{x}} = 2a_2Discrete form \\hat{x}_k = a_0 + a_1(k - 1)T_s + a_2[(k - 1)T_s]^2matrix form: \\begin{align*} & \\begin{bmatrix} n & \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\\\ \\sum_{k = 1}^{n}(k - 1)T_s & \\sum_{k = 1}^{n}[(k - 1)T_s]^2 & \\sum_{k = 1}^{n}[(k - 1)T_s]^3 \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2 & \\sum_{k = 1}^{n}[(k - 1)T_s]^3 & \\sum_{k = 1}^{n}[(k - 1)T_s]^4 \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{bmatrix} \\\\&= \\begin{bmatrix} \\sum_{k = 1}^{n}x^*_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^*_k \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2x^*_k \\end{bmatrix} \\end{align*} Third order LS filter*We can also fit the measurement data with the best cubic or third - order curve in the least squares sense. This means we are seeking estimates to fit the formula for the cubic \\hat{x} = a_0 + a_1t + a_2t^2 + a_3t^3or \\hat{x}_k = a_0 + a_1(k - 1)T_s + a_2[(k - 1)T_s]^2 + a_3[(k - 1)T_s]^3 Lesson 5Least-squares coefficients for different order polynomial fits to measurement data Order Equations Zeroth $a_0 = \\frac{\\sum_{k = 1}^{n}x^*_k}{n}$ First $\\begin{bmatrix}a_0 \\\\ a_1\\end{bmatrix} = \\begin{bmatrix}n &amp; \\sum_{k = 1}^{n}(k - 1)T_s \\\\ \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2\\end{bmatrix}^{-1}\\begin{bmatrix}\\sum_{k = 1}^{n}x^_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^_k\\end{bmatrix}$ Second $\\begin{bmatrix}a_0 \\\\ a_1 \\\\ a_2\\end{bmatrix} = \\begin{bmatrix}n &amp; \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2 \\\\ \\sum_{k = 1}^{n}(k - 1)T_s &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^2 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^3 \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^3 &amp; \\sum_{k = 1}^{n}[(k - 1)T_s]^4\\end{bmatrix}^{-1}\\begin{bmatrix}\\sum_{k = 1}^{n}x^_k \\\\ \\sum_{k = 1}^{n}(k - 1)T_sx^_k \\\\ \\sum_{k = 1}^{n}[(k - 1)T_s]^2x^*_k\\end{bmatrix}$ Accelerometer testing exampleAccelerometer measurements are taken for different accelerometer orientation angles. where $\\theta_𝑘$ is the angle the accelerometer makes with the vertical for the $k$th measurement, $g$ is gravity. \\text{Theory} = g \\cos\\theta_kActually, the accelerometer output will also consist of additional terms caused by imperfections in the accelerometer. \\text{Output} = g \\cos\\theta_k + \\bm B + \\bm{SF}g \\cos\\theta_k + \\bm{K}(g \\cos\\theta_k)^2Therefore, the accelerometer error is simply the difference between the actual output and theory($\\theta_k$ is the actual angle and $\\theta^*_k$ is the measured angle): Error = Accelerometer Output – Theory = g\\cos\\theta_k + B + SF \\ g\\cos\\theta_k + K(g\\cos\\theta_k)^2 - g\\cos\\theta^*_kInitially, the simulation is set up so there is no noise on the angle $\\theta^*_k$. The error or measurement equation for the first example will be given by: \\theta^*_k = \\theta_k, \\quad x_k = g\\cos\\theta_k, \\quad y^*_k = B + SF \\ g\\cos\\theta_k + K(g\\cos\\theta_k)^2Let $x_k = g\\cos\\theta_k$ then $y^*_k = B + SFx_k + K(x_k)^2$ Term Scientific value English units Bias error $B$ $10 \\ \\mu g$ $1010^{-6}32.2 = 0.000322 \\ \\text{ft}/\\text{s}^2$ Scale factor error $SF$ $5 \\ \\text{ppm}$ $5*10^{-6}$ $g$-squared sensitive drift $K$ $1 \\ \\mu g/\\text{g}^2$ $110^{-6}/32.2 = 3.10610^{-8} \\ \\text{s}^2/\\text{ft}$ No angle noise 1 $\\bm{\\mu r}$ of angle noise on the vertical angle Making Least-Squares filter recursiveIf we were trying to fit a zeroth - order polynomial or constant to a set of measurement data the best estimate can be expressed as \\hat{x}_k = a_0 = \\frac{\\sum_{i = 1}^{k}x^*_i}{k}By changing subscripts we can rewrite the preceding expression as \\hat{x}_{k + 1} = \\frac{\\sum_{i = 1}^{k + 1}x^*_i}{k + 1} = \\frac{\\sum_{i = 1}^{k}x^*_i + x^*_{k + 1}}{k + 1}\\sum_{i = 1}^{k}x^*_i = k\\hat{x}_k\\hat{x}_{k + 1} = \\frac{k\\hat{x}_k + x^*_{k + 1}}{k + 1}\\begin{align*} \\hat{x}_{k + 1} = \\frac{k\\hat{x}_k + \\hat{x}_k + x^*_{k + 1} - \\hat{x}_k}{k + 1} \\\\= \\frac{(k + 1)\\hat{x}_k + x^*_{k + 1} - \\hat{x}_k}{k + 1} \\\\= \\hat{x}_k + \\frac{1}{k + 1}(x^*_{k + 1} - \\hat{x}_k) \\end{align*}Recursive properties of One-State filtersThe form of the zeroth - order or one - state recursive least - squares filter is given by \\hat{x}_k = \\hat{x}_{k - 1} + K_{1k}Res_kgain: $K_{1k} = \\frac{1}{k} \\quad k = 1,2,\\cdots,n$ residual: $Res_k = x^*_k - \\hat{x}_{k - 1}$ We can see that the filter gain for the zeroth - order recursive least - squares filter is unity for the first measurement (i.e., $k = 1$) and eventually goes to zero as more measurements are taken. The batch-processing least squares estimates are only available after all of the measurements are taken ,whereas the recursive least-squares estimates are available as the measurements are being taken. Recursive properties of One-State filtersIf the actual measurement data are simply a constant plus noise (i.e., zeroth - order signal plus noise) where the measurement noise is a zero - mean Gaussian process with variance $\\sigma^2_n$. x^*_k = x_k + v_k\\begin{align*} x_k - \\hat{x}_k =& x_k - \\hat{x}_{k - 1} - \\frac{1}{k}(x^*_k - \\hat{x}_{k - 1}) \\\\=& x_k - \\hat{x}_{k - 1} - \\frac{1}{k}(x_k + v_k - \\hat{x}_{k - 1}) \\end{align*}However, because the signal is a constant for the zeroth - order system, we can also say that $x_k = x_{k - 1}$ x_k - \\hat{x}_k = (x_{k - 1} - \\hat{x}_{k - 1})\\left(1 - \\frac{1}{k}\\right) - \\frac{1}{k}v_k\\begin{align*} (x_k - \\hat{x}_k)^2 =& (x_{k - 1} - \\hat{x}_{k - 1})^2\\left(1 - \\frac{1}{k}\\right)^2 \\\\-& 2\\left(1 - \\frac{1}{k}\\right)(x_{k - 1} - \\hat{x}_{k - 1})\\frac{v_k}{k} + \\left(\\frac{1}{k}v_k\\right)^2 \\end{align*}\\begin{align*} E[(x_k - \\hat{x}_k)^2] =& E[(x_{k - 1} - \\hat{x}_{k - 1})^2]\\left(1 - \\frac{1}{k}\\right)^2 \\\\-& 2\\left(1 - \\frac{1}{k}\\right)E[(x_{k - 1} - \\hat{x}_{k - 1})v_k]\\frac{1}{k} + E\\left[\\left(\\frac{1}{k}v_k\\right)^2\\right] \\end{align*}If we define the variance of the error in the estimate to be $P_k$ and the variance of the measurement noise to be $\\sigma^2_n$ and also assume that the noise is uncorrelated with the state or the estimate of the state, we can say that E[(x_k - \\hat{x}_k)^2] = P_kE[v^2_k] = \\sigma^2_nE[(x_{k - 1} - \\hat{x}_{k - 1})v_k] = 0Substitution of the preceding three equations into the expectation equation yields the difference equation for the variance of the error in the estimate or P_k = P_{k - 1}\\left(1 - \\frac{1}{k}\\right)^2 + \\frac{\\sigma^2_n}{k^2}P_1 = P_0\\left(1 - \\frac{1}{1}\\right)^2 + \\frac{\\sigma^2_n}{1^2} = \\sigma^2_nP_2 = P_1\\left(1 - \\frac{1}{2}\\right)^2 + \\frac{\\sigma^2_n}{2^2} = \\sigma^2_n\\frac{1}{4} + \\frac{\\sigma^2_n}{4} = \\frac{\\sigma^2_n}{2}P_3 = P_2\\left(1 - \\frac{1}{3}\\right)^2 + \\frac{\\sigma^2_n}{3^2} = \\frac{\\sigma^2_n}{2}\\frac{4}{9} + \\frac{\\sigma^2_n}{9} = \\frac{\\sigma^2_n}{3}P_4 = P_3\\left(1 - \\frac{1}{4}\\right)^2 + \\frac{\\sigma^2_n}{4^2} = \\frac{\\sigma^2_n}{3}\\frac{9}{16} + \\frac{\\sigma^2_n}{16} = \\frac{\\sigma^2_n}{4}The trend in the preceding four equations is now obvious, and we can summarize these results by saying in general for the zeroth - order recursive least - squares filter that the variance of the error in the estimate is simply P_k = \\frac{\\sigma^2_n}{k} If the real signal is a first - order: x_k = a_0 + a_1t = a_0 + a_1(k - 1)T_sAs we saw the filter will not be able to track the signal. The resulting error in the estimate is known as truncation error: \\varepsilon_k = x_k - \\hat{x}_kIn the noise - free case: \\begin{align*} \\hat{x}_k&=\\frac{\\sum_{i = 1}^{k}x_i}{k}=\\frac{\\sum_{i = 1}^{k}[a_0 + a_1(i - 1)T_s]}{k} \\\\&= \\frac{a_0\\sum_{i = 1}^{k}1 + a_1T_s\\sum_{i = 1}^{k}i - a_1T_s\\sum_{i = 1}^{k}1}{k}\\\\ &=\\frac{a_0k + a_1T_s[k(k + 1)/2] - a_1T_sk}{k}\\\\&=a_0+\\frac{a_1T_s}{2}(k - 1) \\end{align*}The truncation error of the zeroth - order recursive least - squares filter: \\begin{align*} \\varepsilon_k = x_k - \\hat{x}_k &= a_0 + a_1T_s(k - 1) - a_0 - \\frac{a_1T_s}{2}(k - 1)\\\\&=\\frac{a_1T_s}{2}(k - 1) \\end{align*}As already noted, as more measurements are taken k gets larger, and the error in the estimate caused by the measurement noise decreases while the error in the estimate caused by truncation error increases. In principle, for any particular numerical example there is an optimal value of k that will minimize the errors in the estimates caused by both measurement noise and truncation error. Lesson 6"},{"title":"Robotics(EN)","path":"/notes/robotics.html","content":"Chap1. Spatial Descriptions and TransformationsSec 1.1 Descriptions: Positions, Orientations and Frames Descriptions of a position \\mathbf{^A P} = \\begin{bmatrix} P_x \\\\ P_y \\\\ P_z \\end{bmatrix}Position is represented in a column vector $(n \\times 1)$ Description of an orientation Rotation matrix {}^A_BR = \\left[ {}^A\\widehat{X}_B \\quad {}^A\\widehat{Y}_B \\quad {}^A\\widehat{Z}_B \\right] Properties Transpose of rotation matrix describing $ \\{A\\} $ relative to $\\{ B\\} $ equals to the matrix describing $ \\{ B \\} $ relative to $ \\{ A \\} $ : {}^A_BR = {}^B_AR^T Rotation matrix describing a rectangular coordinate system $\\{A \\} $ relative to another is orthogonal: {}^B_AR^{-1} = {}^B_AR^T Description of a frame A frame (coordinate system) can be described by a vector and a rotation matrix: \\{B\\} = \\{^A_BR, ^A\\mathbf{P}_{BORG}\\} Attention ${}^A_BR(x, \\alpha)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s x-axis by $\\alpha$ degrees ${}^A_BR(y, \\beta)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s y-axis by $\\beta$ degrees ${}^A_BR(z, \\gamma)$: $\\{B\\}$ rotated counterclockwise about $\\{A\\}$’s z-axis by $\\gamma$ degrees Rotation Matrices: {}^A_BR(x, \\alpha) = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\alpha & -\\sin\\alpha \\\\ 0 & \\sin\\alpha & \\cos\\alpha \\end{bmatrix} {}^A_BR(y, \\beta) = \\begin{bmatrix} \\cos\\beta & 0 & \\sin\\beta \\\\ 0 & 1 & 0 \\\\ -\\sin\\beta & 0 & \\cos\\beta \\end{bmatrix} {}^A_BR(z, \\gamma) = \\begin{bmatrix} \\cos\\gamma & -\\sin\\gamma & 0 \\\\ \\sin\\gamma & \\cos\\gamma & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} Sec 1.2 MappingsMapping changes the description of a point from one frame to another. Mappings involving translated frames If $\\{A\\}$ and $\\{B\\}$ have the same orientation but differ by translation ${}^AP_{BORG}$: ^AP = ^BP + ^AP_{BORG}$$ Mappings involving rotated frames If $\\{A\\}$ and $\\{B\\}$ share the same origin but differ by rotation ${}^A_BR$: {}^AP = {}^A_BR \\, {}^BP Mapings involving general frames For frames differing by both translation and rotation: {}^AP = {}^A_BR \\, {}^BP + {}^AP_{BORG} Homogeneous Transform Matrix: {}^A_BT = \\begin{bmatrix} {}^A_BR & {}^A\\mathbf{P}_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_BT \\begin{bmatrix} {}^BP \\\\ 1 \\end{bmatrix} AttentionMapping describes the same point in different frames. Translation and rotation relate frames, not point positions. Sec 1.3 OperatorsOperators translate points, rotate vectors, or both. Translational operators Translating point $P_1$ by ${}^A\\mathbf{Q}$: {}^AP_2 = {}^AP_1 + {}^A\\mathbf{Q}Matrix form: D_Q = \\begin{bmatrix} 1 & 0 & 0 & q_x \\\\ 0 & 1 & 0 & q_y \\\\ 0 & 0 & 1 & q_z \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = D_Q \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix} Rotational operators Rotating vector ${}^AP_1$ by $R$: {}^AP_2 = R \\, {}^AP_1$R$ is equivalent to a rotation matrix ${}^A_BR$. Transformation operators Combining translation and rotation: \\begin{bmatrix} {}^AP_2 \\\\ 1 \\end{bmatrix} = T \\begin{bmatrix} {}^AP_1 \\\\ 1 \\end{bmatrix}where $T = \\begin{bmatrix} R &amp; \\mathbf{Q} \\\\ 0 &amp; 1 \\end{bmatrix}$. AttentionOperators act on vectors before transformation, while mappings describe vectors after transformation. Sec 1.4 Transformation Arithmetic Compound Transformation Problem: Transform ${}^CP$ to ${}^AP$ via intermediate frames: {}^A_CT = {}^A_BT {}^B_CT \\begin{bmatrix} {}^AP \\\\ 1 \\end{bmatrix} = {}^A_CT \\begin{bmatrix} {}^CP \\\\ 1 \\end{bmatrix}Fixed reference frame transformations: {}^3_1T = {}^3_2T {}^2_1T Inverse transformation Method 1: ${}^B_AT = {}^A_BT^{-1}$ Method 2: {}^B_AT = \\begin{bmatrix} {}^A_BR^T & -{}^A_BR^T \\, {}^AP_{BORG} \\\\ \\mathbf{0} & 1 \\end{bmatrix} Sec 1.5 More on Representation of Orientation X-Y-Z Fixed Angles Rotate $\\{B\\}$ about fixed axes of $\\{A\\}$ (order: X→Y→Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-X Euler Angles Rotate $\\{B\\}$ about its own axes (order: Z→Y→X): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(x, \\gamma) Z-Y-Z Euler Angles Rotate $\\{B\\}$ about its own axes (order: Z→Y→Z): {}^A_BR = R(z, \\alpha) R(y, \\beta) R(z, \\gamma) Comparison Chap 2. Manipulator Kinematics"},{"title":"Kalman Filter Introduction","path":"/wiki/kalmanprj/Kalman Intro.html","content":"1 IntroductionThe Kalman filter, first proposed by Rudolf E. Kálmán in 1960, has become one of the most fundamental and widely used algorithms in estimation theory and signal processing. As an optimal recursive estimator, it provides an efficient computational framework for inferring the internal states of dynamic systems from noisy measurements. The fundamental strength of the Kalman filter lies in its ability to combine uncertain predictions with noisy measurements through an elegant probabilistic framework. By maintaining estimates of both the system state and its uncertainty covariance matrix, the filter achieves optimal estimation in the minimum mean-square error (MMSE) sense for linear Gaussian systems. This recursive nature makes it particularly suitable for real-time applications where computational efficiency is crucial. 2 AlgorithmThe Kalman filter operates through a recursive prediction-correction cycle, combining system dynamics with noisy measurements. Consider a discrete-time linear dynamic system described by: \\mathbf{x}_k = \\mathbf{A}\\mathbf{x}_{k-1} + \\mathbf{B}\\mathbf{u}_k + \\mathbf{w}_k \\mathbf{z}_k = \\mathbf{H}\\mathbf{x}_k + \\mathbf{v}_kwhere $\\mathbf{x}_k \\in \\mathbb{R}^n$ is the state vector, $\\mathbf{u}_k \\in \\mathbb{R}^m$ the control input, and $\\mathbf{z}_k \\in \\mathbb{R}^p$ the measurement vector. $\\mathbf{A}$ (state transition), $\\mathbf{B}$ (control input), and $\\mathbf{H}$ (observation) matrices define the system model. Process noise $\\mathbf{w}_k \\sim \\mathcal{N}(0,\\mathbf{Q})$ and measurement noise $\\mathbf{v}_k \\sim \\mathcal{N}(0,\\mathbf{R})$ are independent Gaussian distributions. 2.1 Predict PhaseThe filter first predicts the a priori state estimate and error covariance: \\hat{\\mathbf{x}}^-_k = \\mathbf{A}\\hat{\\mathbf{x}}_{k-1} + \\mathbf{B}\\mathbf{u}_k \\mathbf{P}^-_k = \\mathbf{A}\\mathbf{P}_{k-1}\\mathbf{A}^\\top + \\mathbf{Q}where $\\hat{\\mathbf{x}}^-_k$ represents the predicted state estimate and $\\mathbf{P}^-_k$ the predicted estimate covariance. 2.2 Update PhaseThe measurement update incorporates observations to compute the a posteriori estimate: \\mathbf{K}_k = \\mathbf{P}^-_k\\mathbf{H}^\\top(\\mathbf{H}\\mathbf{P}^-_k\\mathbf{H}^\\top + \\mathbf{R})^{-1} \\hat{\\mathbf{x}}_k = \\hat{\\mathbf{x}}^-_k + \\mathbf{K}_k(\\mathbf{z}_k - \\mathbf{H}\\hat{\\mathbf{x}}^-_k) \\mathbf{P}_k = (\\mathbf{I} - \\mathbf{K}_k\\mathbf{H})\\mathbf{P}^-_kHere, $\\mathbf{K}_k$ denotes the Kalman gain matrix that optimally weights prediction and measurement uncertainties. The innovation term $(\\mathbf{z}_k - \\mathbf{H}\\hat{\\mathbf{x}}^-_k)$ represents the difference between actual and predicted measurements. 2.3 Algorithm Pseudocode"},{"title":"Kalman Filter Simulation Practice","path":"/wiki/kalmanprj/Kalman simulation.html","content":"Project I1. Project DescriptionThe object is initially 40,000$m$ above the radar and throwing at initial vertical downward velocity 300$m/s$ and horizontal velocity 400$m/s$ . In this example we are neglecting drag or air resistance so that only gravity g ( $g$=9.8$m/s^2$) acts on the object.Assuming that the radar measures the range from the radar to the target with a 100$m$ standard deviation measurement accuracy. The radar takes measurement 10 times a second for 30 s. We would like to build a filter to estimate the position and velocity of the object without any a priori information. 2. Modelling State Space: We set the k-th state $\\boldsymbol{x}_k = [P_x\\quad P_y \\quad V_x\\quad V_y]^T_k$, so the (k+1)-th state is \\boldsymbol{x}_{k+1} = [P_x\\quad P_y \\quad V_x\\quad V_y]^T_{k+1}\\quad \\text{Expanded,} \\begin{bmatrix} P_x^{k+1} \\\\ P_y^{k+1}\\\\ V_x^{k+1}\\\\ V_y^{k+1} \\end{bmatrix} = \\begin{bmatrix} P_x^k +V_x^kdt + \\frac{1}{2}a_x(dt)^2\\\\ P_y^k +V_y^kdt + \\frac{1}{2}a_y(dt)^2\\\\ V_x^k + a_xdt\\\\ V_y^k + a_ydt \\end{bmatrix} The control input is $\\boldsymbol{u}_k = [a_x\\quad a_y]^T$. State Transition Matrix: According to the equation $\\boldsymbol{x}_{k+1} = \\mathbf{A}\\boldsymbol{x}_k + \\mathbf{B}\\boldsymbol{u}_k + \\boldsymbol{w}_k$, we can write: \\begin{bmatrix} P_x^{k+1} \\\\ P_y^{k+1}\\\\ V_x^{k+1}\\\\ V_y^{k+1} \\end{bmatrix} = A \\cdot \\begin{bmatrix} P_x^k \\\\ P_y^k\\\\ V_x^k\\\\ V_y^k \\end{bmatrix} + B \\cdot \\begin{bmatrix} a_x\\\\ a_y \\end{bmatrix}So the state transition matrix $\\mathbf{A}$ is: \\mathbf{A} = \\begin{bmatrix} 1 & 0 & dt & 0\\\\ 0 & 1 & 0 & dt\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1 \\end{bmatrix} The control input matrix $\\mathbf{B}$ is: \\mathbf{B} = \\begin{bmatrix} \\frac{1}{2}(dt)^2 & 0\\\\ 0 & \\frac{1}{2}(dt)^2\\\\ dt & 0\\\\ 0 & dt \\end{bmatrix} Measurement Model: The measurement model is given by:$\\mathbf{z}_k = \\mathbf{H}\\boldsymbol{x}_k + \\mathbf{v}_k$. where $\\mathbf{H}$ is the measurement matrix. In this case, we only measure the range from the radar to the target, so: $\\boldsymbol{z}_k=\\boldsymbol{x}_k = \\begin{bmatrix}P_x^k\\\\P_y^k\\\\V_x^k\\\\V_y^k\\end{bmatrix}$. eventually we have: $\\mathbf{H} =\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$. Process Noise: The process noise $\\mathbf{w}_k$ is assumed to be Gaussian with zero mean and covariance $\\mathbf{Q}$. We can set $\\mathbf{Q}$ as: \\mathbf{Q} = \\begin{bmatrix} q_{P_x} & 0 & 0 & 0\\\\ 0 & q_{P_y} & 0 & 0\\\\ 0 & 0 & q_{V_x} & 0\\\\ 0 & 0 & 0 & q_{V_y} \\end{bmatrix}where $q_{P_x}$, $q_{P_y}$, $q_{V_x}$, and $q_{V_y}$ are the process noise variances for position and velocity in the x and y directions, respectively. We can set them as: q_{P_x} = 0.1, \\quad q_{P_y} = 0.1, \\quad q_{V_x} = 0.1, \\quad q_{V_y} = 0.1 Measurement Noise: The measurement noise $\\mathbf{v}_k$ is also assumed to be Gaussian with zero mean and covariance $\\mathbf{R}$. We can set $\\mathbf{R}$ as: \\mathbf{R} = \\begin{bmatrix} r_{P_x} & 0 & 0 & 0\\\\ 0 & r_{P_y} & 0 & 0\\\\ 0 & 0 & r_{V_x} & 0\\\\ 0 & 0 & 0 & r_{V_y} \\end{bmatrix}where $r_{P_x}$, $r_{P_y}$, $r_{V_x}$, and $r_{V_y}$ are the measurement noise variances for position and velocity in the x and y directions, respectively. We can set them as: r_{P_x} = 100, \\quad r_{P_y} = 100, \\quad r_{V_x} = 100, \\quad r_{V_y} = 100 Initial State: The initial state $\\boldsymbol{x}_0$ is given by the initial position and velocity of the object. We can set it as: \\boldsymbol{x}_0 = \\begin{bmatrix} P_x\\\\ P_y\\\\ V_x\\\\ V_y \\end{bmatrix} = \\begin{bmatrix} 0\\\\ 40000\\\\ 400\\\\ -300 \\end{bmatrix}where $P_x$ is the initial position in the x direction, $P_y$ is the initial position in the y direction, $V_x$ is the initial velocity in the x direction, and $V_y$ is the initial velocity in the y direction. And the control input $\\boldsymbol{u}_0$ is given by the initial acceleration of the object. We can set it as: \\boldsymbol{u}_0 = \\begin{bmatrix} a_x\\\\ a_y \\end{bmatrix} = \\begin{bmatrix} 0\\\\ -9.8 \\end{bmatrix}where $a_x$ is the acceleration in the x direction and $a_y$ is the acceleration in the y direction. Initial Covariance: The initial covariance $\\mathbf{P}_0$ is given by the initial uncertainty of the state. We can set it as: \\mathbf{P}_0 = \\begin{bmatrix} p_{P_x} & 0 & 0 & 0\\\\ 0 & p_{P_y} & 0 & 0\\\\ 0 & 0 & p_{V_x} & 0\\\\ 0 & 0 & 0 & p_{V_y} \\end{bmatrix}where $p_{P_x}$, $p_{P_y}$, $p_{V_x}$, and $p_{V_y}$ are the initial covariance values for position and velocity in the x and y directions, respectively. We can set them as: p_{P_x} = 0.1, \\quad p_{P_y} = 0.1, \\quad p_{V_x} = 0.1, \\quad p_{V_y} = 0.13. Results:Position estimation: Velocity estimation: Project II1. Project DescriptionSuppose that the actual measurement is a pure cosine wave of unity amplitude corrupted by noise or where $\\omega$ is the frequency of the cosinusoidal signal and the noise is zero-mean Gaussian with a standard deviation of unity. We would like to build a Kalman filter that will be able to track the cosinusoidal and estimate its states based on the noisy cosinusoidal measurement. \\boldsymbol{x}^{*} = \\cos (\\omega t) + \\textbf{noise}2. Modelling State Space We set the k-th state $\\boldsymbol{x}_k = [x_1\\quad x_2]^T_k$. The components of the state vector are: \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} \\cos(\\omega t)\\\\ \\sin(\\omega t) \\end{bmatrix}The components meet the relationship: \\left\\{\\begin{matrix} \\dot{x_1} (t) = -\\omega x_2(t)\\\\ \\dot{x_2} (t) = -\\omega x_1(t) \\end{matrix}\\right.The (k+1)-th state is $\\boldsymbol{x}_{k+1}$ is given by: \\boldsymbol{x}_{k+1} = \\begin{bmatrix} \\cos\\omega (t + dt)\\\\ \\sin\\omega (t + dt) \\end{bmatrix} = \\begin{bmatrix} \\cos \\omega t \\sin \\omega dt - \\sin\\omega t \\sin \\omega dt\\\\ \\sin \\omega t \\cos \\omega dt + \\cos\\omega t \\sin \\omega dt \\end{bmatrix} State Transition Matrix: According to the equation $\\boldsymbol{x}_{k+1} = \\mathbf{A}\\boldsymbol{x}_k + \\mathbf{B}\\boldsymbol{u}_k + \\boldsymbol{w}_k$, since the control input is zero, we can write: \\begin{bmatrix} \\cos \\omega t \\sin \\omega dt - \\sin\\omega t \\sin \\omega dt\\\\ \\sin \\omega t \\cos \\omega dt + \\cos\\omega t \\sin \\omega dt \\end{bmatrix} = \\mathbf{A} \\cdot \\begin{bmatrix} \\cos(\\omega t)\\\\ \\sin(\\omega t) \\end{bmatrix}So the state transition matrix $\\mathbf{A}$ is: \\mathbf{A} = \\begin{bmatrix} \\cos\\omega dt & -\\sin\\omega dt\\\\ \\sin\\omega dt & \\cos\\omega dt \\end{bmatrix} Measurement Model: The measurement model is given by:$\\mathbf{z}_k = \\mathbf{H}\\boldsymbol{x}_k + \\mathbf{v}_k$. where $\\mathbf{H}$ is the measurement matrix. In this case, we only measure the range from the radar to the target, so: $ \\boldsymbol{z}_k=\\boldsymbol{x}_k = \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix}$. eventually we have: $\\mathbf{H} = \\begin{bmatrix} 1 &amp; 0 \\end{bmatrix}$. Process Noise: The process noise $\\mathbf{w}_k$ is assumed to be Gaussian with zero mean and covariance $\\mathbf{Q}$. We can set $\\mathbf{Q}$ as: \\mathbf{Q} = \\begin{bmatrix} q_{x_1} & 0\\\\ 0 & q_{x_2} \\end{bmatrix}where $q_{x_1}$ and $q_{x_2}$ are the process noise variances in the two component states, respectively. We can set them as: q_{x_1} = 10^{-3}, \\quad q_{x_2} = 10^{-3} Measurement Noise: The measurement noise $\\mathbf{v}_k$ is also assumed to be Gaussian with zero mean and covariance $\\mathbf{R}$. We can set $\\mathbf{R}$ as: \\mathbf{R} = \\begin{bmatrix} r_{x} \\end{bmatrix}where $r_{x}$ are the measurement noise variances in the measure state. We can set: r_{x} = 1 Initial State: The initial state $\\boldsymbol{x}_0$ is given by the initial state. We can set it as: \\boldsymbol{x}_0 = \\begin{bmatrix} x_1\\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 1\\\\ 0 \\end{bmatrix}where $x_1$ is the initial state in the first component and $x_2$ is the initial state in the second component.(The initial state is the cosine wave at $t=0$) Initial Covariance: The initial covariance $\\mathbf{P}_0$ is given by the initial uncertainty of the state. We can set it as: \\mathbf{P}_0 = \\begin{bmatrix} p_{x_1} & 0\\\\ 0 & p_{x_2} \\end{bmatrix}where $p_{x_1}$ and $p_{x_2}$ are the initial covariance values for the two component states, respectively. We can set them as: p_{x_1} = 1, \\quad p_{x_2} = 13. Results"},{"title":"Sensors and Measurement System(EN)","path":"/notes/sensors.html","content":"Chap1 IntroductiomSec 1.1 Definition of measurement systemThe measurement is the process by which one can convert physical parameters to meaningful numbers. A measurement system is an information system which presents an observer with a numerical value corresponding to the variable being measured. Sec 1.2 Structure of measurement system Sensing elements: This is in contact with the process and gives an output which depends in some way on the variable to be measured. Signal conditioning element: This takes the output of the sensing elements and converts it into a form more suitable for further processing. Signal processing element: This takes the output of the conditioning element and converts it into a form more suitable for presentation. Data presentation element: This presents the measured value in a form which can be easily recognized by the observer. Sec 1.3 Applications In regulating trade, i.e. ruler. In monitoring functions, i.e. smoke sensor. Using as part of automatic feedback control systems, i.e. feedback control system. Sec 1.4 Methods of measurement Direct method: The unknown quantity can be measured directly. (like vernier caliper) Indirect method: It can’t be measured directly, but it can be transformed into directly measurable physical quantity by the relation. (like laser range finder) Sec 1.5 Definition of sensors A sensor is a device that receives a stimulus and responds with an electrical signal. A sensor is a translator of a generally nonelectrical value into an electrical value, which can be channeled, amplified, and modified by electronic devices. Sec 1.6 Sensor classification1.6.1 Passive and active Passive sensor: it does not need any additional energy source and directly generates an electric signal in response to an external stimulus. That is, the input stimulus energy is converted by the sensor into the output signal. Active Sensor: it requires external power for its operation, which is called an excitation signal. That signal is modified by the sensor to produce the output signal. 1.6.2 Absolute and relative Absolute sensor: it detects a stimulus in reference to an absolute physical scale that is independent of the measurement conditions. Relative sensor: it produces a signal that relates to some special case. Chap 2 Measurement system Characteristic and PrinciplesSec 2.1 Static characteristics Static or steady-state characteristics; The relationships which may occur between the output $O$ and input $I$ of an element when $I$ is either at a constant value or changing slowly. It consists of systematic characteristic and statistical ones. 2.1.1 Systematic characteristicsThe systematic characteristics can be exactly quantified by mathematical or graphical means. These are distinct from statistical characteristics which can not be exactly quantified. Range: \\text{The input range}: I_{\\text{min}} \\quad \\text{to} \\quad I_{\\text{max}} \\text{The output range}: O_{\\text{min}} \\quad \\text{to} \\quad O_{\\text{max}} Span \\text{The input span}: I_{\\text{max}}- I_{\\text{min}} \\text{The output span}: O_{\\text{max}}- O_{\\text{min}} Usually the relationship between the input and output is monotonic. If not, the system is unsuitable for measuring. We should consider that the maximum input $I_{\\mathrm{max}}$ corresponds to the maximum output $O_{\\mathrm{max}}$. Linearity (Ideal straight line)The ideal straight line connects the minimum point A($I_{MIN}$, $O_{MIN}$) to maximum B($I_{MAX}$, $O_{MAX}$) O_{\\text{IDEAL}} = KI+awhere K = \\text{ideal straight-line slope} = \\frac{O_{\\text{max}}- O_{\\text{min}}}{I_{\\text{max}}- I_{\\text{min}}} a = \\text{ideal straight-line intercept} = O_{\\text{min}} - KI_{\\text{min}} We are only describing the relationship between output and input, not fitting the curve. Non-linearity N(I) = O(I) - (KI+a) \\text{Max non-linearity as a percentage of f.s.d.} = \\frac{\\hat{N}}{O_{\\text{max}}- O_{\\text{min}}} \\times 100\\% Sensitivity This is the change $\\Delta O$ output $O$ for unit change $\\Delta I$ input $I$. If the $\\Delta I$ tends to zero, we can find that the sensitivity $ \\Delta O \\setminus \\Delta I $ is the derivative $ \\text{d} O \\setminus \\text{d} I $. Hysteresis H(I) = O(I)_{\\downarrow } - O(I)_{\\uparrow } \\text{Max hysteresis as a percentage of f.s.d.} = \\frac{\\hat{H}}{O_{\\text{max}}- O_{\\text{min}}} \\times 100\\% ResolutionThis is defined as largest change in I that can occur without any corresponding change in O. R(I) = \\frac{\\Delta I_{R}}{I_{\\text{max}}- I_{\\text{min}}} \\times 100\\%For example, the ADC converter. Wear and ageing These effects can cause the characteristics of an element, e.g. $K$ and $a$, to change slowly but systematically throughout its life. Error bands Here the manufacturer states that for any value of I, the output $O$ will be within $\\pm h$ of the ideal straight-line value $O_{IDEAL}$. Environment effect The steady-state of output in general is expressed as: O = KI + a + N(I) + K_MI_MI+K_II_IWhere: $K_M$ is the change in sensitivity for unit change in $I_M$; $K_I$ is the change in zero bias for unit change in $I_I$. What is the interfering input $I_I$ and the modifying input $I_M$? Interfering Inputs - Quantities to which instrument is unintentionally sensitive. Modifying Inputs - Quantities which cause changes in Input-Output relations of desired and interfering inputs."},{"title":"ADC","path":"/wiki/lanqiao/ADC.html","content":"嵌入式ADC在cubemx中选择PB12，PB15分别设置为ADC输出模式（ADC1_IN11和ADC2_IN15） 生成代码后，在adc.c文件中写单通道采样函数，需要在adc.h文件中声明 1234567double getADC(ADC_HandleTypeDef *pin)&#123; uint16_t adc; HAL_ADC_Start(pin); adc = HAL_ADC_GetValue(pin); return adc*3.3/4096;&#125; 在主函数中，用ACD_Proc()调用采样功能 12345678void ADC_Proc(void)&#123; char text[20]; adc_value1 = getADC(&amp;hadc1); adc_value2 = getADC(&amp;hadc2); sprintf(text,&quot;ADC1:%.2f,ADC2:%.2f&quot;,adc_value1,adc_value2); LCD_DisplayStringLine(Line4,(uint8_t *)text);&#125; 需要注意的是，记得在adc.c中使用校准函数对采样进行校准，否则采样最大值为3.25V 123456/* USER CODE BEGIN ADC1_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc1,ADC_SINGLE_ENDED);/* USER CODE END ADC1_Init 2 *//* USER CODE BEGIN ADC2_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);/* USER CODE END ADC2_Init 2 */"},{"title":"IIC","path":"/wiki/lanqiao/IIC.html","content":"嵌入式IIC通信与EEPROM的读写I2C总线是一种双向二线制的同步串行总线，它只需要两根线即可在连接于总线上的器件之间传送信息。（SDA和SCL） 关键是读懂EEPROM的读写时序。 对照着时序图，我们可以写出与EEPROM进行读写数据的函数： 12345678910111213//写函数void e2prom_write(unsigned char address, unsigned char info)&#123; I2CStart(); //1.I2C起始信号(START) I2CSendByte(0xa0); //2.发送设备地址与“写”信号(DEVICE ADDRESS+WRITE)，将在下文解释 I2CWaitAck(); //3.IC2等待确认信号(ACK) I2CSendByte(address); //4.发送数据存储地址(WORD ADDRESS)（可以为0~255，对应256个） I2CWaitAck(); //5.I2C等待确认信号(ACK) I2CSendByte(info); //6.发送数据(DATA) I2CWaitAck(); //7.I2C等待确认信号(ACK) I2CStop(); //8.I2C结束信号(STOP)&#125; 12345678910111213141516171819202122//读函数unsigned char e2prom_read(unsigned char address)&#123; unsigned char val; I2CStart(); //1.I2C起始信号(START) I2CSendByte(0xa0); //2.发送设备地址与“写”信号(DEVICE ADDRESS+WR-TE)，将在下文解释 I2CWaitAck(); //3.IC2等待确认信号(ACK) I2CSendByte(address); //4.发送数据存储地址(WORD ADDRESS)（可以为0~255，对应256个） I2CWaitAck(); //5.I2C等待确认信号(ACK) I2CStop(); //下一次发送起始信号前先停止 I2CStart(); //6.I2C起始信号(START) I2CSendByte(0xa1); //7.发送设备地址与“读”信号(DEVICE ADDRESS+READ)，将在下文解释 I2CWaitAck(); //8.I2C等待确认信号(ACK) val = I2CReceiveByte(); //9.接收数据(DATA) I2CSendNotAck(); //10.I2C发送非确认信号(NO ACK) I2CStop(); //11.I2C结束信号(STOP) return (val);&#125; 注意，EEPROM每一个地址只能读取8位无符号数，16位或者32位需要进行分割 在实际使用中，每一次的EEPROM的读写都需要时间，在具体程序中需要进延时操作。"},{"title":"KEY","path":"/wiki/lanqiao/KEY.html","content":"嵌入式按键使用按键状态机，在用户区新建Key_State.c和Key_State.h文件。在Key_State.h中，写下 123456789101112131415161718192021222324252627#ifndef __KEY_STATE_H_#define __KEY_STATE_H_#include &quot;main.h&quot;/** * @brief 按键状态结构体 */struct keys&#123; uint8_t judge_state; // 状态机标志，0： 检测到一个低电平；1：确实被按下；2：等待抬起 uint8_t key_state; // 按键是否被按下（信号来自GPIO输入） uint8_t key_isPressed; // 按键短按标志位 uint8_t key_long_flag; // 按键长按标志位 uint32_t key_time; // 按键计时 uint32_t key_double_click_time; // 双击计时器 uint8_t key_double_click_EN; // 双击计时器使能 uint8_t key_double_click_flag; // 双击标志位&#125;;extern struct keys key[];void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);#endif keys结构体即为按键状态机，使用定时中断函数进行按键消抖。 Key_State.c内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;Key_State.h&quot;struct keys key[4] = &#123;0, 0, 0, 0&#125;;/** * @brief TIM定时器定时中断回调函数 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM3) &#123; key[0].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); key[1].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1); key[2].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2); key[3].key_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); for (uint8_t i = 0; i &lt; 4; i ++) &#123; if (key[i].key_double_click_EN == 1) // 计数器使能开启时，计时并判断 &#123; key[i].key_double_click_time ++; if (key[i].key_double_click_time &gt; 35) // 如果超时，则说明是短按，置标志位后关闭计数器使能 &#123; key[i].key_isPressed = 1; key[i].key_double_click_EN = 0; &#125; &#125; switch (key[i].judge_state) &#123; case 0: if (key[i].key_state == 0) // 如果刚开始检测到一个低电平 &#123; key[i].key_time = 0; // 时间计数清0 key[i].judge_state = 1; &#125; break; case 1: if (key[i].key_state == 0) // 如果10ms后依然检测到这个按键是低电平，就说明这个按键确实被按下了 &#123; key[i].judge_state = 2; &#125; else &#123; key[i].judge_state = 0; &#125; break; case 2: if (key[i].key_state == 1 &amp;&amp; key[i].key_time &lt;= 70) // 如果是一次短按 &#123; key[i].judge_state = 0; if (key[i].key_double_click_EN == 0) // 如果是第一次按下 &#123; key[i].key_double_click_EN = 1; key[i].key_double_click_time = 0; &#125; else // 双击计时开启，说明这次短按还在双击计时的时间范围内 &#123; key[i].key_double_click_EN = 0; key[i].key_double_click_flag = 1; &#125; &#125; else if (key[i].key_state == 1 &amp;&amp; key[i].key_time &gt; 70) // 长按松开按键，则回到state0 &#123; key[i].judge_state = 0; &#125; else if (key[i].key_state == 0) // 如果按键没有松开，则持续计时 &#123; key[i].key_time ++; if (key[i].key_time &gt; 70) // 如果按键按下时间大于700ms &#123; key[i].key_long_flag = 1; &#125; &#125; break; default: break; &#125; &#125; &#125;&#125; 记住要在cubemx中设置10ms中断，其中PSC预分频是79（80-1），ARR重装预载是9999（10000-1）。以及加入初始化函数： 1HAL_TIM_Base_Start_IT(&amp;htim3);"},{"title":"16届蓝桥杯模拟试题1","path":"/wiki/lanqiao/16moni_1.html","content":"原题请在80MHz主频下完成以下任务 功能要求： 功能概述： 通过微控制器的ADC功能，检测电位器R37上输出的模拟电压信号; 通过板载AT24C02 EEPROM芯片，存储密码值; 依试题要求，通过LCD完成数据显示等功能; 依试题要求通过按键完成参数设置功能; 依试题要求，通过LED完成状态指示功能。 性能要求： 按键响应时间:≤0.1秒 电压采集刷新时间:≤0.5秒 AT24C02:数据掉电不丢失 显示功能： 输入界面：显示要素包含界面名称(Lock)，输入密码(Pass Word)。输入密码值从左往右输入，未输入的密码值使用”*”代替。 修改界面：显示要素包含界面名称(Set)，待修改密码(Change)。修改密码值从左往右输入，未输入的修改密码值使用“*”代替。 LCD通用要求： 显示背景色(BackColor):黑色 显示前景色(TextColor):白色 请严格按照图示要求设计各个信息项的名称(区分字母大小写)和行列位置。 密码机制：使用微控制器的ADC功能读取电位器R37的电压值，经转换关系转化后作为输入的密码：输入界面输入密码与修改界面输入密码的机制相同。 存储功能：当前密码值存储于AT24C02的指定位置，密码数据掉电不丢失，存储表如下图所示。 解锁功能： 输入界面下，完成三位密码值输入后自动尝试解锁，若输入密码值和存储密码值一致，则进入修改界面，否则输入的密码值更置为“*”，可以重新开始输入密码。 进入修改界面后3秒不进行修改密码操作则返回输入界面。 按键功能 B1:定义为“确认”按键： 在输入界面，按下B1按键，确定一位输入密码。 在修改界面，按下B1按键，确定一位修改的密码。若三位修改密码值输入完成，则将密码值修改成功，同时对当前密码值进行存储，并返回到输入界面。 通用按键要求： 按键应进行有效的防抖处理，避免出现一次按键动作触发多次功能等情形。 按键动作不应影响数据采集过程和屏幕显示效果。 当前界面下无功能的按键按下，不触发其它界面的功能。 LED功能 LD1:处于输入界面时，指示灯LD1点亮，否则熄灭。 LD2:处于修改界面时，指示灯LD2点亮，否则熄灭。 LD3-LD8指示灯。 初始状态说明： 请严格按照以下要求设置作品的初始状态： 处于输入界面 初始状态密码默认为：012 设计思路Cubemx配置： 时钟树配置 引脚配置 LED模块在cubemx中配置好时钟和引脚后，新建工程文件，打开工程文件，新增文件“led.c”和“led.h”。 led.c123456789101112#include &quot;led.h&quot;void LED_Disp(uint8_t led)&#123;\tHAL_GPIO_WritePin(GPIOC, 0xff&lt;&lt;8, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC, led&lt;&lt;8, GPIO_PIN_RESET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);\tHAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);&#125; led.h1234567#ifndef __LED_H#define __LED_H#include &quot;main.h&quot;void LED_Disp(uint8_t led);#endif 按键模块新建文件“key.c”和“key.h”，由于只需要按键单击，所以我们的按键驱动可以简写： key.c123456789101112131415161718192021222324252627282930313233#include &quot;key.h&quot;struct keys key[4] = &#123;0,0,0,0&#125;;void key_state(void)&#123;\tkey[0].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0);\tkey[1].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1);\tkey[2].key_state = HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2);\tkey[3].key_state = HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0); for(uint8_t i = 0; i&lt; 4; i++)\t&#123; switch(key[i].judge_state) &#123; case 0: if(key[i].key_state == 0) &#123; key[i].judge_state =1; &#125; break; case 1: if(key[i].key_state == 1) &#123; key[i].key_ispressed = 1; key[i].judge_state = 0; &#125; break; default:break; &#125;\t&#125; &#125; key.h123456789101112131415161718#ifndef __KEY_H#define __KEY_H#include &quot;main.h&quot;struct keys&#123;\tuint8_t judge_state;\tuint8_t key_state;\tuint8_t key_ispressed;&#125;;extern struct keys key[];void key_state(void);#endif ADC电压捕获配置打开生成的“adc.c”文件，在用户代码区增加ADC捕获函数： adc.c12345678910/* USER CODE BEGIN 1 */double getADC(ADC_HandleTypeDef *pin)&#123;\tuint16_t adc;\tHAL_ADC_Start(pin);\tadc = HAL_ADC_GetValue(pin);\treturn adc*3.3/4096;&#125;/* USER CODE END 1 */ 记住需要在“adc.h”中增加声明。 e2prom模块将赛点资源包中的i2c驱动放到项目文件夹中，并导入到项目： 新建“e2prom.c”和“e2prom.h”文件： e2prom.c123456789101112131415161718192021222324252627282930313233343536#include &quot;e2prom.h&quot;#include &quot;i2c_hal.h&quot;void e2prom_write(uint8_t addr, uint8_t data)&#123;\tI2CStart();\tI2CSendByte(0xa0);\tI2CWaitAck(); I2CSendByte(addr);\tI2CWaitAck();\tI2CSendByte(data);\tI2CWaitAck();\tI2CStop();&#125;uint8_t e2prom_read(uint8_t addr)&#123;\tuint8_t val;\tI2CStart();\tI2CSendByte(0xa0);\tI2CWaitAck(); I2CSendByte(addr);\tI2CWaitAck();\tI2CStop(); I2CStart();\tI2CSendByte(0xa1);\tI2CWaitAck();\tval = I2CReceiveByte();\tI2CSendNotAck();\tI2CStop(); return val;&#125; e2prom.h123456789#ifndef __E2PROM_H#define __E2PROM_H#include &quot;main.h&quot;void e2prom_write(uint8_t addr, uint8_t data);uint8_t e2prom_read(uint8_t addr);#endif 主函数LCD显示与程序主体同样的，我们把“lcd.c”和“lcd.h”放入项目文件夹和项目文件中，在主函数用户编辑区，增加lcd显示函数用于显示屏幕内容： main.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void LCD_Page(void)&#123;\tchar buf[20]; switch(page_flag)\t&#123; case 0: sprintf(buf,&quot; Lock &quot;); LCD_DisplayStringLine(Line1, (uint8_t *)buf); sprintf(buf,&quot; Pass Word &quot;); LCD_DisplayStringLine(Line3,(uint8_t *)buf); if(password1_flag == 1 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d * * &quot;,password[0]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d %d * &quot;,password[0],password[1]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 1) &#123; sprintf(buf,&quot; %d %d %d &quot;,password[0],password[1],password[2]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); if(password[0] == password_saved[0] &amp;&amp; password[1] == password_saved[1] &amp;&amp; password[2] == password_saved[2]) page_flag = 1, password1_flag = 0, password2_flag = 0, password3_flag = 0, password[0] = 0, password[1] = 0, password[2] = 0; else password1_flag = 0, password2_flag = 0, password3_flag = 0, password[0] = 0, password[1] = 0, password[2] = 0 ; &#125; if(password1_flag == 0 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; * * * &quot;); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; LED_Disp(0x01); break; case 1: sprintf(buf,&quot; Set &quot;); LCD_DisplayStringLine(Line1, (uint8_t *)buf); sprintf(buf,&quot; Change &quot;); LCD_DisplayStringLine(Line3,(uint8_t *)buf); if(password1_flag == 1 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d * * &quot;,password_saved[0]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; %d %d * &quot;,password_saved[0],password_saved[1]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); &#125; if(password1_flag == 1 &amp;&amp; password2_flag == 1 &amp;&amp; password3_flag == 1) &#123; sprintf(buf,&quot; %d %d %d &quot;,password_saved[0],password_saved[1],password_saved[2]); LCD_DisplayStringLine(Line4,(uint8_t *)buf); page_flag = 0; password1_flag = 0, password2_flag = 0, password3_flag = 0; &#125; if(password1_flag == 0 &amp;&amp; password2_flag == 0 &amp;&amp; password3_flag == 0) &#123; sprintf(buf,&quot; * * * &quot;); LCD_DisplayStringLine(Line4,(uint8_t *)buf); if(timer &gt;=3000) &#123; page_flag = 0; timer = 0; &#125; &#125; save_Password(); LED_Disp(0x02); break; default:break;\t&#125;&#125; 这里的设计思路是： page_flag 标志用于切换“Pass Word”界面和“Change”界面； password_flag1 到 password_flag3是三个密码的输入标志，对应每一位密码，在该位密码输入后密码输入标志置1； 三位密码标志全部置1后判断输入的密码和存储的密码是否相等，相等进入设置界面；无论如何都会清零密码输入标志； 设置界面也是相同思路； 如何实现3s不设置密码返回？设置设置密码界面标志位，进入密码设置界面后标志置1，滴答计时器开始计时，当计时3s时且没有输入密码（密码输入标志位均为0），界面标志位置0返回输入密码界面。 密码输入模块在主函数中用户编辑区，main.c12345678910111213141516171819202122232425void enter_Password(void)&#123;\tr37 = getADC(&amp;hadc2);\tif(key[0].key_ispressed == 1)\t&#123; key[0].key_ispressed = 0; i++; password[i-1] = get_Password(r37); switch(i) &#123; case 1: password1_flag = 1; break; case 2: password2_flag = 1; break; case 3: password3_flag = 1; break; default:break; &#125; if(i&gt;=3) i = 0;\t&#125;&#125;每按下一次B1按键，i都自增1，设置密码输入标志位。根据当前的r37的电压确定密码： main.c12345678uint8_t get_Password(double adc)&#123;\tuint8_t password_value;\tif(adc &lt; 1.5) password_value = 0;\tif(adc&gt;=1.5 &amp;&amp; adc &lt;=2.5) password_value = 1;\tif(adc &gt; 2.5) password_value = 2;\treturn password_value;&#125; 密码存储与读取功能存储密码：在上面的密码输入函数后面添加将数组内容写入eeprom的内容。main.c12345678910111213141516171819202122232425262728293031void save_Password(void)&#123;\tr37 = getADC(&amp;hadc2);\tif(key[0].key_ispressed == 1)\t&#123; key[0].key_ispressed = 0; i++; password_saved[i-1] = get_Password(r37); switch(i) &#123; case 1: password1_flag = 1; break; case 2: password2_flag = 1; break; case 3: password3_flag = 1; break; default:break; &#125; if(i&gt;=3) i = 0;\t&#125;\te2prom_write(0x00, password_saved[0]);\tHAL_Delay(10);\te2prom_write(0x01, password_saved[1]);\tHAL_Delay(10);\te2prom_write(0x02, password_saved[2]);\tHAL_Delay(10);&#125;密码读取：main.c12345678910void read_Password(void)&#123;\tHAL_Delay(10);\tpassword_saved[0] = e2prom_read(0x00);\tHAL_Delay(10);\tpassword_saved[1] = e2prom_read(0x01);\tHAL_Delay(10);\tpassword_saved[2] = e2prom_read(0x02);\tHAL_Delay(10);&#125;初始密码设置：这里设置一个标志位，在进入循环之前查看eeprom里是否存在该标志，如果不存在，则表示第一次写入；否则不是第一次写入。main.c123456789101112131415161718192021222324252627int main&#123;\t...\tif(e2prom_read(0x21) != 4) // 判断是否时第一次写入\t&#123; e2prom_write(0x21,4); HAL_Delay(10); initial_password();\t&#125;\t...\twhile (1)\t...&#125;...void initial_password(void)&#123;\tHAL_Delay(10);\te2prom_write(0x00, 0);\tHAL_Delay(10);\te2prom_write(0x01, 1);\tHAL_Delay(10);\te2prom_write(0x02, 2);\tHAL_Delay(10);&#125; 项目源文件将这些文件综合一下就可以完成这一题，在4T评测网中这题也是满分。 源文件"},{"title":"LED","path":"/wiki/lanqiao/LED.html","content":"LED操作在cubemx中配置时钟和引脚，LED低电平有效 注意要打开PD2锁存器 基本写法： 123456void LED(uint8_t dsled)&#123; HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); //打开锁存器 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET); //灭掉所有的LED HAL_GPIO_WritePin(GPIOC, dsled&lt;&lt;8, GPIO_PIN_RESET); //选择特定的LED亮起&#125; 其中dsled是8位无符号数，0x_ _。 高位即为左边四个led，低位即为右边四个led。每一位取1即为该led亮。 LED交替闪烁和LED闪烁取反 ~ 左四位和右四位交替闪烁 取异或^该位led闪烁 1234567891011uint8_t ucLed=0x0f; //交替闪烁LED(~ucLed); //闪烁uint8_t ucLed2 = 0x0f;LED(ucLed2);HAL_Delay(1000);ucLed2^=0x0f; LED实现流水灯位运算左移和右移（&lt;&lt;和&gt;&gt;） Systick 滴答计时HAL_Delay()是阻塞赋值，可以使用Systick进行计时，Systick进行了已经设置了1ms的中断。 计时方式 12345678910111213141516171819202122232425262728293031//在文件：stm32g4xx_it.c中/* USER CODE BEGIN PV */extern uint32_t usled;/* USER CODE END PV */void SysTick_Handler(void)&#123;/* USER CODE BEGIN SysTick_IRQn 0 *//* USER CODE END SysTick_IRQn 0 */ HAL_IncTick();/* USER CODE BEGIN SysTick_IRQn 1 */ usled++;//实现usled每隔1ms自增1/* USER CODE END SysTick_IRQn 1 */&#125;//在文件main.c中/* USER CODE BEGIN PV */uint32_t usled;uint8_t ucled=0x01;/* USER CODE END PV *//* USER CODE BEGIN 3 */Led_Disp(ucled);if(usled&gt;=500)//500ms到&#123; usled=0;//重新计数 ucled^=0x01;//反转led1&#125;/* USER CODE END 3 */ 解决LED引脚冲突问题修改PD2引脚为低电平 将LED显示函数改成如下： 12345678910void Led_Disp(uint8_t ucled)&#123; HAL_GPIO_WritePin(GPIOC,0xFF&lt;&lt;8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC,ucled&lt;&lt;8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);&#125; 增加了重写PD2引脚高低电平的函数 如何单独对一个8bit数的一位进行操作参考文章STM32单片机修改寄存器的位操作方法(全网最全)_单片机单独操作位-CSDN博客 把某位清零 123456//定义一个变量 a = 1001 1111 b (二进制数)unsigned char a = 0x9f;//对 bit2 清零a &amp;= ~(1&lt;&lt;2); 把连续几位清零 123456789//若把 a 中的二进制位分成 2 个一组//即 bit0、bit1 为第 0 组，bit2、bit 为第 1 组，// bit4、bit5 为第 2 组，bit6、bit7 为第 3 组//要对第 1 组的 bit2、bit3 清零a &amp;= ~(3&lt;&lt;2*1);//例如对第 2 组 bit4、bit5 清零a &amp;= ~(3&lt;&lt;2*2); 对某几位赋值 12345//a = 1000 0011 b//此时对清零后的第 2 组 bit4、bit5 设置成二进制数“01 b ”a |= (1&lt;&lt;2*2);//a = 1001 0011 b，成功设置了第 2 组的值，其它组不变 对某位取反 12345//a = 1001 0011 b//把 bit7 取反，其它位不变a ^=(1&lt;&lt;6);//a = 1101 0011 b"},{"title":"LCD","path":"/wiki/lanqiao/LCD.html","content":"嵌入式LCD根据原理图在cubemx配置引脚，初始化lcd。 1234LCD_Init();LCD_Clear(Black);//黑色清屏，不然LCD原本颜色还会残存LCD_SetBackColor(Black);//设置背景色为黑色LCD_SetTextColor(White);//设置前景色为白色 记住要在 MX_GPIO_Init() 之后，否则可能初始化失败。 在lcd屏上显示字符，可以使用 void LCD_DisplayStringLine(u8 Line, u8 *ptr) 例如，显示”Hello World“ 1LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); 或者，可以使用sprintf()函数，前提使用stdio的头文件 12345#include &quot;stdio.h&quot;sprintf(text,&quot; count: %d &quot;,count);LCD_DisplayStringLine(Line4, (uint8_t *)text); 考点1：实现界面切换。以下是一个按键界面切换的基本思路，通过按键来增加界面计数。注意不要将view和count定义成函数的局部变量，否则在每次加载这个函数的时候界面都是第一个界面，无法进行切换。 123456789101112131415161718192021222324252627282930313233343536373839// 全局变量uint8_t view = 0;uint8_t count = 0;void lcd_process(void)&#123; char text[30]; for(uint8_t i = 0;i &lt; 4; i++) &#123; if(key[0].key_isPressed == 1) &#123; view++; key[i].key_isPressed = 0; if(view ==3) &#123; view = 0; &#125; &#125; if(key[1].key_isPressed == 1) &#123; count++; key[1].key_isPressed = 0; &#125; &#125; if(view==0) &#123; LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); &#125; if(view==1) &#123; sprintf(text,&quot; count: %d &quot;,count); LCD_DisplayStringLine(Line4, (uint8_t *)text); &#125; if(view == 2) &#123; LCD_DisplayStringLine(Line4,(unsigned char*)&quot; END &quot;); &#125;&#125; 考点2：文本高亮没啥技术含量，更改对应行的背景颜色和设置行切换标志。使用按键控制行标志位增减。与屏幕界面切换的思路一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243if(view == 1) &#123; char text2[30]; if(line_flag == 0) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; if(line_flag == 1) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; if(line_flag == 2) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; &#125; 注意，当两个界面所需要的行数不同时，比如，界面1只有一行字符串，界面2有三行字符串，需要给界面1增加三行空字符串，即 123456789if(view == 0) &#123; char text1[30]; sprintf(text1,&quot; Hello,world. &quot;); LCD_SetBackColor(Black); LCD_DisplayStringLine(Line4, (uint8_t *)text1); LCD_DisplayStringLine(Line5, (unsigned char *)&quot; &quot;); LCD_DisplayStringLine(Line6, (unsigned char *)&quot; &quot;); &#125; 否则会出现界面之间的字符串串在界面中。"},{"title":"TIM","path":"/wiki/lanqiao/TIM.html","content":"嵌入式TIM考点1：计算输出频率，占空比 关键概念： ARR：自动重装载值（AutoReloader Register） CCRx：捕获寄存器值 CNT：计数器值 PSC：预分频值（Prescaler） 当CNT小于CCRx时，计时器通道TIMx_CHx输出高电平，反之输出低电平 记住！！！ 频率 $=\\frac{\\text{CLK}}{(\\text{PSC+1})(\\text{ARR+1})}$ 占空比 $= \\frac{\\text{CRRx}}{\\text{ARR+1}}$ 公式中，CLK已经在创建工程时设置成了80MHz，而ARR和PSC可以在cubemx中设置，CCRx在程序中设置。 省赛题： 在cubemx中配置PA6和PA7引脚分别为TIMx_CHx通道。 按照下面的步骤修改寄存器的值： 12TIM3-&gt;ARR= //修改定时器3的ARR值，用于修改频率TIM3-&gt;CCRx= //修改定时器3通道x的CCR值，用于修改占空比 对于这题，在keil5中， 先初始化通道： 123456789//初始化HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1); //PA6HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1); //PA//根据寄存器中ARR的值配置频率PA6_frq=10000/(TIM3-&gt;ARR+1);PA7_frq=20000/(TIM17-&gt;ARR+1);//配置占空比，在cubemx ARR+1为100，CRR1的值正好就是对应的百分数TIM3-&gt;CCR1=PA6_duty; //PA6TIM17-&gt;CCR1=PA7_duty; //PA7 配置按键操作： 1234567891011121314if(key[1].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA6_duty+=10; if(PA6_duty==100) PA6_duty=10; TIM3-&gt;CCR1=PA6_duty; key[1].key_isPressed =0; &#125;if(key[2].key_isPressed == 1 &amp;&amp; view == 0) &#123; PA7_duty+=10; if(PA7_duty==100) PA7_duty=10; TIM17-&gt;CCR1=PA7_duty; key[2].key_isPressed = 0; &#125; 配置LCD的显示： 123456789101112if(view == 0) &#123; char buf[20]; sprintf(buf,&quot;PA6_frq:%dHz&quot;,PA6_frq); LCD_DisplayStringLine(Line4,(uint8_t*)buf); sprintf(buf,&quot;PA7_frq:%dHz&quot;,PA7_frq); LCD_DisplayStringLine(Line5,(uint8_t*)buf); sprintf(buf,&quot;PA6_duty:%d%%&quot;,PA6_duty); LCD_DisplayStringLine(Line7,(uint8_t*)buf); sprintf(buf,&quot;PA7_duty:%d%%&quot;,PA7_duty); LCD_DisplayStringLine(Line8,(uint8_t*)buf); &#125; 考点2：输入捕获频率原理是调整信号发生器的频率，对应的分别是PA15和PB4，需要在cubemx中配置定时器输入捕获模式。 以TIM2_CH1为例，需要在cubemx中分别配置两个通道为direct 和 indirect。 记得打开NVIC中断使能 首先需要启动定时器： 1234HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_2); 接着，配置输入捕捉回调函数： 123456789101112131415161718192021void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123; if(htim-&gt;Instance == TIM2) &#123; if(htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) &#123; tim2_val1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); /* 读取通道一，上升沿的值 一个完整的周期 */ tim2_val2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); /* 读取通道二，下降沿的值 一个周期中的高电平 */ __HAL_TIM_SetCounter(htim, 0);/* 清零定时器中的值，继续读取下一周期的脉冲 */ /* 捕获到的频率 = 时钟频率 / 预分频值 / 捕获的值（从0开始直到上升沿产生读的数值） */ tim2_freq = (80000000 / 80) / tim2_val1; /* 捕获的占空比 = 高电平的时间 / 低电平的时间 * 100 */ tim2_duty = ((float)tim2_val2 / tim2_val1) * 100; HAL_TIM_IC_Start(htim, TIM_CHANNEL_1); //重开通道1 HAL_TIM_IC_Start(htim, TIM_CHANNEL_2); //重开通道2 &#125; &#125; &#125; 这里写了TIM2的频率捕获部分，对于TIM3，是一样的。 接下来只需要在LCD中输入显示即可。"},{"title":"RTC","path":"/wiki/lanqiao/RTC.html","content":"嵌入式RTCRTC实时时钟用来获取时间和日期 cubemx RTC配置 其中Calendar Time是当前时间，Calendar Date为当前日期 记住General中的异步分频（APV）是125，同步分频（SPV）是6000 接着，在keil中先配置时间结构体 1234/* USER CODE BEGIN PTD */RTC_TimeTypeDef time; //时间结构体RTC_DateTypeDef date; //日期结构体/* USER CODE END PTD */ 然后在主循环中进行实时计时： 12345678910111213 while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);HAL_RTC_GetDate(&amp;hrtc,&amp;date,RTC_FORMAT_BIN);sprintf(buf,&quot;Date:%2d-%2d-%2d &quot;,date.Year,date.Month,date.Date);LCD_DisplayStringLine(Line1,(uint8_t*)buf);sprintf(buf,&quot;Time:%2d-%2d-%2d &quot;,time.Hours,time.Minutes,time.Seconds);LCD_DisplayStringLine(Line2,(uint8_t*)buf); &#125; /* USER CODE END 3 */"},{"title":"USART","path":"/wiki/lanqiao/USART.html","content":"嵌入式USART先在cubemx配置USART中断，调试时配合串口调试助手。 注意字符串操作要使用string库 考点1：串口发送例如，向上位机发送Hello World! 1234567891011121314151617char tx_buf[20]; //字符缓存区uint8_t rx_data; sprintf(tx_buf,&quot;Hello World!\\r &quot;);HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50);HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)/* * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be sent. * @param Timeout Timeout duration. * @retval HAL status*/ 考点2：串口接收串口接收函数在HAL库中的定义 1234567891011/** * @brief Recive an amount of data in interrupt mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the received data is handled as a set of u16. In this case, Size must indicate the number * of u16 available through pData. * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be received. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 进行串口接收时，我们要编写串口中断函数，函数名和形参不能改，函数本身是空内容，和TIM中断函数一致 1void HAL_UART_RxCpltCallback(UART_HandleTypedef *huart) 串口接收又分为几种，首先是单字符接收，例如，接收不同的单字符来对LED1进行控制： 12345678910111213141516171819202122void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(rx_data==&#x27;O&#x27;) &#123; ucled=0x01; sprintf(tx_buf,&quot;LED1 Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else if(rx_data==&#x27;C&#x27;) &#123; ucled=0x00; sprintf(tx_buf,&quot;LED1 Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else &#123; sprintf(tx_buf,&quot;Error!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); Led_Disp(ucled);&#125; 要提前打开接收中断 123/* USER CODE BEGIN 2 */HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); //打开接收中断/* USER CODE END 2 */ 只要接收中断就会进入串口中断函数 再例如，接收多字符进行LED控制： 12345678910111213141516171819202122232425262728void Usart_Proc(void)&#123; if(rx_count==4) &#123; if(strcmp(rx_buf,&quot;LEDO&quot;)==0) &#123; ucled=0x01; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; if(strcmp(rx_buf,&quot;LEDC&quot;)==0) &#123; ucled=0x00; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; rx_count=0; memset(rx_buf,0,20); //将缓存清空 &#125; &#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; rx_buf[rx_count++]=rx_data; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1);&#125; 在主函数主循环中使用Usart_Proc()函数，同样的，在接收上位机发送的信息后会进入串口中断函数，同样的，要提前打开接收中断。 考点3：sscanf()函数解析字符串12345678int sscanf(const char* str, const char* format, ...);/*参数：str：要解析的输入字符串。format：格式字符串，指定要匹配的格式规则。...：可变参数列表，用于接收解析后的数据。*/ 例如，省赛中解析车牌字符串： 123456789101112131415void Usart_Proc(void)&#123; if(rx_count==22) &#123; sscanf(rx_buf,&quot;%4s:%4s:%12s&quot;,car_type,car_num,car_time); sprintf(tx_buf,&quot;car_type:%4s\\r &quot;,car_type); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_num:%4s\\r &quot;,car_num); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_time:%4s\\r &quot;,car_time); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); rx_count=0; memset(rx_buf,0,20); &#125;&#125;"}]