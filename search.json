[{"path":"/notes/index.html","content":"写在前面笔记喵"},{"title":"ADC","path":"/wiki/lanqiao/ADC.html","content":"嵌入式ADC在cubemx中选择PB12，PB15分别设置为ADC输出模式（ADC1_IN11和ADC2_IN15） 生成代码后，在adc.c文件中写单通道采样函数，需要在adc.h文件中声明 1234567double getADC(ADC_HandleTypeDef *pin)&#123; uint16_t adc; HAL_ADC_Start(pin); adc = HAL_ADC_GetValue(pin); return adc*3.3/4096;&#125; 在主函数中，用ACD_Proc()调用采样功能 12345678void ADC_Proc(void)&#123; char text[20]; adc_value1 = getADC(&amp;hadc1); adc_value2 = getADC(&amp;hadc2); sprintf(text,&quot;ADC1:%.2f,ADC2:%.2f&quot;,adc_value1,adc_value2); LCD_DisplayStringLine(Line4,(uint8_t *)text);&#125; 需要注意的是，记得在adc.c中使用校准函数对采样进行校准，否则采样最大值为3.25V 123456/* USER CODE BEGIN ADC1_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc1,ADC_SINGLE_ENDED);/* USER CODE END ADC1_Init 2 *//* USER CODE BEGIN ADC2_Init 2 */HAL_ADCEx_Calibration_Start(&amp;hadc2,ADC_SINGLE_ENDED);/* USER CODE END ADC2_Init 2 */"},{"title":"KEY","path":"/wiki/lanqiao/KEY.html","content":"嵌入式按键使用按键状态机，在用户区新建Key_State.c和Key_State.h文件。在Key_State.h中，写下 123456789101112131415161718192021222324252627#ifndef __KEY_STATE_H_#define __KEY_STATE_H_#include &quot;main.h&quot;/** * @brief 按键状态结构体 */struct keys&#123; uint8_t judge_state; // 状态机标志，0： 检测到一个低电平；1：确实被按下；2：等待抬起 uint8_t key_state; // 按键是否被按下（信号来自GPIO输入） uint8_t key_isPressed; // 按键短按标志位 uint8_t key_long_flag; // 按键长按标志位 uint32_t key_time; // 按键计时 uint32_t key_double_click_time; // 双击计时器 uint8_t key_double_click_EN; // 双击计时器使能 uint8_t key_double_click_flag; // 双击标志位&#125;;extern struct keys key[];void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);#endif keys结构体即为按键状态机，使用定时中断函数进行按键消抖。 Key_State.c内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &quot;Key_State.h&quot;struct keys key[4] = &#123;0, 0, 0, 0&#125;;/** * @brief TIM定时器定时中断回调函数 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM3) &#123; key[0].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0); key[1].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1); key[2].key_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_2); key[3].key_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0); for (uint8_t i = 0; i &lt; 4; i ++) &#123; if (key[i].key_double_click_EN == 1) // 计数器使能开启时，计时并判断 &#123; key[i].key_double_click_time ++; if (key[i].key_double_click_time &gt; 35) // 如果超时，则说明是短按，置标志位后关闭计数器使能 &#123; key[i].key_isPressed = 1; key[i].key_double_click_EN = 0; &#125; &#125; switch (key[i].judge_state) &#123; case 0: if (key[i].key_state == 0) // 如果刚开始检测到一个低电平 &#123; key[i].key_time = 0; // 时间计数清0 key[i].judge_state = 1; &#125; break; case 1: if (key[i].key_state == 0) // 如果10ms后依然检测到这个按键是低电平，就说明这个按键确实被按下了 &#123; key[i].judge_state = 2; &#125; else &#123; key[i].judge_state = 0; &#125; break; case 2: if (key[i].key_state == 1 &amp;&amp; key[i].key_time &lt;= 70) // 如果是一次短按 &#123; key[i].judge_state = 0; if (key[i].key_double_click_EN == 0) // 如果是第一次按下 &#123; key[i].key_double_click_EN = 1; key[i].key_double_click_time = 0; &#125; else // 双击计时开启，说明这次短按还在双击计时的时间范围内 &#123; key[i].key_double_click_EN = 0; key[i].key_double_click_flag = 1; &#125; &#125; else if (key[i].key_state == 1 &amp;&amp; key[i].key_time &gt; 70) // 长按松开按键，则回到state0 &#123; key[i].judge_state = 0; &#125; else if (key[i].key_state == 0) // 如果按键没有松开，则持续计时 &#123; key[i].key_time ++; if (key[i].key_time &gt; 70) // 如果按键按下时间大于700ms &#123; key[i].key_long_flag = 1; &#125; &#125; break; default: break; &#125; &#125; &#125;&#125; 记住要在cubemx中设置10ms中断，其中PSC预分频是79（80-1），ARR重装预载是9999（10000-1）。"},{"title":"LCD","path":"/wiki/lanqiao/LCD.html","content":"嵌入式LCD根据原理图在cubemx配置引脚，初始化lcd。 1234LCD_Init();LCD_Clear(Black);//黑色清屏，不然LCD原本颜色还会残存LCD_SetBackColor(Black);//设置背景色为黑色LCD_SetTextColor(White);//设置前景色为白色 记住要在 MX_GPIO_Init() 之后，否则可能初始化失败。 在lcd屏上显示字符，可以使用 void LCD_DisplayStringLine(u8 Line, u8 *ptr) 例如，显示”Hello World“ 1LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); 或者，可以使用sprintf()函数，前提使用stdio的头文件 12345#include &quot;stdio.h&quot;sprintf(text,&quot; count: %d &quot;,count);LCD_DisplayStringLine(Line4, (uint8_t *)text); 考点1：实现界面切换。 以下是一个按键界面切换的基本思路，通过按键来增加界面计数。注意不要将view和count定义成函数的局部变量，否则在每次加载这个函数的时候界面都是第一个界面，无法进行切换。 123456789101112131415161718192021222324252627282930313233343536373839// 全局变量uint8_t view = 0;uint8_t count = 0;void lcd_process(void)&#123; char text[30]; for(uint8_t i = 0;i &lt; 4; i++) &#123; if(key[0].key_isPressed == 1) &#123; view++; key[i].key_isPressed = 0; if(view ==3) &#123; view = 0; &#125; &#125; if(key[1].key_isPressed == 1) &#123; count++; key[1].key_isPressed = 0; &#125; &#125; if(view==0) &#123; LCD_DisplayStringLine(Line4, (unsigned char *)&quot; Hello,world. &quot;); &#125; if(view==1) &#123; sprintf(text,&quot; count: %d &quot;,count); LCD_DisplayStringLine(Line4, (uint8_t *)text); &#125; if(view == 2) &#123; LCD_DisplayStringLine(Line4,(unsigned char*)&quot; END &quot;); &#125;&#125; 考点2：文本高亮 没啥技术含量，更改对应行的背景颜色和设置行切换标志 12345678910111213141516171819202122232425262728293031323334353637383940414243if(view == 1) &#123; char text2[30]; if(line_flag == 0) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count1:%d &quot;,count1); LCD_DisplayStringLine(Line4,(uint8_t *)text2); &#125; if(line_flag == 1) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count2:%d &quot;,count2); LCD_DisplayStringLine(Line5,(uint8_t *)text2); &#125; if(line_flag == 2) &#123; LCD_SetBackColor(Green); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; else &#123; LCD_SetBackColor(Black); sprintf(text2,&quot; count3:%d &quot;,count3); LCD_DisplayStringLine(Line6,(uint8_t *)text2); &#125; &#125; 注意，当两个界面所需要的行数不同时，比如，界面1只有一行字符串，界面2有三行字符串，需要给界面1增加三行空字符串，即 123456789if(view == 0) &#123; char text1[30]; sprintf(text1,&quot; Hello,world. &quot;); LCD_SetBackColor(Black); LCD_DisplayStringLine(Line4, (uint8_t *)text1); LCD_DisplayStringLine(Line5, (unsigned char *)&quot; &quot;); LCD_DisplayStringLine(Line6, (unsigned char *)&quot; &quot;); &#125; 否则会出现界面之间的字符串串在界面中。"},{"title":"USART","path":"/wiki/lanqiao/USART.html","content":"嵌入式USART先在cubemx配置USART中断，调试时配合串口调试助手。 注意字符串操作要使用string库 考点1：串口发送例如，向上位机发送Hello World! 1234567891011121314151617char tx_buf[20]; //字符缓存区uint8_t rx_data; sprintf(tx_buf,&quot;Hello World!\\r &quot;);HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50);HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)/* * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be sent. * @param Timeout Timeout duration. * @retval HAL status*/ 考点2：串口接收串口接收函数在HAL库中的定义 1234567891011/** * @brief Recive an amount of data in interrupt mode. * @note When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01), * the received data is handled as a set of u16. In this case, Size must indicate the number * of u16 available through pData. * @param huart UART handle. * @param pData Pointer to data buffer (u8 or u16 data elements). * @param Size Amount of data elements (u8 or u16) to be received. * @retval HAL status */HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 进行串口接收时，我们要编写串口中断函数，函数名和形参不能改，函数本身是空内容，和TIM中断函数一致 1void HAL_UART_RxCpltCallback(UART_HandleTypedef *huart) 串口接收又分为几种，首先是单字符接收，例如，接收不同的单字符来对LED1进行控制： 12345678910111213141516171819202122void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(rx_data==&#x27;O&#x27;) &#123; ucled=0x01; sprintf(tx_buf,&quot;LED1 Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else if(rx_data==&#x27;C&#x27;) &#123; ucled=0x00; sprintf(tx_buf,&quot;LED1 Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; else &#123; sprintf(tx_buf,&quot;Error!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); Led_Disp(ucled);&#125; 要提前打开接收中断 123/* USER CODE BEGIN 2 */HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1); //打开接收中断/* USER CODE END 2 */ 只要接收中断就会进入串口中断函数 再例如，接收多字符进行LED控制： 12345678910111213141516171819202122232425262728void Usart_Proc(void)&#123; if(rx_count==4) &#123; if(strcmp(rx_buf,&quot;LEDO&quot;)==0) &#123; ucled=0x01; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Open!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; if(strcmp(rx_buf,&quot;LEDC&quot;)==0) &#123; ucled=0x00; Led_Disp(ucled); sprintf(tx_buf,&quot;LED Close!\\r &quot;); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); &#125; rx_count=0; memset(rx_buf,0,20); //将缓存清空 &#125; &#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; rx_buf[rx_count++]=rx_data; HAL_UART_Receive_IT(&amp;huart1,&amp;rx_data,1);&#125; 在主函数主循环中使用Usart_Proc()函数，同样的，在接收上位机发送的信息后会进入串口中断函数，同样的，要提前打开接收中断。 考点3：sscanf()函数解析字符串12345678int sscanf(const char* str, const char* format, ...);/*参数：str：要解析的输入字符串。format：格式字符串，指定要匹配的格式规则。...：可变参数列表，用于接收解析后的数据。*/ 例如，省赛中解析车牌字符串： 123456789101112131415void Usart_Proc(void)&#123; if(rx_count==22) &#123; sscanf(rx_buf,&quot;%4s:%4s:%12s&quot;,car_type,car_num,car_time); sprintf(tx_buf,&quot;car_type:%4s\\r &quot;,car_type); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_num:%4s\\r &quot;,car_num); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); sprintf(tx_buf,&quot;car_time:%4s\\r &quot;,car_time); HAL_UART_Transmit(&amp;huart1,(uint8_t*)tx_buf,strlen(tx_buf),50); rx_count=0; memset(rx_buf,0,20); &#125;&#125;"},{"title":"LED","path":"/wiki/lanqiao/LED.html","content":"LED操作在cubemx中配置时钟和引脚，LED低电平有效 注意要打开PD2锁存器 基本写法： 123456void LED(uint8_t dsled)&#123; HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET); //打开锁存器 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_All, GPIO_PIN_SET); //灭掉所有的LED HAL_GPIO_WritePin(GPIOC, dsled&lt;&lt;8, GPIO_PIN_RESET); //选择特定的LED亮起&#125; 其中dsled是8位无符号数，0x_ _。 高位即为左边四个led，低位即为右边四个led。每一位取1即为该led亮。 LED交替闪烁和LED闪烁取反 ~ 左四位和右四位交替闪烁 取异或^该位led闪烁 1234567891011uint8_t ucLed=0x0f; //交替闪烁LED(~ucLed); //闪烁uint8_t ucLed2 = 0x0f;LED(ucLed2);HAL_Delay(1000);ucLed2^=0x0f; LED实现流水灯位运算左移和右移（&lt;&lt;和&gt;&gt;） Systick 滴答计时HAL_Delay()是阻塞赋值，可以使用Systick进行计时，Systick进行了已经设置了1ms的中断。 计时方式 12345678910111213141516171819202122232425262728293031//在文件：stm32g4xx_it.c中/* USER CODE BEGIN PV */extern uint32_t usled;/* USER CODE END PV */void SysTick_Handler(void)&#123;/* USER CODE BEGIN SysTick_IRQn 0 *//* USER CODE END SysTick_IRQn 0 */ HAL_IncTick();/* USER CODE BEGIN SysTick_IRQn 1 */ usled++;//实现usled每隔1ms自增1/* USER CODE END SysTick_IRQn 1 */&#125;//在文件main.c中/* USER CODE BEGIN PV */uint32_t usled;uint8_t ucled=0x01;/* USER CODE END PV *//* USER CODE BEGIN 3 */Led_Disp(ucled);if(usled&gt;=500)//500ms到&#123; usled=0;//重新计数 ucled^=0x01;//反转led1&#125;/* USER CODE END 3 */ 解决LED引脚冲突问题修改PD2引脚为低电平 将LED显示函数改成如下： 12345678910void Led_Disp(uint8_t ucled)&#123; HAL_GPIO_WritePin(GPIOC,0xFF&lt;&lt;8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOC,ucled&lt;&lt;8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);&#125; 增加了重写PD2引脚高低电平的函数"}]